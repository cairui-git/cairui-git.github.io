<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法题-数组实现队列]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目使用数组实现队列结构，实现方法： add(向队尾添加元素) poll(返回队首元素，并移除) peek(返回队首元素) 思路 创建两个指针start、end和一个变量size，初始值都为0 start表示队首元素的位置 end表示下一个元素入队时要添加的位置 size表示队列大小 start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 使用数组实现队列 * @author CaiRui * @time 2019-10-23 */public class ArrayBecomeQueue &#123; private int[] arr; private int start = 0; private int end = 0; private int size = 0; public ArrayBecomeQueue() &#123; arr = new int[50]; &#125; public ArrayBecomeQueue(int initSize) &#123; arr = new int[initSize]; &#125; //添加一个元素到队尾 public boolean add(int num) &#123; if (size == arr.length) &#123; throw new ArrayIndexOutOfBoundsException("队列已满"); &#125; size++; arr[end] = num; end = (end == arr.length - 1) ? 0 : ++end; return true; &#125; //获取队首元素，并移除 public int poll() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("队列为空"); &#125; size--; int result = arr[start]; start = start == arr.length - 1 ? 0 : ++start; return result; &#125; //获取队首元素 public int peek() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("队列为空"); &#125; return arr[start]; &#125; public static void main(String[] args) &#123; //预计输出：1 1 2 3 3 ArrayBecomeQueue queue = new ArrayBecomeQueue(5); queue.add(1); queue.add(2); queue.add(3); System.out.println(queue.peek()); queue.add(4); System.out.println(queue.poll()); System.out.println(queue.poll()); queue.add(5); queue.add(6); System.out.println(queue.peek()); System.out.println(queue.poll()); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相邻两数最大差值]]></title>
    <url>%2F2019%2F10%2F22%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n) 举个例子： 给定数组：{4,5,1,2} 排好序后的数组是：{1,2,4,5} 相邻两数的差值分别为：1,2,1 需要返回最大差值，所以最终结果就是2 暴力解法先把数组排序，再遍历数组求出所有差值，返回最大的那一个 123456789101112131415//暴力解法 O(n*logn)private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result;&#125; 由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用 标准解法这里利用了桶的概念，但没有进行桶排序 思路： 假设数组中有N个数，创建N+1个桶 遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶 然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中 (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5) 这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 产生最大差值的两个相邻数绝对不会来自于相同桶 有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了 所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值 * @author CaiRui * @time 2019-10-21 */public class BorderCount &#123; //O(n) private static int getBorderCount(int[] arr) &#123; //过滤非法数据 if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; //借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶 int[] min = new int[arr.length+1]; int[] max = new int[arr.length+1]; //记录桶是否为空 boolean[] existNumber = new boolean[arr.length+1]; //最小值和最大值相等：返回0 HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr); int minNum = criticalMap.get("Min"); int maxNum = criticalMap.get("Max"); if (minNum == maxNum) &#123; return 0; &#125; //最小值放在第一个桶，最大值放在最后一个桶 min[0] = minNum; max[0] = minNum; existNumber[0] = true; min[min.length-1] = maxNum; max[max.length-1] = maxNum; existNumber[existNumber.length-1] = true; //每个桶中存放的数值范围 double scope = (double) (min[min.length-1] - min[0])/min.length; //元素入桶 for (int num : arr) &#123; if (num == min[0] || num == max[max.length - 1]) &#123; continue; &#125; //该元素应该存放的下标 int index = (int) Math.ceil((num - min[0]) / scope)-1; if (!existNumber[index]) &#123; min[index] = num; max[index] = num; existNumber[index] = true; &#125; else &#123; if (num &gt; max[index]) &#123; max[index] = num; &#125; else if (num &lt; min[index]) &#123; min[index] = num; &#125; &#125; &#125; //记录非空桶的坐标 List&lt;Integer&gt; existIndex = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; existNumber.length;i++) &#123; if (existNumber[i]) &#123; existIndex.add(i); &#125; &#125; //计算最大差值 int maxBorderCount = max[0] - min[0]; for (int i = 0;i &lt; existIndex.size() - 1;i++) &#123; int border = min[existIndex.get(i+1)] - max[existIndex.get(i)]; if (border &gt; maxBorderCount) &#123; maxBorderCount = border; &#125; &#125; return maxBorderCount; &#125; //获取最大值和最小值 private static HashMap&lt;String,Integer&gt; getMaxAndMin(int[] arr) &#123; HashMap&lt;String,Integer&gt; result = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int num : arr) &#123; max = Math.max(max,num); min = Math.min(min,num); &#125; result.put("Max",max); result.put("Min",min); return result; &#125; //暴力解法 O(n*logn) private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; int testCount = 10000; boolean is_success = true; for (int i = 0;i &lt; testCount;i++) &#123; int[] arr = ArrayUtil.getArray(10,0,20); int[] arr1 = ArrayUtil.copyArray(arr); int[] arr2 = ArrayUtil.copyArray(arr); int border1 = BorderCount.getBorderCount(arr1); int border2 = BorderCount.testMethod(arr2); if (border1 != border2) &#123; is_success = false; break; &#125; &#125; if (is_success) &#123; System.out.println("Success"); &#125; else &#123; System.out.println("Fail"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序堆排序是利用堆结构的特点来设计的一种排序算法。 思路 首先将整个数组构建成大根堆 依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置 在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组 当堆中所有元素弹出完毕，此时数组已全部有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 堆排序 * @author Cai Rui * @time 2019-10-17 */public class HeapSort &#123; public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; Heap.buildBigHeap(arr,arr.length,0); for (int i = 0;i &lt; arr.length;i++) &#123; Heap.heapPop(arr,arr.length-i,0); &#125; &#125;&#125;/** * 堆结构 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param length 堆的大小 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int length,int heapType)&#123; if (arr == null || length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType)&#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; ArrayUtil.swap(arr,0,length-1); heapFalling(arr,length-2,heapType); return result; &#125; /** * 向堆中添加一个元素 * @param arr 数组中(0 ~ index-1)为堆结构 * @param index 元素下标 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void heapInsert(int[] arr,int index,int heapType)&#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; ArrayUtil.swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType)&#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; &#125; else &#123; ArrayUtil.swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n*logn); 平均时间复杂度: O(n*logn) 空间复杂度: O(1) 稳定性分析不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 完全二叉树首先堆的结构是一颗 完全二叉树 完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图： 在程序中，我们可以使用数组结构来抽象出一颗完全二叉树： 数组中的0位置代表根节点 假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为： 左孩子：2*i+1 右孩子：2*i+2 假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为： 父节点：(i-1)/2 根节点的父节点是自己：(0-1)/2 = 0 使用上面的抽象规则，我们就可以把 任意数组抽象为一颗完全二叉树。 构建推结构堆分为两种： 大根堆：在一颗完全二叉树中，任何一颗子树的 最大值 都是头部 小根堆：在一颗完全二叉树中，任何一颗子树的 最小值 都是头部 以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？ 步骤： 首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中 后面通过遍历数组，将每个元素依次进堆 进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止 数组中所有元素进堆完毕，则大根堆构建完成 时间复杂度：O(n) 弹出堆顶元素在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。 步骤： 将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中 对此时的堆顶元素进行下沉操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉) 下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子(如果没有右孩子就不比较，但一定有左孩子) 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉 堆顶元素下沉完毕后，此时又重新构建好了堆结构 时间复杂度：O(logn) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * 堆 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int heapType) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; arr.length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType) &#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; swap(arr,0,length); heapFalling(arr,length-1,heapType); return result; &#125; private static void heapInsert(int[] arr,int index,int heapType) &#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType) &#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; &#125; else &#123; swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125; private static void swap(int[] arr,int a,int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; public static void main(String[] args) &#123; int[] arr = &#123;5,1,4,5,8,2,5,6,54,9,7,5,2,0&#125;; Heap.buildBigHeap(arr,1); ArrayUtil.printArray(arr); int min = Heap.heapPop(arr,arr.length-1,1); System.out.println(min); ArrayUtil.printArray(arr); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-快速排序]]></title>
    <url>%2F2019%2F10%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 思路 选取数组中的中的一个数作为基准数，然后将数组调整为两部分：左部分的数全部小于等于基准数、右部分的数全部大于基准数(子序列中内部不需要有序) 递归的对数组两个部分继续执行上述步骤，直至数组有序 改进 将数组划分为三个部分，小于、等于、大于区域 (具体实现) 这时等于区域的数就已经位于理想的位置，因此只需要递归小于区域和大于区域 (在有很多重复数字的情况下效率提升会很明显) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 快速排序 * @author cairui * @time 2019-10-11 */public class QuickSort &#123; public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr, 0, arr.length-1); &#125; //递归函数 private static void quickSort(int[] arr,int left,int right) &#123; if (left &gt;= right) &#123; return; &#125; int[] index = grouping(arr,left,right); //递归小于区域和大于区域 quickSort(arr,left,index[0]); quickSort(arr,index[1],right); &#125; //划分出小于、等于、大于区域 private static int[] grouping(int[] arr, int left, int right) &#123; int indexFront = left; int indexMid = left; int indexRear = right; int num = arr[right]; while (true) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr, indexMid, indexFront); if (indexMid + 1 &gt; indexRear) break; indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; if (indexMid + 1 &gt; indexRear) break; indexMid++; &#125; else &#123; if (indexMid &gt; indexRear - 1) break; swap(arr, indexMid, indexRear); indexRear--; &#125; &#125; //返回临界值坐标 int[] index = new int[2]; index[0] = (arr[indexFront] == num) ? (indexFront - 1) : indexFront; index[1] = (arr[indexRear] == num) ? (indexRear + 1) : indexRear; return index; &#125; private static void swap(int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n2); (快排在最差情况下会退化为冒泡) 平均时间复杂度: O(n*logn) 空间复杂度: O(logn) 稳定性分析不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-向git推送更新失败]]></title>
    <url>%2F2019%2F10%2F11%2FHexo-%E5%90%91git%E6%8E%A8%E9%80%81%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[今天在更新博客时发生了 hexo d 时推送失败的情况。 报错信息: 12Connection reset by 52.74.223.119 port 22fatal: Could not read from remote repository. 这表示git客户端无法连接至github，原因大概是防火墙禁止了ip为52.74.223.119端口22的ssh连接 解决方法： (1) 我的解决的方法是切换网络，将wifi切成手机热点就提交成功了。 (2) 如果条件不允许或者切换网络依旧不成功，需要手动将防火墙中的 22端口设置为允许连接 具体操作请参考]]></content>
      <categories>
        <category>问题整理</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荷兰国旗问题]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。 常见思路常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。 代码： 1234567891011121314151617181920212223242526//常见思路 时间复杂度(n) 空间复杂度O(n)private static void badMethod(@NotNull int[] arr, int num)&#123; int index = 0; List&lt;Integer&gt; alist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; blist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; clist = new ArrayList&lt;&gt;(); for (int n : arr) &#123; if (n&lt;num) &#123; alist.add(n); &#125; else if (n==num) &#123; blist.add(n); &#125; else &#123; clist.add(n); &#125; &#125; index = setArray(arr,index,alist); index = setArray(arr,index,blist); setArray(arr,index,clist);&#125;private static int setArray(int[] arr, int index, @NotNull List&lt;Integer&gt; list)&#123; for (Integer integer : list) &#123; arr[index++] = integer; &#125; return index;&#125; 改进上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级： 123456789101112131415161718192021222324//空间复杂度改进为O(1)的方法private static void dutchFlag(@NotNull int[] arr, int num)&#123; int indexFront = 0; int indexMid = 0; int indexRear = arr.length-1; while (indexMid &lt;= indexRear) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr,indexMid,indexFront); indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; indexMid++; &#125; else &#123; swap(arr,indexMid,indexRear); indexRear--; &#125; &#125;&#125;private static void swap(@NotNull int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125; 使用三个指针，交换全部在数组内部进行，三个指针的含义为： indexFront : 指针前面的所有数都满足小于num indexMid : 指针前面所有的数都满足小于等于num indexRear : 指针后面所有的数都满足大于num 终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA-批量修改变量名]]></title>
    <url>%2F2019%2F10%2F11%2FIDEA-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[双击选中修改对象后： Shift+F6 变量名填写完成后按回车执行修改]]></content>
      <tags>
        <tag>IDEA快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小和问题]]></title>
    <url>%2F2019%2F09%2F27%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。 现在给出一个数组请求出数组的小和。 例子数组：[1,3,4,2,5] 1左边比1小的数，没有； 3左边比3小的数，1； 4左边比4小的数，1、3； 2左边比2小的数，1； 5左边比5小的数，1、3、4、2； 所以小和为1+1+3+1+1+3+4+2=16 常见思路常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。 12345678910//常见思路,O(n2)的方法int badMethod(int[] arr)&#123; int smallSum = 0; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(arr[i]&gt;arr[j]) smallSum += arr[j]; &#125; &#125; return smallSum;&#125; 但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进 改进在归并排序的基础上进行改进，在merge左右两个有序数组时候，如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。 1234567891011121314151617181920212223242526272829303132333435363738394041//利用分治思想,O(n*logn)的方法private static int getSmallSum(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return 0; &#125; return getSmallSum(arr,0,arr.length-1);&#125;//递归private static int getSmallSum(int[] arr, int left, int right)&#123; if(left&gt;=right)&#123; return 0; &#125; int mid = left - (left-right)/2; return getSmallSum(arr,left,mid) + getSmallSum(arr,mid+1,right) + merge(arr,left,mid,right);&#125;private static int merge(int[] arr,int left,int mid,int right)&#123; int smallSum = 0; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; //左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数) smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+1) * arr[index_left] : 0; merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); return smallSum;&#125; 此时算法的时间复杂度就提升到了O(n*logn)的级别]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。 思路 将数组分解为各含n/2个元素的子数组，递归的拆分数组，当子数组长度为1时，默认子数组是就有序的 将两个有序的数组通过外排合并为一个有序的数组 当全部子数组合并完成时，原数组变为有序 图解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 归并排序 * author:Cai Rui * date:2019-09-27 */class MergeSort &#123; static void mergeSort(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return; &#125; mergeSort(arr,0,arr.length-1); &#125; //递归 private static void mergeSort(int[] arr,int left,int right)&#123; if(left&gt;=right)&#123; return; &#125; int mid = left - (left-right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); merge(arr,left,mid,right); &#125; private static void merge(int[] arr,int left,int mid,int right)&#123; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; merge_arr[index_merge++] = (arr[index_left] &gt; arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ;最差时间复杂度: O(n*logn) ;平均时间复杂度: O(n*logn) 空间复杂度: O(n) 稳定性分析稳定(在外排过程中，当遇到相等元素先存左边的数，就可以保证排序结果是稳定的)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖倒置原则]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD. 定义High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 翻译过来就是： 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 每一个逻辑的具体实现就是低层模块(一般指方法)，各种逻辑的组装就是高层模块。 抽象是指接口或者抽象类，属于不能被示例化的；细节就是可以被实例化的实现类，一般指实现接口或继承抽象类的类。 依赖倒置原则在开发过程中的体现就是： 模块间的依赖通过抽象发生，实现类之间不直接发生依赖，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 应用看一个应用到依赖倒置原则的例子： 下图是在不使用依赖倒置原则的情况下，奔驰车和驾车司机的类图设计：奔驰车中提供run方法，表示车辆运行： 12345public class Benz &#123; public void run()&#123; System.out.println("奔驰汽车开始运行..."); &#125;&#125; 司机通过调用奔驰车的run方法来驾驶奔驰车： 12345public class Driver &#123; public void drive(Benz benz)&#123; benz.run(); &#125;&#125; 司机驾驶奔驰汽车的场景如下： 1234567public class Client &#123; public static void main(String[] args) &#123; Driver driver = new Driver(); Benz benz = new Benz(); driver.drive(benz); &#125;&#125; 以上代码实现了司机开动奔驰车的功能，目前为止程序的功能没有任何问题。 此时如果我们现在不仅有奔驰车，又添加了一辆宝马车，代码如下： 12345public class BMW &#123; public void run()&#123; System.out.println("宝马汽车开始运行..."); &#125;&#125; 有了宝马车之后，我们发现司机竟然没有办法把宝马车开动起来，这是因为目前的司机和奔驰车是紧耦合的关系，要想让司机开动奔驰车就必须修改司机类的代码，被依赖者的变更竟然需要依赖者来承担修改的代价，可见上面的程序稳定性和可维护性都是非常差的 在比较大一些项目开发中，团队中每个人都会负责不同的模块，这里假设这个项目的团队中甲负责汽车类的维护，乙负责司机类的维护，如果按照上面的思路开发，那么在甲开发完成之前乙是不能编写drive方法，因为缺少汽车类，所以此时团队的开发工作是无法做到并行开发的，这严重影响了项目的开发效率 为了解决以上问题，对该项目引入依赖倒置原则后的类图如图所示： 列出采用依赖倒置原则的三种写法： (1)构造函数传入依赖对象 12345678910111213public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public Driver(ICar _car)&#123; this.car = _car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 通过构造函数来设置驾驶汽车的类型 (2)set方法传递依赖对象 1234567891011121314public interface IDriver &#123; public void setCar(ICar car); public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 在执行drive方法之前通过setCar方法来指定汽车的类型 (3)接口声明依赖对象 12345678910111213141516171819202122232425public interface IDriver &#123; public void drive(ICar car);&#125;public class Driver implements IDriver&#123; public void drive(ICar car)&#123; car.run(); &#125;&#125;public interface ICar &#123; public void run();&#125;public class Benz implements ICar&#123; public void run()&#123; System.out.println("奔驰汽车开始运行..."); &#125;&#125;public class BMW implements ICar&#123; public void run()&#123; System.out.println("宝马汽车开始运行..."); &#125;&#125; 业务场景实现： 1234567public class Client &#123; public static void main(String[] args) &#123; IDriver zhangSan = new Driver(); ICar benz = new Benz(); zhangSan.drive(benz); &#125;&#125; 小结为什么是依赖“倒置”：以正常人的思维方式，类之间的依赖关系是实现类之间的依赖，例如司机要开奔驰车，就直接依赖奔驰车，这种就属于“正置”；在编写程序中我们要做到的是对现实世界的事物进行抽象，来实现扩展性和维护性更高的代码，抽象就是抽象类和接口，让我们的的系统产生对抽象的依赖，代替正常人们传统的思维方式(对事物的依赖)，这就是“倒置”的含义 采用依赖倒置原则带来的好处： 减少类间的耦合性 提高系统的稳定性 降低并行开发的风险 提高代码的可读性和可维护性 在项目开发中应遵循： 实体类尽量有接口或抽象类：有抽象才能进行依赖倒置 变量的表面类型尽量是接口或抽象类 不要从具体类中派生出子类 尽量不重写父类的方法：对依赖的稳定性会有影响 采用依赖倒置原则的优势在小型项目中很难体现，一般适用于大中型项目，让项目在后续的扩展和维护中更加方便快捷稳定。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少 思路 第一个数默认已经排好序 从第二数开始，依次和前面的数比较，遇到比自己大的就交换，遇到比自己小的或者已经到了数组头部时停止(相当于把自己插入到了正确的位置，比自己大的数往后挪了一位) 遍历数组，重复以上步骤 图解 代码12345678910111213141516171819202122public class InsertSort &#123; //插入排序 public static void insertSort(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&gt;arr[j-1])&#123; break; &#125; swap(arr,j,j-1); &#125; &#125; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2) 思路 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾 以此类推，直到全部待排序的数据元素的个数为零 图解 代码12345678910111213141516171819202122public class SelectSort &#123; //选择排序 public static int[] selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; int min_index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; min_index = arr[j]&lt;arr[min_index] ? j : min_index; &#125; swap(arr,i,min_index); &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n2) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析举例： 排序前：3(1号) , 3(2号) , 1 排序后：1 , 3(2号) , 3(1号) 不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对数器]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%AF%B9%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。 下面一个例子，是利用系统已有的排序函数(绝对正确的方法)来验证我自己写的排序函数mySort(正确性未知的,我们要验证的方法)的正确性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.Arrays;public class SortTest &#123; /** * 获取一个随机数组 * @param length 数组最大长度,最小为0 * @param min 最小值 * @param max 最大值 */ private static int[] getArray(int length,int min,int max)&#123; int[] arr = new int[(int)(0+Math.random()*(length+1))]; for(int i=0;i&lt;length;i++)&#123; arr[i] = (int)(min+Math.random()*(max-min+1)); &#125; return arr; &#125; //复制数组 private static int[] copyArray(int[] arr)&#123; int[] result = new int[arr.length]; for(int i=0;i&lt;arr.length;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; //比较两个数组是否相等 private static boolean isEqualsArray(int[] arr1,int[] arr2)&#123; if(arr1.length!=arr2.length)&#123; return false; &#125; for(int i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; return false; &#125; &#125; return true; &#125; //输出数组 private static void printArray(int[] arr)&#123; for(int num : arr)&#123; System.out.print(num+" "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; boolean is_right = true; int[] fail_array = new int[10]; //测试次数 int test_num = 100000; for(int i=0;i&lt;test_num;i++)&#123; //生成一个长度为 0~10，值为 1~20之间的随机数组,并生成两个复制来进行排序 int[] arr = SortTest.getArray(10, 1, 20); int[] arrA = SortTest.copyArray(arr1); int[] arrB = SortTest.copyArray(arr1); //执行排序 Arrays.sort(arrA); MySort.mySort(arrB); //比较结果是否相等 if(!SortTest.isEqualsArray(arrA, arrB))&#123; is_right = false; fail_array = arr; break; &#125; &#125; if(is_right)&#123; System.out.println("Success!"); &#125;else&#123; System.out.println("Fail!"); System.out.println(); System.out.print("Fail Array:"); SortTest.printArray(fail_array); &#125; &#125;&#125; 校验mySort步骤： 生成一个长度随机，值也随机的数组 获取两个刚刚随机生成的数组的复制，分别用正确的sort方法和待验证的mysort方法进行排序 比较排好序的两个数组是否相等 若不相等则说明算法是错的，把排序失败的数组打印出来，方便排查问题出在哪 相等则说明该条测试用例可以通过，继续重复以上步骤，我这里重复了10万次，当然次数越多越好，这样几乎可以涵盖所有的可能，可以说明该算法是正确的 对数器的好处在于测试用例不再需要自己设计了，通过随机生成的庞大样本量，就可以保证算法的正确性，自己想测试用例的话总会出现情况考虑不全的时候，到时程序出bug的话就得不偿失了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[里氏替换原则]]></title>
    <url>%2F2019%2F09%2F19%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。 定义那什么是里氏替换原则呢？它有两种定义： 第一种：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为什么发生变化，那么类型S是类型T的子类型) 第二种：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明的使用其子类的对象) 第一种是比较官方、正宗的定义，不是很好理解，感觉像是高数里面的某种概念。我们看第二种，第二种是定义是比较清晰的，解释一下就是：所有可以使用父类的地方，把父类替换为子类后，程序运行时不会体现出任何的异常，使用者甚至不需要关心使用的是父类和子类。 但反过来就未必可以，使用子类的地方换成父类就不能保证程序不会出错，因为子类可以有父类没有的属性和方法。 继承的使用规范知道了什么是里氏替换原则，那么具体应该怎么做呢？ (1)子类必须完全实现父类的方法： 如果子类不能完整的实现父类的方法，或者父类的方法不适合该子类，这种情况下继承带来的效果就属于弊大于利，因为子类无法完整地实现父类的业务，此时建议解除继承关系，采用依赖、聚集、组合等关系代替来继承。 (2)覆盖或实现父类的方法时输入参数可以被放大，不可以被缩小： 例如： 123456789101112131415public class Father &#123; public void doSomething(HashMap map)&#123; System.out.println("父类被执行"); &#125;&#125;public class Son extends Father &#123; public void doSomething(Map map)&#123; System.out.println("子类被执行"); &#125;&#125; 子类实现了一个和父类同名的方法，虽然方法名相同，但方法的输入参数不同，这样的方式就保证了子类对父类的方法进行了 重载 而非 重写 ，看具体的场景： 1234567891011public class Client &#123; public static void main(String[] args) &#123; Father f = new Father(); Son s = new Son(); HashMap hashmap = new HashMap(); f.doSomething(hashmap); s.doSomething(hashmap); &#125;&#125; 执行结果： 12父类被执行父类被执行 可以看到我们把调用父类的地方换成了子类，结果依然调用了父类的方法，对程序和业务逻辑没有造成影响，这样就符合了里氏替换原则。 如果子类的参数范围缩小的话，在引用里氏替换原则后执行结果就会变为 子类被执行，这样就会引起物业逻辑混乱，因为父类已经抽象好了方法，而子类“曲解”了父类的意图。 所以子类的覆写父类的方法时，只能让输入参数的范围扩大或相同，不能缩小。 (3)重写父类的方法时输出结果可以被缩小，不能扩大 小结采用里氏替换原则的目的就是增强程序的健壮性，在版本升级时也可以保持非常好的兼容性。保证即使增加子类，原有的子类也可以正常运行。在实际项目中每个子类在同的业务中，使用父类作为参数来实现不同的业务逻辑。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈继承的特点]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%B5%85%E8%B0%88%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。 特点： 子类继承后自动拥有父类所有的非private属性和方法,父类的构造方法无法被继承 子类可以拥有自己的属性和方法 子类可以重写从父类继承过来的方法，但方法的访问权限只能扩大或不变，不能缩小(public&gt;protect&gt;(默认)&gt;private) 当创建一个子类对象时，会先调用父类的构造方法，再调用子类的构造方法 被关键字final修饰的类无法被继承 支持向下转型，例如：123//通过父类创建子类Person person = new Teacher();Teacher teacher = (Teacher)p; 优点： 提高代码的复用性，减少工作量 提高代码的可读性，让层次更清晰 提高代码的易维护性：所有子类共用父类的方法，方法变更时只需修改父类一处 提高代码的拓展性：子类可实现特有的方法 缺点： 继承是侵入的，只要继承，子类就必须拥有父类的所有非私有的属性和方法 继承是高耦合的形式：当父类修改方法时，需要考虑对所有子类的影响，如果有子类重写了该方法，可能会造成非常严重的后果]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止 思路 比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数 重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数 针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; //冒泡排序 public static int[] bubbleSort(int[] arr)&#123; for(int i=0;i&lt;=arr.length;i++)&#123; boolean is_change = false; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr, j, j+1); is_change = true; &#125; &#125; //如果一次完整的遍历中,没有触发过交换，则数组已经有序 if(!is_change)&#123; break; &#125; &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用数据结构&应用场景]]></title>
    <url>%2F2019%2F09%2F12%2FRedis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。 应用场景String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。 Hash常用命令 hget($key,$field) 返回hash表中指定字段的值 hset($key,$field,$value) 设置hash中指定字段的值 hgetall($key) 返回指定key下，哈希表中所有字段和值 实现Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。 应用场景当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。 List常用命令 lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部 rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部 lpop($key) 移除指定列表的第一个元素 rpop($key) 移除指定列表的最后一个元素 lrange($key,$start,$stop) 获取指定列表指定范围内的元素 blpop($key,$timeOut) 移除指定列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 实现Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。 应用场景最新消息排行; 消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。 SetSet集合的特点是在插入元素时Redis会提供去重的功能 常用命令 sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，已经存在与集合中的元素将被忽略 spop($key) 移除集合中的一个随机元素 srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略 smembers($key) 获取指定集合中的所有元素 sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集 sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集 实现set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重 应用场景用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。 SortSet有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点 常用方法 zadd($key,$score,$value) 将一个或多个元素及其分数值加入到有序集合中，重复的元素只更新分数，并按分数重新对集合排序 zrange($key,$start,$end) 获取有序集合中指定区间内的成员信息 zrem($key,$member) 移除一个或多个成员，不存在的成员会忽略，不存在的key或key不是有序集合会返回错误 zcard($key) 获取指定有序集合中元素的数量 实现sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。 应用场景可以用于需要不重复、有序的场景中。例如各种排行榜 延迟队列]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中字符串与0比较问题]]></title>
    <url>%2F2019%2F09%2F06%2Fphp%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E0%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = "CaiRui";if($str==0)&#123; echo "==0成立";&#125;else&#123; echo "==0不成立";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = "CaiRui";if($str===0)&#123; echo "===0成立";&#125;else&#123; echo "===0不成立";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = "CaiRui";if($str=="0")&#123; echo "==0成立";&#125;else&#123; echo "==0不成立";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。]]></content>
      <categories>
        <category>问题整理</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单一职责原则]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine("拍照片"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine("播放音乐"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine("播放音乐"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine("拍照片"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式开篇]]></title>
    <url>%2F2019%2F09%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是，设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring、Yii这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望在不久的将来，通过对设计模式的理解和工作经验的积累，自己可以站在一个更高的层次来审视、赏析程序代码。]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Write]]></title>
    <url>%2F2019%2F08%2F28%2FFirst%20Write%2F</url>
    <content type="text"><![CDATA[2019年，终于毕业了，结束了学生生涯 这次搭建了自己的网站，我会花时间来慢慢丰富这个博客 记录自己的成长.]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
