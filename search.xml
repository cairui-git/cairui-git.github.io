<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[赛马问题]]></title>
    <url>%2F2019%2F12%2F04%2F%E9%80%BB%E8%BE%91%E9%A2%98-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目： 64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？ 下面是我的思路，不能保证是最优解： 所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234 把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123 将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况： 前3名全部来自于第1名的小组，前三名直接晋级，只需比 10场 前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 11场 题目中问最少，所以答案应是 10场。 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。]]></content>
      <tags>
        <tag>逻辑题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复制含有随机指针的链表]]></title>
    <url>%2F2019%2F12%2F02%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目复制含有随机指针节点的链表 Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下： 12345678910111213public class RandNode &#123; public RandNode next; public RandNode rand; public int value; public RandNode(int value) &#123; this.value = value; this.next = null; this.rand = null; &#125;&#125; 给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。 HashMap实现使用辅助结构HashMap实现： 创建一个HashMap，key、value都是RandNode类型 遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中 遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点 重新遍历原链表，将map中所有的value的next、rand指针进行连接 返回复制后链表的头节点 代码： 1234567891011121314151617181920212223242526272829/** * 使用HashMap实现 * @param head 原链表头节点 * @return 复制后的链表头节点 */public static RandNode hashMapMethod(RandNode head) &#123; if (head == null) &#123; return null; &#125; else if (head.next == null) &#123; return new RandNode(head.value); &#125; HashMap&lt;RandNode, RandNode&gt; map = new HashMap&lt;&gt;(); RandNode node = head; while (node != null) &#123; RandNode copy_node = new RandNode(node.value); map.put(node, copy_node); node = node.next; &#125; node = head; while (node != null) &#123; RandNode copy_node = map.get(node); copy_node.next = map.get(node.next); copy_node.rand = map.get(node.rand); node = node.next; &#125; return map.get(head);&#125; 使用有限变量实现借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表： 遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null) 此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点 下面遍历链表，将所有复制节点的rand指针指向正确的位置 最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 使用有限的变量实现 空间复杂度O(1) * @param head 原链表头节点 * @return 复制后的链表头节点 */public static RandNode randPointNode(RandNode head) &#123; if (head == null) &#123; return null; &#125; else if (head.next == null) &#123; return new RandNode(head.value); &#125; //将复制的节点连到对应原节点后面 RandNode node = head; while (node != null) &#123; RandNode copy_node = new RandNode(node.value); copy_node.next = node.next; node.next = copy_node; node = copy_node.next; &#125; //配置复制节点的rand指针 node = head; while (node != null) &#123; RandNode copy_node = node.next; copy_node.rand = node.rand != null ? node.rand.next : null; node = node.next.next; &#125; //将复制的节点分离出来 RandNode result = head.next; node = head; while (true) &#123; RandNode copy_node = node.next; if (copy_node.next != null) &#123; node.next = copy_node.next; copy_node.next = copy_node.next.next; node = node.next; &#125; else &#123; node.next = null; copy_node.next = null; break; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检查是否安装某种php扩展]]></title>
    <url>%2F2019%2F11%2F27%2Fphp-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%9F%90%E7%A7%8Dphp%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[1、linux下使用命令：php -m 可列出已安装的php扩展 2、使用phpInfo()函数，可展示已安装的php扩展 3、使用如下代码验证： 1234567&lt;?php$extension= ''; //需要验证的某种扩展if (extension_loaded($extension)) &#123; echo '开启了扩展';&#125; else &#123; echo '没有开启扩展';&#125;]]></content>
      <categories>
        <category>操作</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荷兰国旗问题-单向链表版]]></title>
    <url>%2F2019%2F11%2F27%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%89%88%2F</url>
    <content type="text"><![CDATA[题目将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。 进阶：左、中、右三个部分内部需要与原链表顺序一致 思路一使用辅助数组实现： 创建一个辅助数组，遍历链表将节点放入数组中 在数组中调整元素的位置，具体操作可见荷兰国旗问题 在数组中调整好顺序后再将值赋给原链表 代码： 12345678910public class ListNode &#123; public ListNode next = null; public int value; public ListNode(int value) &#123; this.value = value; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * 使用辅助数组 * 空间复杂度O(n) */public static void arrayMethod(ListNode head, int num) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ListNode node = head; while (node != null) &#123; list.add(node.value); node = node.next; &#125; int indexFront = 0; int indexMid = 0; int indexRear = list.size() - 1; while (indexMid &lt;= indexRear) &#123; if (list.get(indexMid) &lt; num) &#123; swap(list,indexMid,indexFront); indexMid++; indexFront++; &#125; else if (list.get(indexMid) == num) &#123; indexMid++; &#125; else &#123; swap(list,indexMid,indexRear); indexRear--; &#125; &#125; node = head; for (Integer integer : list) &#123; node.value = integer; node = node.next; &#125;&#125;private static void swap(List&lt;Integer&gt; list, int x, int y)&#123; int temp = list.get(x); list.set(x, list.get(y)); list.set(y, temp);&#125; 思路二为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作： 遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点 将三条子链表头尾连接，变为一条完整的链表返回即可 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 进阶版 * 保证稳定性，同时空间复杂度达到O(1) */public static void dutchFlagListNode(ListNode head, int num) &#123; if (head == null || head.next == null) &#123; return; &#125; ListNode less_head = null; ListNode less_tail = null; ListNode eq_head = null; ListNode eq_tail = null; ListNode more_head = null; ListNode more_tail = null; while (head != null) &#123; if (head.value &lt; num) &#123; if (less_head == null) &#123; less_head = head; less_tail = head; &#125; else &#123; less_tail.next = head; less_tail = less_tail.next; &#125; &#125; else if (head.value == num) &#123; if (eq_head == null) &#123; eq_head = head; eq_tail = head; &#125; else &#123; eq_tail.next = head; eq_tail = eq_tail.next; &#125; &#125; else &#123; if (more_head == null) &#123; more_head = head; more_tail = head; &#125; else &#123; more_tail.next = head; more_tail = more_tail.next; &#125; &#125; head = head.next; &#125; //连接小于、等于、大于部分 head = null; ListNode tail = null; if (less_head != null) &#123; head = less_head; tail = less_tail; &#125; if (eq_head != null) &#123; if (head != null) &#123; tail.next = eq_head; &#125; else &#123; head = eq_head; &#125; tail = eq_tail; &#125; if (more_head != null) &#123; if (head != null) &#123; tail.next = more_head; &#125; else &#123; head = more_head; &#125; tail = more_tail; &#125; //尾部至空，防止链表成环 if (tail != null &amp;&amp; tail.next != null) tail.next = null;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断链表是否为回文结构]]></title>
    <url>%2F2019%2F11%2F25%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目给定一个链表的头节点head,请判断该链表是否为回文结构。 回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构 思路1使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)： 将链表从头到尾依次入栈 再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等 如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构 代码： 12345678910111213141516171819202122/** * 使用栈结构 * 额外空间O(n) */public static boolean stackMethod(ListNode head) &#123; if (head == null) &#123; return false; &#125; ListNode node = head; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (node != null) &#123; stack.push(node.value); node = node.next; &#125; while (!stack.isEmpty()) &#123; if (head.value != stack.pop()) &#123; return false; &#125; head = head.next; &#125; return true;&#125; 思路2使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)： 使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点 将链表的后半部分逆序，同时将中间节点指向null 此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等 如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论 将链表调整为最初的状态(如果需要的话)，然后返回结论 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 快慢指针+逆序链表 * 额外空间O(1) */public static boolean isPalindromeList(ListNode head) &#123; if (head == null) &#123; return false; &#125; else if (head.next == null) &#123; return true; &#125; ListNode fast = head; ListNode slow = head; //链表元素的个数是否为单数 boolean isSingular = true; //寻找链表的中心点 while (true) &#123; if (fast.next == null) &#123; break; &#125; if (fast.next.next == null) &#123; isSingular = false; break; &#125; slow = slow.next; fast = fast.next.next; &#125; //逆序链表的后半部分 ListNode node1 = head; ListNode node2 = null; if (isSingular) &#123; node2 = reverseListNode(slow); &#125; else &#123; node2 = slow.next; slow.next = null; node2 = reverseListNode(node2); &#125; //判断链表是否是回文结构 boolean result = true; ListNode tailNode = node2; while (true) &#123; if (node1 == null &amp;&amp; node2 == null) &#123; break; &#125; else if (node1 == null || node2 == null) &#123; result = false; break; &#125; else if (node1.value != node2.value) &#123; result = false; break; &#125; node1 = node1.next; node2 = node2.next; &#125; //调整链表至最初状态 reverseListNode(tailNode); return true;&#125;/** * 反转链表 * @param head 头节点 * @return 反转后的头节点 */private static ListNode reverseListNode(ListNode head) &#123; ListNode before = null; ListNode node = head; ListNode next = head.next; while (true) &#123; node.next = before; before = node; node = next; if (node == null) &#123; break; &#125; next = node.next; &#125; return before;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链与比特币]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%2F</url>
    <content type="text"><![CDATA[区块链2008年11月1日， 中本聪（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“比特币”的电子货币及其算法，其中实现比特币的底层技术：chain of blocks 在最早的比特币白皮书中文翻译版中，将 chain of blocks 翻译成了 区块链，这是区块链这一中文词的第一次出现。 想要解决的问题我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？ 想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。 好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。 你也许会问，我依赖第三方机构有什么问题？ 问题在于，你所拥有的不过是清一色的数字，并且修改权不在你： 要是中央数据库的数据丢失了呢？ 要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？ 要是，他根本就是有意为之呢？你真的可以完全信任他吗？ 多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。 现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？ 我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么———— 1是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？ 是的， 区块链 就是这个问题的答案，区块链被很多人定义为 加密的分布式记账技术,它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。 下面就来介绍一下这个分散式账簿是如何实现的。 区块链是如何工作的？使用区块链维护账簿的要求是： 必修有足够的人不想依赖第三方， 至少要三个。 一个简单的例子，假设有10个人打算使用区块链来维护彼此之间的账簿： 这10个人一直拥有着彼此的账号信息，但不知道真实身份。 一个空的文件夹一开始的时候，每个人都拥有一个空的文件夹和一些空的纸张。 一笔交易发生的时候在这个网络中的每个人都纸笔在手，随时准备记录下每时每刻发生的任何交易。 现在假设2号想要给9号转10块钱，于是2号将这个信息广播给所有人，我想转10元钱给9号，大家都记录下来！ 这时收到通知的人都通过历史的交易记录来确认2号是否有足够的余额转账，如果确认2号有足够的钱，每个人都在自己维护的账簿上记录下这笔交易。 时间过的很快，在这个网络中随时都在发生着交易，为了保证交易的成立，我们需要每隔一段时间更换新的纸张记录新的交易信息，并将上一份交易记录保存起来。 我将交易记录保存之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。 密封过后没人能够对这份大家都认同的交易记录做出更改，直至永远。 如果可以做到这点，那么大家就都可以信任被密封过的交易记录。 (在比特币中一般把将用来密封交易记录的东西称之为“矿”或者“工作量证明”) 123第三方/中介给予我们信任，其形式是：交易发生后账簿不可更改。在区块链这样的分散式、去中心化的系统中，这把唯一的钥匙将提供信任替代。 待更新… 参考文章 https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348]]></content>
      <categories>
        <category>拓展知识</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql-使用explain分析sql]]></title>
    <url>%2F2019%2F11%2F14%2FMySql-%E4%BD%BF%E7%94%A8explain%E5%88%86%E6%9E%90sql%2F</url>
    <content type="text"><![CDATA[在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。 Expliain语法：explain + sql语句 Expliain执行后包含以下信息： 123+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+ idsql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序： id相同：执行顺序由上至下执行 id不同，按id由大到小执行 select_type表示select的类型，包含以下几种： select_type 含义 SIMPLE 简单SELECT(不使用UNION或子查询等) PRIMARY 最外层的 select 查询(使用到主键作为查询条件) UNION UNION中的第二个或后面的SELECT语句 DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询 UNION RESULT UNION的结果 SUBQUERY 子查询中的第一个SELECT,不依赖于外部查询的结果集 DEPENDENT SUBQUERY 子查询中的第一个select查询,依赖于外部查询的结果集 DERIVED 导出表的SELECT(FROM子句的子查询) table表示该条查询的表名 如果查询是使用了别名，显示的是别名 如果不涉及数据库表，显示NULL 如果显示结果别这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N typetype表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。 常用的几个type： system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。 type 含义 system 表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index const 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描 eq_ref 出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref ref 不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。 fulltext 全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 ref_or_null 与ref方法类似，只是增加了null值的比较。实际用的不多 unique_subquery 用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery 用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 range 索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。 index_merge 表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range index 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user all 这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。 possible_keys显出可能使用到的索引 key查询中实际使用到的索引 key_lenkey_len显示的值为索引字段的最大可能长度，并非实际使用长度 ref显示使用哪个列或常数与key一起从表中选择行。 rows显示MySQL认为它执行查询时必须检查的行数 Extra包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>sql优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断k是否在矩阵中]]></title>
    <url>%2F2019%2F11%2F12%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%ADk%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[题目给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵： 要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。 思路 创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点 假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素 跟据该特性，判断指针所在位置的元素和整数k的关系： 等于k：返回true 大于k：指针向左移动，如果移动后超过了矩阵边界返回false 小于k：指针向下移动，如果移动后超过了矩阵边界返回false 重复执行上述步骤，直至函数return 代码1234567891011121314151617181920212223242526272829/** * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的. * 实现一个函数,判断K是否在matrix中 * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1). * @author Cairui * @time 2019-11-08 */public class SortMatrixNum &#123; public static boolean isExist(int[][] matrix, int num) &#123; if (matrix == null) &#123; return false; &#125; int[] index = &#123;0, matrix[0].length - 1&#125;; while (true) &#123; if (matrix[index[0]][index[1]] == num) &#123; return true; &#125; else if (matrix[index[0]][index[1]] &gt; num) &#123; index[1]--; &#125; else &#123; index[0]++; &#125; if (index[0] &gt;= matrix.length || index[1] &lt; 0) &#123; return false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转正方形矩阵]]></title>
    <url>%2F2019%2F11%2F07%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 要求：额外空间复杂度为O(1)。 举例： 思路大体思路做到由外到内一圈一圈旋转，具体步骤如下： 取左上角与右上角的坐标A、B，由A、B来确定完整的一圈 要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转 旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Code;/** * 旋转正方形矩阵 *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 *【要求】 额外空间复杂度为O(1)。 * @author CaiRui * @time 2019-11-06 */public class ClockwiseRotateMatrix &#123; public static void clockwiseRotateMatrix(int[][] matrix) &#123; //不是正方形矩阵 if (matrix == null || matrix.length != matrix[0].length || matrix.length &lt; 2) &#123; return; &#125; int A = 0; int B = matrix.length - 1; while (A &lt; B) &#123; clockwise(matrix, A, B); A++; B--; &#125; &#125; /** * 旋转一个外圈 * @param matrix 矩阵 * @param A 左上角坐标(A, A) * @param B 右下角坐标(B, B) */ private static void clockwise(int[][] matrix, int A, int B) &#123; int[] leftOn = &#123;A, A&#125;; int[] rightOn = &#123;A, B&#125;; int[] leftDown = &#123;B, A&#125;; int[] rightDown = &#123;B, B&#125;; while (leftOn[1] &lt; B) &#123; swap(matrix, leftOn, rightOn, rightDown, leftDown); leftOn[1]++; rightOn[0]++; leftDown[0]--; rightDown[1]--; &#125; &#125; private static void swap(int[][] matrix, int[] A, int[] B, int[] C, int[] D) &#123; int tempA = matrix[A[0]][A[1]]; int tempB = matrix[B[0]][B[1]]; int tempC = matrix[C[0]][C[1]]; int tempD = matrix[D[0]][D[1]]; matrix[A[0]][A[1]] = tempD; matrix[B[0]][B[1]] = tempA; matrix[C[0]][C[1]] = tempB; matrix[D[0]][D[1]] = tempC; &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930package Test;import Code.ClockwiseRotateMatrix;public class CodeTest &#123; private static void printMatrix(int[][] matrix) &#123; for (int[] ints : matrix) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; System.out.print(ints[j] + " "); &#125; System.out.println(); &#125; &#125; private static void clockwiseRotateMatrixTest() &#123; int[][] matrix = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;// int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; System.out.println("原矩阵："); printMatrix(matrix); System.out.println("旋转后矩阵："); ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix); printMatrix(matrix); &#125; public static void main(String[] args) &#123; CodeTest.clockwiseRotateMatrixTest(); &#125;&#125; 运行结果： 12345678原矩阵：1 2 3 4 5 6 7 8 9 旋转后矩阵：7 4 1 8 5 2 9 6 3]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[之字形打印矩阵]]></title>
    <url>%2F2019%2F11%2F05%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵 打印结果为： 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16 要求：额外空间复杂度为O(1) 思路 创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角 指针A、B每次同时移动一格，移动规则为： 指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动 指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动 在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印) 最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 之字型打印矩阵 * @author CaiRui * @time 2019-11-04 */public class ZigZagPrintMatrix &#123; private static void zigZagPrintMatrix(int[][] matrix) &#123; //不是矩阵 if (matrix == null || matrix.length &lt;= 1 || matrix[0].length &lt;= 1) &#123; return; &#125; int[] indexA = &#123;0, 0&#125;; int[] indexB = &#123;0, 0&#125;; boolean isAToB = false; while (true) &#123; printStraightLine(matrix,indexA,indexB,isAToB); if (indexA[0] == (matrix.length - 1) &amp;&amp; indexA[1] == (matrix[0].length - 1)) &#123; //终点 break; &#125; //更新A、B坐标 if (indexA[1] == (matrix[0].length - 1)) &#123; indexA[0]++; &#125; else &#123; indexA[1]++; &#125; if (indexB[0] == (matrix.length - 1)) &#123; indexB[1]++; &#125; else &#123; indexB[0]++; &#125; isAToB = !isAToB; &#125; &#125; //打印点A~B这条线的元素 private static void printStraightLine(int[][] matrix, int[] indexA, int[] indexB, boolean isAToB) &#123; //只有一个元素 if (indexA[0] == indexB[0] &amp;&amp; indexA[1] == indexB[1]) &#123; System.out.println(matrix[indexA[0]][indexA[1]]); return; &#125; //不能改变数组中的值,用变量代替 int x = isAToB ? indexA[0] : indexB[0]; int y = isAToB ? indexA[1] : indexB[1]; if (isAToB) &#123; // 从A打印到B while (true) &#123; System.out.print(matrix[x][y]+" "); if (x == indexB[0] &amp;&amp; y == indexB[1]) &#123; break; &#125; x++; y--; &#125; &#125; else &#123; // 从B打印到A while (true) &#123; System.out.print(matrix[x][y]+" "); if (indexA[0] == x &amp;&amp; indexA[1] == y) &#123; break; &#125; x--; y++; &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; ZigZagPrintMatrix.zigZagPrintMatrix(matrix); &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言学习笔记]]></title>
    <url>%2F2019%2F11%2F01%2Fgo-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[从零开始，持续更新 参考书籍：《Go程序设计语言》 环境部署前往官网下载源码点击此处官网(可能需要翻墙) 根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的 解压并安装1$ tar -zxvf go1.13.4.linux-amd64.tar.gz 配置环境变量123456789101112131415161.创建workspace$ mkdir -p workspace/src2.配置环境变量$ vi ~/.bashrc将以下配置添加进bashrc中export GOROOT=$HOME/goexport GOPATH=$HOME/workspaceexport PATH=$GOROOT/bin:$GOPATH/bin:$PATH使配置生效$ source ~/.bashrc3.验证是否成功$ go version 入门体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。 HelloWorld创建一个 HelloWorld.go 文件 (注意创建在你的GOPATH目录下) 1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello World")&#125; go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件： 1234$ go run HelloWorld.go输出：Hello World 如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现： 1$ go build HelloWorld.go 此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行： 1234$ ./HelloWorld输出：Hello World 下面说一下代码：Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。 每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。 package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。 在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。 Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句 Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。 输出命令行参数123456789101112131415package mainimport ( "os" "fmt")func main() &#123; var s, sep string for i := 1; i &lt; len(os.Args); i++ &#123; s += sep + os.Args[i] sep = " " &#125; fmt.Println(s)&#125; os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。 运行结果如下： 1234$ go run echo.go 1 3 -X ?输出：1 3 -X ? 使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串 循环变量i在for循环的开始处声明，使用 := 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。 注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且左大括号不能独立成行，必须和前置语句在同一行 for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为： 1234//传统的for循环for initialization; condition; post &#123; // ...&#125; 其中三个部分都是可以省略的，例如： 123456789//传统的while循环for condition &#123; // ...&#125;//无限循环 while(true)for &#123; //...&#125; 无限循环这种形式可以通过如break、return等语句进行终止 还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明： 123456789101112131415package mainimport ( "os" "fmt")func main() &#123; s, sep := "", "" for _, arg := range os.Args[1:] &#123; s += sep + arg sep = " " &#125; fmt.Println(s)&#125; 首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下： 12345678//定义简洁方便，通常在函数内部使用，不适用于包级别的变量s := ""//使用默认初始化值时的定义方式var s string//很少使用，除非定义多个变量时使用var s = ""//在类型不一致时，强调类型使用var s string = "" 在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 _ 这个变量，_ 在go语言中表示 空标识符 ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。 如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法： 1234567891011package mainimport ( "fmt" "strings" "os")func main() &#123; fmt.Println(strings.Join(os.Args[1:], ""))&#125; 最后，如果不关心格式或者只是调试程序时，可以直接使用Println： 12345678910package mainimport ( "fmt" "os")func main() &#123; fmt.Println(os.Args[1:])&#125; 结果和预期很像，只是两边有括号： 123$ go run echo4.go 1 2 s d ?[1 2 s d ?] 找出重复行从控制台输入下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下： 1234567891011121314151617181920212223package mainimport ( "bufio" "os" "fmt")func main() &#123; counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() &#123; if input.Text() == "end" &#123; break &#125; counts[input.Text()]++ &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf("%d\t%s\n",n,line) &#125; &#125;&#125; 程序运行结果如下： 123456789101112$ go run dup1.go112333end2 13 3 在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。 接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。 在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。 为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。 下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。 例如程序中的 “%d\t%s\n”含义为： %d 为将一个整数格式化为十进制形式、 \t 制表符、 %s 把参数输入为字符串、 \n 换行符。 下面给出一些常用的Printf转义字符，Go程序员将其称为verb： verb 描述 %d 十进制整数 %x, %o, %b 十六进制、八进制、二进制整数 %f, %g, %e 浮点型 %t 布尔型 %c 字符 %s 字符串 %q 带引号的字符串(“abc”或者’c’) %v 内置格式的任何值 %T 任何值的类型 %% 百分号本身 流式读取文件下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件： 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( "os" "fmt" "bufio")func main() &#123; counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 &#123; countLines(os.Stdin, counts) &#125; else &#123; for _, arg := range files &#123; f, err := os.Open(arg) if err != nil &#123; fmt.Fprintf(os.Stderr, "dup2: %v\n", err) continue &#125; countLines(f, counts) f.Close() &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf("%d\t%s\n", n, line) &#125; &#125;&#125;func countLines(f *os.File, counts map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; if input.Text() == "end" &#123; break &#125; counts[input.Text()]++ &#125;&#125; for test： 首先创建一个测试文件，名为test.txt： 1234567112121231231231234 运行结果如下： 1234$ go run dup2.go test.txt3 1232 12 os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。 可以看出 在go中函数的声明次序是任意的，包括main函数。 在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。 一次性读取文件上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。 下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理： 123456789101112131415161718192021222324252627package mainimport ( "os" "io/ioutil" "fmt" "strings")func main() &#123; counts := make(map[string]int) for _, filename := range os.Args[1:] &#123; data, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Fprintf(os.Stderr, "dup3: %v\n", err) continue &#125; for _, line := range strings.Split(string(data), "\n") &#123; counts[line]++ &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf("%d\t%s\n", n, line) &#125; &#125;&#125; 运行方式与结果同dup2.go ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。 获取URL的内容程序fetch通过命令行来读取url，通过net包下面的方法来获取指定url的内容，然后不加解析地输出： 12345678910111213141516171819202122232425package mainimport ( "os" "net/http" "fmt" "io/ioutil")func main() &#123; for _, url := range os.Args[1:] &#123; resp, err := http.Get(url) if err != nil &#123; fmt.Fprintf(os.Stderr, "fetch: %v\n", err) os.Exit(1) &#125; b, err := ioutil.ReadAll(resp.Body) resp.Body.Close() if err != nil &#123; fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err) os.Exit(1) &#125; fmt.Printf("%s", b) &#125;&#125; 上面程序使用net/http包的http.Get函数来产生一个HTTP请求，在没有出错的情况下返回结果会保存到resp中，其中resp.Body为一个可读数据流，通过ioutil.ReadAll来读取整个响应结果并存入b，随后关闭Body数据流来避免起源泄露。 并发获取多个URL的内容Go语言的特点之一就是支持并发编程，我们通过下面程序的程序简单了解下go的主要并发机制、goroutine和通道(channel)。下面程序用来从命令行读取很多个URL，并发的获取这些URL的内容，并返回获取每个URL的时间与程序执行的总时间 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "time" "os" "fmt" "net/http" "io" "io/ioutil")func fetch(url string, ch chan&lt;- string) &#123; start := time.Now() resp, err := http.Get(url) if err != nil &#123; ch &lt;- fmt.Sprint(err) //发送到通道ch return &#125; nbytes, err := io.Copy(ioutil.Discard, resp.Body) resp.Body.Close() if err != nil &#123; ch &lt;- fmt.Sprintf("while reading %s: %v", url, err) return &#125; secs := time.Since(start).Seconds() ch &lt;- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)&#125;func main() &#123; start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] &#123; go fetch(url, ch) //启动一个goroutine &#125; for range os.Args[1:] &#123; fmt.Println(&lt;-ch) //从通道ch接收 &#125; fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())&#125; 运行结果如下： 1234567$ go run fetchall.go http://www.rong360.com http://www.jd.com http://www.weibo.com http://www.baidu.com0.03s 156218 http://www.baidu.com0.14s 106674 http://www.jd.com0.15s 611 http://www.weibo.com0.17s 110858 http://www.rong360.com0.17s elapsed goroutin是一个并发执行的函数，本质是协程。main函数就是在一个goroutine中执行的，在main中可以使用 go 关键字来创建额外的goroutine。goroutine之前可以使用channel来进行通信或者说是数据共享。 go语言中使用 chan 关键字来声明channel，在上面的程序中使用了make创建了一个字符串通道ch，接下来在for循环中每次循环都创建一个新的goroutine，可以实现异步的调用fetch()方法来获取URL内容，在fetch中将读取到的信息传入channel中，在main函数的第二个for循环中依次接收。 搭建一个Web服务器输出url路径使用Go的库将很容易实现一个Web服务器，用来响应像fetch那样的客户端请求，下面实现一个迷你服务器，它将展示出访问服务器的URL路径部分。 1234567891011121314151617package mainimport ( "net/http" "fmt" "log")func main() &#123; http.HandleFunc("/", handler) log.Fatal(http.ListenAndServe("localhost:4000", nil))&#125;//处理回显请求部分func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "URL.PATH = %q\n", r.URL.Path)&#125; 运行服务器： 1$ go run server1.go 效果如下： 这个程序只有寥寥几行代码，因为库函数做了大部分工作。main函数中， http.HandleFunc(“/“, handler) 代表所有以/开头的URL都将转交给handler这个方法来处理，然后启动服务器开始监听本地4000端口的请求。 一个请求由一个http.Request类型的结构体表示，其中包含请求的URL(http.Request.URL.Path)，handler函数的操作就是将URL提取出来使用Fprintf输出。 输出网址的访问数量为服务器添加功能很容易，下面的程序实现了当URL为/count时返回到现在为止请求的个数： 1234567891011121314151617181920212223242526272829303132package mainimport ( "sync" "net/http" "log" "fmt")var mu sync.Mutexvar count intfunc main() &#123; http.HandleFunc("/", handler) http.HandleFunc("/count", counter) log.Fatal(http.ListenAndServe("localhost:4000", nil))&#125;//处理程序回显请求的URL的路径部分func handler(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() count++ mu.Unlock() fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)&#125;//counter回显目前为止调用的次数func counter(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() fmt.Fprintf(w, "Count %d\n", count) mu.Unlock()&#125; 在程序后台，服务器在不同的goroutine中运行处理函数，这样它可以同时处理多个请求，需要注意的是，在并发请求的情况下可能导致count的计数的不一致，为了避免该问题，所以使用了mu.lock()和mu.Unlock()两个方法对方法加锁，保证goroutine在同一时间最多只有一个对count变量进行操作，实现了共享变量的并发访问。 输出消息头和表单数据下面是一个更完整的例子，处理函数handler可以报告它接收到的消息头和表单数据，这样可以方便服务器审查和调试请求： 1234567891011121314151617181920212223242526272829package mainimport ( "net/http" "log" "fmt")func main() &#123; http.HandleFunc("/", handler) log.Fatal(http.ListenAndServe("localhost:4000", nil))&#125;//处理回显请求部分func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto) for k, v := range r.Header &#123; fmt.Fprintf(w, "Header[%q] = %q\n", k, v) &#125; fmt.Fprintf(w, "Host = %q\n", r.Host) fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr) if err := r.ParseForm(); err != nil &#123; log.Print(err) &#125; for k, v := range r.Form &#123; fmt.Fprintf(w, "Form[%q] = %q\n", k, v) &#125;&#125; 运行结果： 程序结构名称命名规范Go中对于函数、变量、常量、类型、语句标签和包名的命名全部遵循一个简单的规则：名称的开头是一个字母或者下划线，并区分大小写，后面可以跟任意字符的字母、数字或下划线。 Go存在一些不能用来命名的关键字，他们只能用在语法允许的地方： 另外还有一些内置的预声明的常量、类型和函数，这些名称不属于关键字，我们可以将它们用来命名，但不建议这么做，会有冲突的风险： 访问权限Go中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问(类似于其他语言的public)；如果首字母小写，则只能在本包中使用(类似于其他语言的private) 在定义结构体时，如果结构体是大写的，则该结构体可以被任意包访问，但无法访问结构体中以小写字母开头定义的参数，如果结构体需要通过json转码，需要注意参数不能使用小写，json无法解析小写字母开头的参数。 声明Go程序由一个或多个以.go为后缀的文件组成，每一个.go文件以package声明开头，表名文件属于哪个包。package声明后面是import声明，然后是包级别的变量、类型、常量、函数的声明，这4种声明不区分顺序，也是Go程序中主要的4种声明类型。 例如：下面的程序声明了一个常量、一个函数和一对变量： 123456789101112//输出水的沸点package mainimport "fmt"const boilingF = 212.0func main() &#123; var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf("boiling point = %g°F or %g°C\n", f, c)&#125; 常量boilingF是一个包级别的声明，对包中所有源文件可见；变量f和c是属于main函数的局部变量，变量仅在main函数内部可见。 函数的声明包含一个函数名字，一个参数列表，一个可选的返回值列表（如果无需返回值可省略），以及函数体组成。 下面的程序封装了温度转换的方法fToC，在其他函数中可以进行多次调用： 1234567891011121314//两次华氏-摄氏温度的转换package mainimport "fmt"func main() &#123; const freezingF, boilingF = 32.0, 212.0 fmt.Printf("%g°F = %g°C\n",freezingF, fToC(freezingF)) fmt.Printf("%g°F = %g°C\n",boilingF, fToC(boilingF))&#125;func fToC(f float64) float64 &#123; return (f - 32) * 5 / 9&#125; 待更新…]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则-最少知识原则]]></title>
    <url>%2F2019%2F11%2F01%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[定义最少知识法则也称为迪米特原则，定义为：一个对象应该对其他对象有最少的了解。 实践迪米特法则对实现类的低耦合提出了明确的要求，规则如下： 1.只和直接的朋友通信直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。 类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。 2.朋友间也需要有距离一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。 3.是自己的就是自己的如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计原则-接口隔离原则]]></title>
    <url>%2F2019%2F10%2F30%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[定义Clients should not be forced to depend upon interfaces that they don’t use. “客户端不应该依赖它不需要的接口”，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。 实践实现接口时尽量做到以下规范： 接口要做到高内聚：尽量少的公布public方法，降低变更的风险 定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法 有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口 已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理 接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2019%2F10%2F30%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵 打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 思路大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下： 在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1) 完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标 重复执行上述步骤，直至得到的坐标无法构成矩阵为止 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package Code;/** * 顺时针打印矩阵 * @author CaiRui * @time 2019-10-24 */public class ClockwisePrintMatrix &#123; private static void printMatrix(int[][] matrix) &#123; //不是矩阵 if (matrix == null || matrix.length &lt;= 1 || matrix[0].length &lt;= 1) &#123; return; &#125; int[] A = &#123;0, 0&#125;; int[] B = &#123;matrix.length - 1, matrix[0].length -1&#125;; while (B[0] &gt;= A[0] &amp;&amp; B[1] &gt;= A[1]) &#123; print(matrix,A[0]++,A[1]++,B[0]--,B[1]--); &#125; &#125; /** * 左上角坐标(a,b) * 右下角坐标(c,d) */ private static void print(int[][] arr, int a, int b, int c, int d) &#123; // (a, b) -&gt; (a, d) int index = b; while (index &lt; d) &#123; System.out.print(arr[a][index++] + " "); &#125; // (a, d) -&gt; (c, d) index = a; while (index &lt; c) &#123; System.out.print(arr[index++][d] + " "); &#125; // (c, d) -&gt; (c, b) index = d; while (index &gt; b) &#123; System.out.print(arr[c][index--] + " "); &#125; // (c, b) -&gt; (a, b) index = c; while (index &gt; a) &#123; System.out.print(arr[index--][b]+" "); &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; ClockwisePrintMatrix.printMatrix(matrix); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈实现队列&队列实现栈]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈实现队列要求使用栈实现队列的如下方法： offer(入队) poll(出队) peek(查看栈顶元素) 思路 内部创建两个栈，push栈和pop栈 offer()：push栈正常入栈 poll(): 弹出pop栈的栈顶元素并返回 (当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中) peek(): 返回pop栈的栈顶元素 (当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Stack;/** * 栈实现队列 * @author CaiRui * @time 2019-10-24 */public class StackBecomeQueue &#123; private Stack&lt;Integer&gt; push = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; pop = new Stack&lt;&gt;(); public void offer(int num) &#123; push.push(num); &#125; public int poll() &#123; if (!pop.isEmpty()) &#123; return pop.pop(); &#125; if (push.isEmpty()) &#123; throw new ArrayIndexOutOfBoundsException("Queue is empty!"); &#125; this.pushData(); return pop.pop(); &#125; public int peek() &#123; if (!pop.isEmpty()) &#123; return pop.peek(); &#125; if (push.isEmpty()) &#123; throw new ArrayIndexOutOfBoundsException("Queue is empty!"); &#125; this.pushData(); return pop.peek(); &#125; private void pushData() &#123; while (!push.isEmpty()) &#123; pop.push(push.pop()); &#125; &#125;&#125; 队列实现栈结构要求使用队列实现栈结构的如下方法： push(入栈) pop(出栈) peek(查看栈顶元素) 思路 内部创建两个队列，data队列和help队列 push(): data队列正常入队 pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回 peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.LinkedList;import java.util.Queue;/** * 使用队列实现栈结构 * @author CaiRui * @time 2019-10-23 */public class QueueBecomeStack &#123; private Queue&lt;Integer&gt; data = new LinkedList&lt;&gt;(); private Queue&lt;Integer&gt; help = new LinkedList&lt;&gt;(); private int size = 0; /** * 入栈 */ private void push(int num) &#123; size++; data.offer(num); &#125; /** * 栈顶元素出栈 */ private int pop() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("栈为空"); &#125; for (int i = 0; i &lt; size - 1; i++) &#123; help.offer(data.remove()); &#125; size--; swap(); return help.remove(); &#125; /** * 查看栈顶元素 */ private int peek() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("栈为空"); &#125; for (int i = 0; i &lt; size -1; i++) &#123; help.offer(data.remove()); &#125; int ret = data.remove(); help.offer(ret); swap(); return ret; &#125; private void swap() &#123; Queue&lt;Integer&gt; temp = data; data = help; help = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min栈的实现]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-Min%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[题目实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求： 1．pop、push、peek、getMin操作的时间复杂度都是O(1)。 2．设计的栈类型可以使用现成的栈结构。 思路 内部创建两个栈，data栈和min栈 元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是(min栈的栈顶存的永远是data栈中的最小值) 出栈时data栈和min栈一起正常出栈 getMin()方法只需要返回min栈的栈顶元素 代码12345678910111213141516171819202122232425262728293031323334import java.util.Stack;/** * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。 * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。 * 2．设计的栈类型可以使用现成的栈结构。 * @author CaiRui * @time 2019-10-22 */public class MinStack &#123; private Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; min = new Stack&lt;&gt;(); public int push(int num) &#123; data.push(num); min.push((min.peek() &gt; num) ? num : min.peek()); return num; &#125; public int pop() &#123; min.pop(); return data.pop(); &#125; public int peek() &#123; return data.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更快的获取中位数]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数 思路这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。 此时收集数的操作是 O(1)，获取中位数的操作是 O(n*logn) 如果接口被频繁调用，排序的代价就太高了，下面利用堆结构的特点来进行优化： 创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下： 假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中 两个堆中元素数量保持平衡，差值不大于1 如何获取中位数： 如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素 如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值 此时收集数的操作需要进行一次heapInsert 代价是 O(logn)，而获取中位数的操作变为了 O(1)，效率得到了很大的提升 O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import DataStructure.Heap;/** * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数 * @author Cai Rui * @time 2019-10-18 */public class MedianQuick &#123; private int[] bigHeap = new int[100]; private int[] smallHeap = new int[100]; private int bigSize = 0; private int smallSize = 0; public void numberInsert(int number) &#123; if (bigSize == 0) &#123; bigHeap[bigSize++] = number; return; &#125; //是否需要扩容 if (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123; this.automaticCapacity(); &#125; if (number &gt; bigHeap[0]) &#123; //较大的数进小根堆 smallHeap[smallSize++] = number; Heap.heapInsert(smallHeap,smallSize-1,1); &#125; else &#123; //较小的数进大根堆 bigHeap[bigSize++] = number; Heap.heapInsert(bigHeap,bigSize-1,0); &#125; //平衡堆中元素数量，差值不等大于1 if (bigSize - smallSize &gt; 1) &#123; smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,0); Heap.heapInsert(smallHeap,smallSize-1,1); &#125; else if (smallSize - bigSize &gt; 1) &#123; bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,1); Heap.heapInsert(bigHeap,bigSize-1,0); &#125; &#125; //获取中位数 public double getMedian() &#123; if (bigSize == 0) &#123; return -1; &#125; if (bigSize == smallSize) &#123; return (double)(bigHeap[0] + smallHeap[0])/2; &#125; else if (bigSize &gt; smallSize) &#123; return bigHeap[0]; &#125; else &#123; return smallHeap[0]; &#125; &#125; //自动扩容 private void automaticCapacity() &#123; int[] bigHeap = new int[this.bigHeap.length+100]; int[] smallHeap = new int[this.smallHeap.length+100]; System.arraycopy(this.bigHeap, 0, bigHeap, 0, bigSize); System.arraycopy(this.smallHeap, 0, smallHeap, 0, smallSize); this.bigHeap = bigHeap; this.smallHeap = smallHeap; &#125;&#125; 注：Heap类的相关代码]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组实现队列]]></title>
    <url>%2F2019%2F10%2F28%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目使用数组实现队列结构，实现方法： add(向队尾添加元素) poll(返回队首元素，并移除) peek(返回队首元素) 思路 创建两个指针start、end和一个变量size，初始值都为0 start表示队首元素的位置 end表示下一个元素入队时要添加的位置 size表示队列大小 start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 使用数组实现队列 * @author CaiRui * @time 2019-10-23 */public class ArrayBecomeQueue &#123; private int[] arr; private int start = 0; private int end = 0; private int size = 0; public ArrayBecomeQueue() &#123; arr = new int[50]; &#125; public ArrayBecomeQueue(int initSize) &#123; arr = new int[initSize]; &#125; //添加一个元素到队尾 public boolean add(int num) &#123; if (size == arr.length) &#123; throw new ArrayIndexOutOfBoundsException("队列已满"); &#125; size++; arr[end] = num; end = (end == arr.length - 1) ? 0 : ++end; return true; &#125; //获取队首元素，并移除 public int poll() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("队列为空"); &#125; size--; int result = arr[start]; start = start == arr.length - 1 ? 0 : ++start; return result; &#125; //获取队首元素 public int peek() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException("队列为空"); &#125; return arr[start]; &#125; public static void main(String[] args) &#123; //预计输出：1 1 2 3 3 ArrayBecomeQueue queue = new ArrayBecomeQueue(5); queue.add(1); queue.add(2); queue.add(3); System.out.println(queue.peek()); queue.add(4); System.out.println(queue.poll()); System.out.println(queue.poll()); queue.add(5); queue.add(6); System.out.println(queue.peek()); System.out.println(queue.poll()); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相邻两数最大差值]]></title>
    <url>%2F2019%2F10%2F22%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n) 举个例子： 给定数组：{4,5,1,2} 排好序后的数组是：{1,2,4,5} 相邻两数的差值分别为：1,2,1 需要返回最大差值，所以最终结果就是2 暴力解法先把数组排序，再遍历数组求出所有差值，返回最大的那一个 123456789101112131415//暴力解法 O(n*logn)private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result;&#125; 由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用 标准解法这里利用了桶的概念，但没有进行桶排序 思路： 假设数组中有N个数，创建N+1个桶 遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶 然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中 (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5) 这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 产生最大差值的两个相邻数绝对不会来自于相同桶 有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了 所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值 * @author CaiRui * @time 2019-10-21 */public class BorderCount &#123; //O(n) private static int getBorderCount(int[] arr) &#123; //过滤非法数据 if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; //借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶 int[] min = new int[arr.length+1]; int[] max = new int[arr.length+1]; //记录桶是否为空 boolean[] existNumber = new boolean[arr.length+1]; //最小值和最大值相等：返回0 HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr); int minNum = criticalMap.get("Min"); int maxNum = criticalMap.get("Max"); if (minNum == maxNum) &#123; return 0; &#125; //最小值放在第一个桶，最大值放在最后一个桶 min[0] = minNum; max[0] = minNum; existNumber[0] = true; min[min.length-1] = maxNum; max[max.length-1] = maxNum; existNumber[existNumber.length-1] = true; //每个桶中存放的数值范围 double scope = (double) (min[min.length-1] - min[0])/min.length; //元素入桶 for (int num : arr) &#123; if (num == min[0] || num == max[max.length - 1]) &#123; continue; &#125; //该元素应该存放的下标 int index = (int) Math.ceil((num - min[0]) / scope)-1; if (!existNumber[index]) &#123; min[index] = num; max[index] = num; existNumber[index] = true; &#125; else &#123; if (num &gt; max[index]) &#123; max[index] = num; &#125; else if (num &lt; min[index]) &#123; min[index] = num; &#125; &#125; &#125; //记录非空桶的坐标 List&lt;Integer&gt; existIndex = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; existNumber.length;i++) &#123; if (existNumber[i]) &#123; existIndex.add(i); &#125; &#125; //计算最大差值 int maxBorderCount = max[0] - min[0]; for (int i = 0;i &lt; existIndex.size() - 1;i++) &#123; int border = min[existIndex.get(i+1)] - max[existIndex.get(i)]; if (border &gt; maxBorderCount) &#123; maxBorderCount = border; &#125; &#125; return maxBorderCount; &#125; //获取最大值和最小值 private static HashMap&lt;String,Integer&gt; getMaxAndMin(int[] arr) &#123; HashMap&lt;String,Integer&gt; result = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int num : arr) &#123; max = Math.max(max,num); min = Math.min(min,num); &#125; result.put("Max",max); result.put("Min",min); return result; &#125; //暴力解法 O(n*logn) private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; int testCount = 10000; boolean is_success = true; for (int i = 0;i &lt; testCount;i++) &#123; int[] arr = ArrayUtil.getArray(10,0,20); int[] arr1 = ArrayUtil.copyArray(arr); int[] arr2 = ArrayUtil.copyArray(arr); int border1 = BorderCount.getBorderCount(arr1); int border2 = BorderCount.testMethod(arr2); if (border1 != border2) &#123; is_success = false; break; &#125; &#125; if (is_success) &#123; System.out.println("Success"); &#125; else &#123; System.out.println("Fail"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[堆排序堆排序是利用堆结构的特点来设计的一种排序算法。 思路 首先将整个数组构建成大根堆 依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置 在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组 当堆中所有元素弹出完毕，此时数组已全部有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 堆排序 * @author Cai Rui * @time 2019-10-17 */public class HeapSort &#123; public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; Heap.buildBigHeap(arr,arr.length,0); for (int i = 0;i &lt; arr.length;i++) &#123; Heap.heapPop(arr,arr.length-i,0); &#125; &#125;&#125;/** * 堆结构 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param length 堆的大小 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int length,int heapType)&#123; if (arr == null || length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType)&#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; ArrayUtil.swap(arr,0,length-1); heapFalling(arr,length-2,heapType); return result; &#125; /** * 向堆中添加一个元素 * @param arr 数组中(0 ~ index-1)为堆结构 * @param index 元素下标 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void heapInsert(int[] arr,int index,int heapType)&#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; ArrayUtil.swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType)&#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; &#125; else &#123; ArrayUtil.swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n*logn); 平均时间复杂度: O(n*logn) 空间复杂度: O(1) 稳定性分析不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-堆]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86%2F</url>
    <content type="text"><![CDATA[堆堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。 完全二叉树首先堆的结构是一颗 完全二叉树 完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图： 在程序中，我们可以使用数组结构来抽象出一颗完全二叉树： 数组中的0位置代表根节点 假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为： 左孩子：2*i+1 右孩子：2*i+2 假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为： 父节点：(i-1)/2 根节点的父节点是自己：(0-1)/2 = 0 使用上面的抽象规则，我们就可以把 任意数组抽象为一颗完全二叉树。 构建推结构堆分为两种： 大根堆：在一颗完全二叉树中，任何一颗子树的 最大值 都是头部 小根堆：在一颗完全二叉树中，任何一颗子树的 最小值 都是头部 以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？ 步骤： 首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中 后面通过遍历数组，将每个元素依次进堆 进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止 数组中所有元素进堆完毕，则大根堆构建完成 时间复杂度：O(n) 弹出堆顶元素在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。 步骤： 将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中 对此时的堆顶元素进行下沉操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉) 下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子(如果没有右孩子就不比较，但一定有左孩子) 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉 堆顶元素下沉完毕后，此时又重新构建好了堆结构 时间复杂度：O(logn) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * 堆 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int heapType) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; arr.length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType) &#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; swap(arr,0,length); heapFalling(arr,length-1,heapType); return result; &#125; private static void heapInsert(int[] arr,int index,int heapType) &#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType) &#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; &#125; else &#123; swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125; private static void swap(int[] arr,int a,int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; public static void main(String[] args) &#123; int[] arr = &#123;5,1,4,5,8,2,5,6,54,9,7,5,2,0&#125;; Heap.buildBigHeap(arr,1); ArrayUtil.printArray(arr); int min = Heap.heapPop(arr,arr.length-1,1); System.out.println(min); ArrayUtil.printArray(arr); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F10%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 思路 选取数组中的中的一个数作为基准数，然后将数组调整为两部分：左部分的数全部小于等于基准数、右部分的数全部大于基准数(子序列中内部不需要有序) 递归的对数组两个部分继续执行上述步骤，直至数组有序 改进 将数组划分为三个部分，小于、等于、大于区域 (具体实现) 这时等于区域的数就已经位于理想的位置，因此只需要递归小于区域和大于区域 (在有很多重复数字的情况下效率提升会很明显) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 快速排序 * @author cairui * @time 2019-10-11 */public class QuickSort &#123; public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr, 0, arr.length-1); &#125; //递归函数 private static void quickSort(int[] arr,int left,int right) &#123; if (left &gt;= right) &#123; return; &#125; int[] index = grouping(arr,left,right); //递归小于区域和大于区域 quickSort(arr,left,index[0]); quickSort(arr,index[1],right); &#125; //划分出小于、等于、大于区域 private static int[] grouping(int[] arr, int left, int right) &#123; int indexFront = left; int indexMid = left; int indexRear = right; int num = arr[right]; while (true) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr, indexMid, indexFront); if (indexMid + 1 &gt; indexRear) break; indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; if (indexMid + 1 &gt; indexRear) break; indexMid++; &#125; else &#123; if (indexMid &gt; indexRear - 1) break; swap(arr, indexMid, indexRear); indexRear--; &#125; &#125; //返回临界值坐标 int[] index = new int[2]; index[0] = (arr[indexFront] == num) ? (indexFront - 1) : indexFront; index[1] = (arr[indexRear] == num) ? (indexRear + 1) : indexRear; return index; &#125; private static void swap(int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n2); (快排在最差情况下会退化为冒泡) 平均时间复杂度: O(n*logn) 空间复杂度: O(logn) 稳定性分析不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-向git推送更新失败]]></title>
    <url>%2F2019%2F10%2F11%2FHexo-%E5%90%91git%E6%8E%A8%E9%80%81%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[今天在更新博客时发生了 hexo d 时推送失败的情况。 报错信息: 12Connection reset by 52.74.223.119 port 22fatal: Could not read from remote repository. 这表示git客户端无法连接至github，原因大概是防火墙禁止了ip为52.74.223.119端口22的ssh连接 解决方法： (1) 我的解决的方法是切换网络，将wifi切成手机热点就提交成功了。 (2) 如果条件不允许或者切换网络依旧不成功，需要手动将防火墙中的 22端口设置为允许连接 具体操作请参考]]></content>
      <categories>
        <category>问题整理</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荷兰国旗问题]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。 常见思路常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。 代码： 1234567891011121314151617181920212223242526//常见思路 时间复杂度(n) 空间复杂度O(n)private static void badMethod(@NotNull int[] arr, int num)&#123; int index = 0; List&lt;Integer&gt; alist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; blist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; clist = new ArrayList&lt;&gt;(); for (int n : arr) &#123; if (n&lt;num) &#123; alist.add(n); &#125; else if (n==num) &#123; blist.add(n); &#125; else &#123; clist.add(n); &#125; &#125; index = setArray(arr,index,alist); index = setArray(arr,index,blist); setArray(arr,index,clist);&#125;private static int setArray(int[] arr, int index, @NotNull List&lt;Integer&gt; list)&#123; for (Integer integer : list) &#123; arr[index++] = integer; &#125; return index;&#125; 改进上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级： 123456789101112131415161718192021222324//空间复杂度改进为O(1)的方法private static void dutchFlag(@NotNull int[] arr, int num)&#123; int indexFront = 0; int indexMid = 0; int indexRear = arr.length-1; while (indexMid &lt;= indexRear) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr,indexMid,indexFront); indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; indexMid++; &#125; else &#123; swap(arr,indexMid,indexRear); indexRear--; &#125; &#125;&#125;private static void swap(@NotNull int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125; 使用三个指针，交换全部在数组内部进行，三个指针的含义为： indexFront : 指针前面的所有数都满足小于num indexMid : 指针前面所有的数都满足小于等于num indexRear : 指针后面所有的数都满足大于num 终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA-批量修改变量名]]></title>
    <url>%2F2019%2F10%2F11%2FIDEA-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[双击选中修改对象后： Shift+F6 变量名填写完成后按回车执行修改]]></content>
      <categories>
        <category>操作</category>
      </categories>
      <tags>
        <tag>IDEA快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小和问题]]></title>
    <url>%2F2019%2F09%2F27%2F%E7%AE%97%E6%B3%95%E9%A2%98-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。 现在给出一个数组请求出数组的小和。 例子数组：[1,3,4,2,5] 1左边比1小的数，没有； 3左边比3小的数，1； 4左边比4小的数，1、3； 2左边比2小的数，1； 5左边比5小的数，1、3、4、2； 所以小和为1+1+3+1+1+3+4+2=16 常见思路常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。 12345678910//常见思路,O(n2)的方法int badMethod(int[] arr)&#123; int smallSum = 0; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(arr[i]&gt;arr[j]) smallSum += arr[j]; &#125; &#125; return smallSum;&#125; 但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进 改进在归并排序的基础上进行改进，在merge左右两个有序数组时候，如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。 1234567891011121314151617181920212223242526272829303132333435363738394041//利用分治思想,O(n*logn)的方法private static int getSmallSum(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return 0; &#125; return getSmallSum(arr,0,arr.length-1);&#125;//递归private static int getSmallSum(int[] arr, int left, int right)&#123; if(left&gt;=right)&#123; return 0; &#125; int mid = left - (left-right)/2; return getSmallSum(arr,left,mid) + getSmallSum(arr,mid+1,right) + merge(arr,left,mid,right);&#125;private static int merge(int[] arr,int left,int mid,int right)&#123; int smallSum = 0; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; //左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数) smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+1) * arr[index_left] : 0; merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); return smallSum;&#125; 此时算法的时间复杂度就提升到了O(n*logn)的级别]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。 思路 将数组分解为各含n/2个元素的子数组，递归的拆分数组，当子数组长度为1时，默认子数组是就有序的 将两个有序的数组通过外排合并为一个有序的数组 当全部子数组合并完成时，原数组变为有序 图解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 归并排序 * author:Cai Rui * date:2019-09-27 */class MergeSort &#123; static void mergeSort(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return; &#125; mergeSort(arr,0,arr.length-1); &#125; //递归 private static void mergeSort(int[] arr,int left,int right)&#123; if(left&gt;=right)&#123; return; &#125; int mid = left - (left-right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); merge(arr,left,mid,right); &#125; private static void merge(int[] arr,int left,int mid,int right)&#123; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; merge_arr[index_merge++] = (arr[index_left] &gt; arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ;最差时间复杂度: O(n*logn) ;平均时间复杂度: O(n*logn) 空间复杂度: O(n) 稳定性分析稳定(在外排过程中，当遇到相等元素先存左边的数，就可以保证排序结果是稳定的)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖倒置原则]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD. 定义High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 翻译过来就是： 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 每一个逻辑的具体实现就是低层模块(一般指方法)，各种逻辑的组装就是高层模块。 抽象是指接口或者抽象类，属于不能被示例化的；细节就是可以被实例化的实现类，一般指实现接口或继承抽象类的类。 依赖倒置原则在开发过程中的体现就是： 模块间的依赖通过抽象发生，实现类之间不直接发生依赖，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 应用看一个应用到依赖倒置原则的例子： 下图是在不使用依赖倒置原则的情况下，奔驰车和驾车司机的类图设计：奔驰车中提供run方法，表示车辆运行： 12345public class Benz &#123; public void run()&#123; System.out.println("奔驰汽车开始运行..."); &#125;&#125; 司机通过调用奔驰车的run方法来驾驶奔驰车： 12345public class Driver &#123; public void drive(Benz benz)&#123; benz.run(); &#125;&#125; 司机驾驶奔驰汽车的场景如下： 1234567public class Client &#123; public static void main(String[] args) &#123; Driver driver = new Driver(); Benz benz = new Benz(); driver.drive(benz); &#125;&#125; 以上代码实现了司机开动奔驰车的功能，目前为止程序的功能没有任何问题。 此时如果我们现在不仅有奔驰车，又添加了一辆宝马车，代码如下： 12345public class BMW &#123; public void run()&#123; System.out.println("宝马汽车开始运行..."); &#125;&#125; 有了宝马车之后，我们发现司机竟然没有办法把宝马车开动起来，这是因为目前的司机和奔驰车是紧耦合的关系，要想让司机开动奔驰车就必须修改司机类的代码，被依赖者的变更竟然需要依赖者来承担修改的代价，可见上面的程序稳定性和可维护性都是非常差的 在比较大一些项目开发中，团队中每个人都会负责不同的模块，这里假设这个项目的团队中甲负责汽车类的维护，乙负责司机类的维护，如果按照上面的思路开发，那么在甲开发完成之前乙是不能编写drive方法，因为缺少汽车类，所以此时团队的开发工作是无法做到并行开发的，这严重影响了项目的开发效率 为了解决以上问题，对该项目引入依赖倒置原则后的类图如图所示： 列出采用依赖倒置原则的三种写法： (1)构造函数传入依赖对象 12345678910111213public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public Driver(ICar _car)&#123; this.car = _car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 通过构造函数来设置驾驶汽车的类型 (2)set方法传递依赖对象 1234567891011121314public interface IDriver &#123; public void setCar(ICar car); public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 在执行drive方法之前通过setCar方法来指定汽车的类型 (3)接口声明依赖对象 12345678910111213141516171819202122232425public interface IDriver &#123; public void drive(ICar car);&#125;public class Driver implements IDriver&#123; public void drive(ICar car)&#123; car.run(); &#125;&#125;public interface ICar &#123; public void run();&#125;public class Benz implements ICar&#123; public void run()&#123; System.out.println("奔驰汽车开始运行..."); &#125;&#125;public class BMW implements ICar&#123; public void run()&#123; System.out.println("宝马汽车开始运行..."); &#125;&#125; 业务场景实现： 1234567public class Client &#123; public static void main(String[] args) &#123; IDriver zhangSan = new Driver(); ICar benz = new Benz(); zhangSan.drive(benz); &#125;&#125; 小结为什么是依赖“倒置”：以正常人的思维方式，类之间的依赖关系是实现类之间的依赖，例如司机要开奔驰车，就直接依赖奔驰车，这种就属于“正置”；在编写程序中我们要做到的是对现实世界的事物进行抽象，来实现扩展性和维护性更高的代码，抽象就是抽象类和接口，让我们的的系统产生对抽象的依赖，代替正常人们传统的思维方式(对事物的依赖)，这就是“倒置”的含义 采用依赖倒置原则带来的好处： 减少类间的耦合性 提高系统的稳定性 降低并行开发的风险 提高代码的可读性和可维护性 在项目开发中应遵循： 实体类尽量有接口或抽象类：有抽象才能进行依赖倒置 变量的表面类型尽量是接口或抽象类 不要从具体类中派生出子类 尽量不重写父类的方法：对依赖的稳定性会有影响 采用依赖倒置原则的优势在小型项目中很难体现，一般适用于大中型项目，让项目在后续的扩展和维护中更加方便快捷稳定。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少 思路 第一个数默认已经排好序 从第二数开始，依次和前面的数比较，遇到比自己大的就交换，遇到比自己小的或者已经到了数组头部时停止(相当于把自己插入到了正确的位置，比自己大的数往后挪了一位) 遍历数组，重复以上步骤 图解 代码12345678910111213141516171819202122public class InsertSort &#123; //插入排序 public static void insertSort(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&gt;arr[j-1])&#123; break; &#125; swap(arr,j,j-1); &#125; &#125; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2) 思路 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾 以此类推，直到全部待排序的数据元素的个数为零 图解 代码12345678910111213141516171819202122public class SelectSort &#123; //选择排序 public static int[] selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; int min_index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; min_index = arr[j]&lt;arr[min_index] ? j : min_index; &#125; swap(arr,i,min_index); &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n2) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析举例： 排序前：3(1号) , 3(2号) , 1 排序后：1 , 3(2号) , 3(1号) 不稳定]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对数器]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%AF%B9%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。 下面一个例子，是利用系统已有的排序函数(绝对正确的方法)来验证我自己写的排序函数mySort(正确性未知的,我们要验证的方法)的正确性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.Arrays;public class SortTest &#123; /** * 获取一个随机数组 * @param length 数组最大长度,最小为0 * @param min 最小值 * @param max 最大值 */ private static int[] getArray(int length,int min,int max)&#123; int[] arr = new int[(int)(0+Math.random()*(length+1))]; for(int i=0;i&lt;length;i++)&#123; arr[i] = (int)(min+Math.random()*(max-min+1)); &#125; return arr; &#125; //复制数组 private static int[] copyArray(int[] arr)&#123; int[] result = new int[arr.length]; for(int i=0;i&lt;arr.length;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; //比较两个数组是否相等 private static boolean isEqualsArray(int[] arr1,int[] arr2)&#123; if(arr1.length!=arr2.length)&#123; return false; &#125; for(int i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; return false; &#125; &#125; return true; &#125; //输出数组 private static void printArray(int[] arr)&#123; for(int num : arr)&#123; System.out.print(num+" "); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; boolean is_right = true; int[] fail_array = new int[10]; //测试次数 int test_num = 100000; for(int i=0;i&lt;test_num;i++)&#123; //生成一个长度为 0~10，值为 1~20之间的随机数组,并生成两个复制来进行排序 int[] arr = SortTest.getArray(10, 1, 20); int[] arrA = SortTest.copyArray(arr1); int[] arrB = SortTest.copyArray(arr1); //执行排序 Arrays.sort(arrA); MySort.mySort(arrB); //比较结果是否相等 if(!SortTest.isEqualsArray(arrA, arrB))&#123; is_right = false; fail_array = arr; break; &#125; &#125; if(is_right)&#123; System.out.println("Success!"); &#125;else&#123; System.out.println("Fail!"); System.out.println(); System.out.print("Fail Array:"); SortTest.printArray(fail_array); &#125; &#125;&#125; 校验mySort步骤： 生成一个长度随机，值也随机的数组 获取两个刚刚随机生成的数组的复制，分别用正确的sort方法和待验证的mysort方法进行排序 比较排好序的两个数组是否相等 若不相等则说明算法是错的，把排序失败的数组打印出来，方便排查问题出在哪 相等则说明该条测试用例可以通过，继续重复以上步骤，我这里重复了10万次，当然次数越多越好，这样几乎可以涵盖所有的可能，可以说明该算法是正确的 对数器的好处在于测试用例不再需要自己设计了，通过随机生成的庞大样本量，就可以保证算法的正确性，自己想测试用例的话总会出现情况考虑不全的时候，到时程序出bug的话就得不偿失了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[里氏替换原则]]></title>
    <url>%2F2019%2F09%2F19%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。 定义那什么是里氏替换原则呢？它有两种定义： 第一种：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为什么发生变化，那么类型S是类型T的子类型) 第二种：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明的使用其子类的对象) 第一种是比较官方、正宗的定义，不是很好理解，感觉像是高数里面的某种概念。我们看第二种，第二种是定义是比较清晰的，解释一下就是：所有可以使用父类的地方，把父类替换为子类后，程序运行时不会体现出任何的异常，使用者甚至不需要关心使用的是父类和子类。 但反过来就未必可以，使用子类的地方换成父类就不能保证程序不会出错，因为子类可以有父类没有的属性和方法。 继承的使用规范知道了什么是里氏替换原则，那么具体应该怎么做呢？ (1)子类必须完全实现父类的方法： 如果子类不能完整的实现父类的方法，或者父类的方法不适合该子类，这种情况下继承带来的效果就属于弊大于利，因为子类无法完整地实现父类的业务，此时建议解除继承关系，采用依赖、聚集、组合等关系代替来继承。 (2)覆盖或实现父类的方法时输入参数可以被放大，不可以被缩小： 例如： 123456789101112131415public class Father &#123; public void doSomething(HashMap map)&#123; System.out.println("父类被执行"); &#125;&#125;public class Son extends Father &#123; public void doSomething(Map map)&#123; System.out.println("子类被执行"); &#125;&#125; 子类实现了一个和父类同名的方法，虽然方法名相同，但方法的输入参数不同，这样的方式就保证了子类对父类的方法进行了 重载 而非 重写 ，看具体的场景： 1234567891011public class Client &#123; public static void main(String[] args) &#123; Father f = new Father(); Son s = new Son(); HashMap hashmap = new HashMap(); f.doSomething(hashmap); s.doSomething(hashmap); &#125;&#125; 执行结果： 12父类被执行父类被执行 可以看到我们把调用父类的地方换成了子类，结果依然调用了父类的方法，对程序和业务逻辑没有造成影响，这样就符合了里氏替换原则。 如果子类的参数范围缩小的话，在引用里氏替换原则后执行结果就会变为 子类被执行，这样就会引起物业逻辑混乱，因为父类已经抽象好了方法，而子类“曲解”了父类的意图。 所以子类的覆写父类的方法时，只能让输入参数的范围扩大或相同，不能缩小。 (3)重写父类的方法时输出结果可以被缩小，不能扩大 小结采用里氏替换原则的目的就是增强程序的健壮性，在版本升级时也可以保持非常好的兼容性。保证即使增加子类，原有的子类也可以正常运行。在实际项目中每个子类在同的业务中，使用父类作为参数来实现不同的业务逻辑。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈继承的特点]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%B5%85%E8%B0%88%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。 特点： 子类继承后自动拥有父类所有的非private属性和方法,父类的构造方法无法被继承 子类可以拥有自己的属性和方法 子类可以重写从父类继承过来的方法，但方法的访问权限只能扩大或不变，不能缩小(public&gt;protect&gt;(默认)&gt;private) 当创建一个子类对象时，会先调用父类的构造方法，再调用子类的构造方法 被关键字final修饰的类无法被继承 支持向下转型，例如：123//通过父类创建子类Person person = new Teacher();Teacher teacher = (Teacher)p; 优点： 提高代码的复用性，减少工作量 提高代码的可读性，让层次更清晰 提高代码的易维护性：所有子类共用父类的方法，方法变更时只需修改父类一处 提高代码的拓展性：子类可实现特有的方法 缺点： 继承是侵入的，只要继承，子类就必须拥有父类的所有非私有的属性和方法 继承是高耦合的形式：当父类修改方法时，需要考虑对所有子类的影响，如果有子类重写了该方法，可能会造成非常严重的后果]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止 思路 比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数 重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数 针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; //冒泡排序 public static int[] bubbleSort(int[] arr)&#123; for(int i=0;i&lt;=arr.length;i++)&#123; boolean is_change = false; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr, j, j+1); is_change = true; &#125; &#125; //如果一次完整的遍历中,没有触发过交换，则数组已经有序 if(!is_change)&#123; break; &#125; &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用数据结构&应用场景]]></title>
    <url>%2F2019%2F09%2F12%2FRedis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。 应用场景String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。 Hash常用命令 hget($key,$field) 返回hash表中指定字段的值 hset($key,$field,$value) 设置hash中指定字段的值 hgetall($key) 返回指定key下，哈希表中所有字段和值 实现Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。 应用场景当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。 List常用命令 lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部 rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部 lpop($key) 移除指定列表的第一个元素 rpop($key) 移除指定列表的最后一个元素 lrange($key,$start,$stop) 获取指定列表指定范围内的元素 blpop($key,$timeOut) 移除指定列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 实现Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。 应用场景最新消息排行; 消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。 SetSet集合的特点是在插入元素时Redis会提供去重的功能 常用命令 sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，已经存在与集合中的元素将被忽略 spop($key) 移除集合中的一个随机元素 srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略 smembers($key) 获取指定集合中的所有元素 sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集 sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集 实现set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重 应用场景用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。 SortSet有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点 常用方法 zadd($key,$score,$value) 将一个或多个元素及其分数值加入到有序集合中，重复的元素只更新分数，并按分数重新对集合排序 zrange($key,$start,$end) 获取有序集合中指定区间内的成员信息 zrem($key,$member) 移除一个或多个成员，不存在的成员会忽略，不存在的key或key不是有序集合会返回错误 zcard($key) 获取指定有序集合中元素的数量 实现sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。 应用场景可以用于需要不重复、有序的场景中。例如各种排行榜 延迟队列]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中字符串与0比较问题]]></title>
    <url>%2F2019%2F09%2F06%2Fphp%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E0%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = "CaiRui";if($str==0)&#123; echo "==0成立";&#125;else&#123; echo "==0不成立";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = "CaiRui";if($str===0)&#123; echo "===0成立";&#125;else&#123; echo "===0不成立";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = "CaiRui";if($str=="0")&#123; echo "==0成立";&#125;else&#123; echo "==0不成立";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。]]></content>
      <categories>
        <category>问题整理</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单一职责原则]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine("拍照片"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine("播放音乐"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine("播放音乐"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine("拍照片"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。]]></content>
      <categories>
        <category>知识点整理</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式开篇]]></title>
    <url>%2F2019%2F09%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景，慢慢更新 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望通过对设计模式的理解，自己可以站在一个更高的层次来审视、赏析程序代码。]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Write]]></title>
    <url>%2F2019%2F08%2F28%2FFirst%20Write%2F</url>
    <content type="text"><![CDATA[2019年，终于毕业了，结束了学生生涯 这次搭建了自己的网站，我会花时间来慢慢丰富这个博客 记录自己的成长.]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
