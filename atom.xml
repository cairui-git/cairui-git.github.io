<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>坚持是一种品格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2019-11-07T08:29:53.023Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>旋转正方形矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/07/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/07/算法题-旋转正方形矩阵/</id>
    <published>2019-11-07T07:43:14.000Z</published>
    <updated>2019-11-07T08:29:53.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><a id="more"></a><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。&lt;/p&gt;
&lt;p&gt;要求：额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>之字形打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/05/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/05/算法题-之字形打印矩阵/</id>
    <published>2019-11-05T07:43:50.000Z</published>
    <updated>2019-11-07T10:51:28.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：</p><ul><li>1</li><li>2 5</li><li>9 6 3</li><li>4 7 10 13</li><li>14 11 8</li><li>12 15</li><li>16</li></ul><a id="more"></a><p>要求：额外空间复杂度为O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角</li><li>指针A、B每次同时移动一格，移动规则为：<ul><li>指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动</li><li>指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动</li></ul></li><li>在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印)</li><li>最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之字型打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] indexA = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] indexB = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAToB = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            printStraightLine(matrix,indexA,indexB,isAToB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>) &amp;&amp; indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123; <span class="comment">//终点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新A、B坐标</span></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexA[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexA[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexB[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexB[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isAToB = !isAToB;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印点A~B这条线的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStraightLine</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] indexA, <span class="keyword">int</span>[] indexB, <span class="keyword">boolean</span> isAToB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (indexA[<span class="number">0</span>] == indexB[<span class="number">0</span>] &amp;&amp; indexA[<span class="number">1</span>] == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.println(matrix[indexA[<span class="number">0</span>]][indexA[<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能改变数组中的值,用变量代替</span></span><br><span class="line">        <span class="keyword">int</span> x = isAToB ? indexA[<span class="number">0</span>] : indexB[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = isAToB ? indexA[<span class="number">1</span>] : indexB[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isAToB) &#123; <span class="comment">// 从A打印到B</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == indexB[<span class="number">0</span>] &amp;&amp; y == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从B打印到A</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (indexA[<span class="number">0</span>] == x &amp;&amp; indexA[<span class="number">1</span>] == y) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ZigZagPrintMatrix.zigZagPrintMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/11/05/M9pE11.png" alt="M9pE11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2 5&lt;/li&gt;
&lt;li&gt;9 6 3&lt;/li&gt;
&lt;li&gt;4 7 10 13&lt;/li&gt;
&lt;li&gt;14 11 8&lt;/li&gt;
&lt;li&gt;12 15&lt;/li&gt;
&lt;li&gt;16&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习笔记</title>
    <link href="http://blog.cairui99.cn/2019/11/01/go-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.cairui99.cn/2019/11/01/go-go语言学习笔记/</id>
    <published>2019-11-01T06:04:02.000Z</published>
    <updated>2019-11-08T08:56:23.419Z</updated>
    
    <content type="html"><![CDATA[<center>从零开始，持续更新</center><p><img src="https://s2.ax1x.com/2019/11/01/K7h5QA.png" alt="K7h5QA.png"></p><a id="more"></a><p>参考书籍：<strong>《Go程序设计语言》</strong></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="前往官网下载源码"><a href="#前往官网下载源码" class="headerlink" title="前往官网下载源码"></a>前往官网下载源码</h3><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">点击此处官网</a>(可能需要翻墙)</p><p>根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的</p><p><a href="https://imgchr.com/i/K7XWYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7XWYn.md.png" alt="K7XWYn.md.png"></a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar  -zxvf  go1.13.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建workspace</span><br><span class="line">$ mkdir -p workspace/src</span><br><span class="line"></span><br><span class="line">2.配置环境变量</span><br><span class="line">$ vi ~/.bashrc</span><br><span class="line"></span><br><span class="line">将以下配置添加进bashrc中</span><br><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export GOPATH=$HOME/workspace</span><br><span class="line">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH</span><br><span class="line"></span><br><span class="line">使配置生效</span><br><span class="line">$ source ~/.bashrc</span><br><span class="line"></span><br><span class="line">3.验证是否成功</span><br><span class="line">$ go version</span><br></pre></td></tr></table></figure><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>创建一个 HelloWorld.go 文件 <strong>(注意创建在你的GOPATH目录下)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run HelloWorld.go</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build HelloWorld.go</span><br></pre></td></tr></table></figure><p>此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./HelloWorld</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>下面说一下代码：<br>Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。</p><p>每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。</p><p>package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。</p><p>在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。</p><p>Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句</p><p>Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。</p><h3 id="输出命令行参数"><a href="#输出命令行参数" class="headerlink" title="输出命令行参数"></a>输出命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s, sep <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">s += sep + os.Args[i]</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。</p><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo.go 1 3 -X ?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 3 -X ?</span><br></pre></td></tr></table></figure><p>使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串</p><p>循环变量i在for循环的开始处声明，使用 <strong>:=</strong> 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。</p><p>注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且<strong>左大括号不能独立成行</strong>，必须和前置语句在同一行</p><p>for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中三个部分都是可以省略的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环 while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环这种形式可以通过如break、return等语句进行终止</p><p>还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s, sep := <span class="string">""</span>, <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">s += sep + arg</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义简洁方便，通常在函数内部使用，不适用于包级别的变量</span></span><br><span class="line">s := <span class="string">""</span></span><br><span class="line"><span class="comment">//使用默认初始化值时的定义方式</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="comment">//很少使用，除非定义多个变量时使用</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">""</span></span><br><span class="line"><span class="comment">//在类型不一致时，强调类型使用</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 <strong>_</strong> 这个变量，<strong>_</strong> 在go语言中表示 <strong>空标识符</strong> ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。</p><p>如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果不关心格式或者只是调试程序时，可以直接使用Println：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果和预期很像，只是两边有括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo4.go 1 2 s d ?</span><br><span class="line"></span><br><span class="line">[1 2 s d ?]</span><br></pre></td></tr></table></figure><h3 id="找出重复行"><a href="#找出重复行" class="headerlink" title="找出重复行"></a>找出重复行</h3><h4 id="从控制台输入"><a href="#从控制台输入" class="headerlink" title="从控制台输入"></a>从控制台输入</h4><p>下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>,n,line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup1.go</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">21</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。</p><p>接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。</p><p>在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。</p><p>为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。</p><p>下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。</p><p>例如程序中的 <strong>“%d\t%s\n”</strong>含义为： <strong>%d</strong> 为将一个整数格式化为十进制形式、 <strong>\t</strong> 制表符、 <strong>%s</strong> 把参数输入为字符串、 <strong>\n</strong> 换行符。</p><p>下面给出一些常用的Printf转义字符，Go程序员将其称为verb：</p><table><thead><tr><th align="center">verb</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">十进制整数</td></tr><tr><td align="center">%x, %o, %b</td><td align="center">十六进制、八进制、二进制整数</td></tr><tr><td align="center">%f, %g, %e</td><td align="center">浮点型</td></tr><tr><td align="center">%t</td><td align="center">布尔型</td></tr><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%q</td><td align="center">带引号的字符串(“abc”或者’c’)</td></tr><tr><td align="center">%v</td><td align="center">内置格式的任何值</td></tr><tr><td align="center">%T</td><td align="center">任何值的类型</td></tr><tr><td align="center">%%</td><td align="center">百分号本身</td></tr></tbody></table><h4 id="流式读取文件"><a href="#流式读取文件" class="headerlink" title="流式读取文件"></a>流式读取文件</h4><p>下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">files := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">countLines(os.Stdin, counts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := os.Open(arg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">countLines(f, counts)</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(f)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for test：</p><p>首先创建一个测试文件，名为test.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup2.go test.txt</span><br><span class="line"></span><br><span class="line">3123</span><br><span class="line">212</span><br></pre></td></tr></table></figure><p>os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。</p><p>可以看出 <strong>在go中函数的声明次序是任意的，包括main函数。</strong></p><p>在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。</p><h4 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h4><p>上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。</p><p>下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">data, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup3: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="keyword">string</span>(data), <span class="string">"\n"</span>) &#123;</span><br><span class="line">counts[line]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行方式与结果同dup2.go</p><p>ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。</p><p>持续更新中…</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;从零开始，持续更新&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/01/K7h5QA.png&quot; alt=&quot;K7h5QA.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.cairui99.cn/categories/Go/"/>
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/Go/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="go语言基础" scheme="http://blog.cairui99.cn/tags/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-最少知识原则</title>
    <link href="http://blog.cairui99.cn/2019/11/01/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E6%B3%95%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/11/01/设计原则-最少知识法则/</id>
    <published>2019-11-01T03:31:11.000Z</published>
    <updated>2019-11-01T06:00:02.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最少知识法则也称为迪米特原则，定义为：<strong>一个对象应该对其他对象有最少的了解。</strong></p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>迪米特法则对实现类的低耦合提出了明确的要求，规则如下：</p><h5 id="1-只和直接的朋友通信"><a href="#1-只和直接的朋友通信" class="headerlink" title="1.只和直接的朋友通信"></a>1.只和直接的朋友通信</h5><p>直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。</p><p>类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。</p><h5 id="2-朋友间也需要有距离"><a href="#2-朋友间也需要有距离" class="headerlink" title="2.朋友间也需要有距离"></a>2.朋友间也需要有距离</h5><p>一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。</p><h5 id="3-是自己的就是自己的"><a href="#3-是自己的就是自己的" class="headerlink" title="3.是自己的就是自己的"></a>3.是自己的就是自己的</h5><p>如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;最少知识法则也称为迪米特原则，定义为：&lt;strong&gt;一个对象应该对其他对象有最少的了解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-接口隔离原则</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/10/30/设计原则-接口隔离原则/</id>
    <published>2019-10-30T07:25:09.000Z</published>
    <updated>2019-10-31T12:16:35.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Clients should not be forced to depend upon interfaces that they don’t use.</strong></p><p><strong>“客户端不应该依赖它不需要的接口”</strong>，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。</p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实现接口时尽量做到以下规范：</p><ul><li>接口要做到高内聚：尽量少的公布public方法，降低变更的风险</li><li>定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法</li><li>有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口</li><li>已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理</li><li>接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Clients should not be forced to depend upon interfaces that they don’t use.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户端不应该依赖它不需要的接口”&lt;/strong&gt;，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E7%AE%97%E6%B3%95%E9%A2%98-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/10/30/算法题-顺时针打印矩阵/</id>
    <published>2019-10-30T06:11:01.000Z</published>
    <updated>2019-11-07T10:55:10.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下：</p><ul><li>在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1)</li><li>完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标</li><li>重复执行上述步骤，直至得到的坐标无法构成矩阵为止</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwisePrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (B[<span class="number">0</span>] &gt;= A[<span class="number">0</span>] &amp;&amp; B[<span class="number">1</span>] &gt;= A[<span class="number">1</span>]) &#123;</span><br><span class="line">            print(matrix,A[<span class="number">0</span>]++,A[<span class="number">1</span>]++,B[<span class="number">0</span>]--,B[<span class="number">1</span>]--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角坐标(a,b)</span></span><br><span class="line"><span class="comment">     * 右下角坐标(c,d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (a, b) -&gt; (a, d)</span></span><br><span class="line">        <span class="keyword">int</span> index = b;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; d) &#123;</span><br><span class="line">            System.out.print(arr[a][index++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (a, d) -&gt; (c, d)</span></span><br><span class="line">        index = a;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; c) &#123;</span><br><span class="line">            System.out.print(arr[index++][d] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, d) -&gt; (c, b)</span></span><br><span class="line">        index = d;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; b) &#123;</span><br><span class="line">            System.out.print(arr[c][index--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, b) -&gt; (a, b)</span></span><br><span class="line">        index = c;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; a) &#123;</span><br><span class="line">            System.out.print(arr[index--][b]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ClockwisePrintMatrix.printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>栈实现队列&amp;队列实现栈</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-栈实现队列-队列实现栈/</id>
    <published>2019-10-28T07:02:20.000Z</published>
    <updated>2019-10-30T05:45:28.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>要求使用栈实现队列的如下方法：</p><ul><li>offer(入队)</li><li>poll(出队)</li><li>peek(查看栈顶元素)</li></ul><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个栈，push栈和pop栈</li><li>offer()：push栈正常入栈</li><li>poll(): 弹出pop栈的栈顶元素并返回 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li><li>peek(): 返回pop栈的栈顶元素 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; push = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pop  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        push.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!push.isEmpty()) &#123;</span><br><span class="line">            pop.push(push.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列实现栈结构"><a href="#队列实现栈结构" class="headerlink" title="队列实现栈结构"></a>队列实现栈结构</h3><p>要求使用队列实现栈结构的如下方法：</p><ul><li>push(入栈)</li><li>pop(出栈)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个队列，data队列和help队列</li><li>push(): data队列正常入队</li><li>pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回</li><li>peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列实现栈结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBecomeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        data.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> help.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = data.remove();</span><br><span class="line">        help.offer(ret);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈实现队列&quot;&gt;&lt;a href=&quot;#栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;栈实现队列&quot;&gt;&lt;/a&gt;栈实现队列&lt;/h3&gt;&lt;p&gt;要求使用栈实现队列的如下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offer(入队)&lt;/li&gt;
&lt;li&gt;poll(出队)&lt;/li&gt;
&lt;li&gt;peek(查看栈顶元素)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Min栈的实现</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-Min%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-Min栈的实现/</id>
    <published>2019-10-28T06:46:05.000Z</published>
    <updated>2019-10-30T06:21:34.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：</p><ul><li>1．pop、push、peek、getMin操作的时间复杂度都是O(1)。</li><li>2．设计的栈类型可以使用现成的栈结构。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>内部创建两个栈，data栈和min栈</li><li>元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是<strong>(min栈的栈顶存的永远是data栈中的最小值)</strong></li><li>出栈时data栈和min栈一起正常出栈</li><li>getMin()方法只需要返回min栈的栈顶元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span></span><br><span class="line"><span class="comment"> * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。</span></span><br><span class="line"><span class="comment"> *         2．设计的栈类型可以使用现成的栈结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        data.push(num);</span><br><span class="line">        min.push((min.peek() &gt; num) ? num : min.peek());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.pop();</span><br><span class="line">        <span class="keyword">return</span> data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1．pop、push、peek、getMin操作的时间复杂度都是O(1)。&lt;/li&gt;
&lt;li&gt;2．设计的栈类型可以使用现成的栈结构。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>更快的获取中位数</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-更快的获取中位数/</id>
    <published>2019-10-28T05:56:44.000Z</published>
    <updated>2019-10-30T06:20:33.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。</p><p>此时收集数的操作是 <strong>O(1)</strong>，获取中位数的操作是 <strong>O(n*logn)</strong></p><p>如果接口被频繁调用，排序的代价就太高了，下面利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来进行优化：</p><ul><li>创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下：<ul><li>假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中</li><li>两个堆中元素数量保持平衡，差值不大于1</li></ul></li><li>如何获取中位数：<ul><li>如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素</li><li>如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值</li></ul></li></ul><p> 此时收集数的操作需要进行一次heapInsert 代价是 <strong>O(logn)</strong>，而获取中位数的操作变为了 <strong>O(1)</strong>，效率得到了很大的提升 <strong>O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianQuick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bigSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smallSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberInsert</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.automaticCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &gt; bigHeap[<span class="number">0</span>]) &#123; <span class="comment">//较大的数进小根堆</span></span><br><span class="line">            smallHeap[smallSize++] = number;</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//较小的数进大根堆</span></span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//平衡堆中元素数量，差值不等大于1</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize - smallSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,<span class="number">0</span>);</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize - bigSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,<span class="number">1</span>);</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(bigHeap[<span class="number">0</span>] + smallHeap[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bigSize &gt; smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> smallHeap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">automaticCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.bigHeap.length+<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.smallHeap.length+<span class="number">100</span>];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.bigHeap, <span class="number">0</span>, bigHeap, <span class="number">0</span>, bigSize);</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.smallHeap, <span class="number">0</span>, smallHeap, <span class="number">0</span>, smallSize);</span><br><span class="line">        <span class="keyword">this</span>.bigHeap = bigHeap;</span><br><span class="line">        <span class="keyword">this</span>.smallHeap = smallHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">Heap类的相关代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数组实现队列</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-数组实现队列/</id>
    <published>2019-10-28T03:39:43.000Z</published>
    <updated>2019-10-30T06:20:58.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>使用数组实现队列结构，实现方法：</p><ul><li>add(向队尾添加元素)</li><li>poll(返回队首元素，并移除)</li><li>peek(返回队首元素)</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针start、end和一个变量size，初始值都为0<ul><li>start表示队首元素的位置</li><li>end表示下一个元素入队时要添加的位置</li><li>size表示队列大小</li><li><strong>start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组</strong></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个元素到队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = num;</span><br><span class="line">        end = (end == arr.length - <span class="number">1</span>) ? <span class="number">0</span> : ++end;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素，并移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> result = arr[start];</span><br><span class="line">        start = start == arr.length - <span class="number">1</span> ? <span class="number">0</span> : ++start;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//预计输出：1 1 2 3 3</span></span><br><span class="line">        ArrayBecomeQueue queue = <span class="keyword">new</span> ArrayBecomeQueue(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        queue.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;使用数组实现队列结构，实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add(向队尾添加元素)&lt;/li&gt;
&lt;li&gt;poll(返回队首元素，并移除)&lt;/li&gt;
&lt;li&gt;peek(返回队首元素)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>相邻两数最大差值</title>
    <link href="http://blog.cairui99.cn/2019/10/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <id>http://blog.cairui99.cn/2019/10/22/算法题-相邻两数最大差值/</id>
    <published>2019-10-22T06:08:22.000Z</published>
    <updated>2019-10-24T06:02:09.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)</p><a id="more"></a><p>举个例子：</p><ul><li>给定数组：{4,5,1,2}</li><li>排好序后的数组是：{1,2,4,5}</li><li>相邻两数的差值分别为：1,2,1</li><li>需要返回最大差值，所以最终结果就是2</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先把数组排序，再遍历数组求出所有差值，返回最大的那一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">            result = border;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用</strong></p><h3 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h3><p>这里利用了桶的概念，但没有进行桶排序</p><p>思路：</p><ul><li>假设数组中有N个数，创建N+1个桶</li><li>遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶</li><li>然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中   (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：<strong>1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5</strong>)</li></ul><p>这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 <strong>产生最大差值的两个相邻数绝对不会来自于相同桶</strong></p><p>有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了</p><p>所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 <strong>相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorderCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBorderCount</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤非法数据</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶</span></span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录桶是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span>[] existNumber = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值和最大值相等：返回0</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr);</span><br><span class="line">        <span class="keyword">int</span> minNum = criticalMap.get(<span class="string">"Min"</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = criticalMap.get(<span class="string">"Max"</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNum == maxNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值放在第一个桶，最大值放在最后一个桶</span></span><br><span class="line">        min[<span class="number">0</span>] = minNum;</span><br><span class="line">        max[<span class="number">0</span>] = minNum;</span><br><span class="line">        existNumber[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        min[min.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        max[max.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        existNumber[existNumber.length-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个桶中存放的数值范围</span></span><br><span class="line">        <span class="keyword">double</span> scope = (<span class="keyword">double</span>) (min[min.length-<span class="number">1</span>] - min[<span class="number">0</span>])/min.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == min[<span class="number">0</span>] || num == max[max.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该元素应该存放的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.ceil((num - min[<span class="number">0</span>]) / scope)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existNumber[index]) &#123;</span><br><span class="line">                min[index] = num;</span><br><span class="line">                max[index] = num;</span><br><span class="line">                existNumber[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; max[index]) &#123;</span><br><span class="line">                    max[index] = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min[index]) &#123;</span><br><span class="line">                    min[index] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录非空桶的坐标</span></span><br><span class="line">        List&lt;Integer&gt; existIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existNumber.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existNumber[i]) &#123;</span><br><span class="line">                existIndex.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最大差值</span></span><br><span class="line">        <span class="keyword">int</span> maxBorderCount = max[<span class="number">0</span>] - min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existIndex.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = min[existIndex.get(i+<span class="number">1</span>)] - max[existIndex.get(i)];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; maxBorderCount) &#123;</span><br><span class="line">                maxBorderCount = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxBorderCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值和最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; <span class="title">getMaxAndMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">"Max"</span>,max);</span><br><span class="line">        result.put(<span class="string">"Min"</span>,min);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">                result = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; testCount;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = ArrayUtil.getArray(<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span> border1 = BorderCount.getBorderCount(arr1);</span><br><span class="line">            <span class="keyword">int</span> border2 = BorderCount.testMethod(arr2);</span><br><span class="line">            <span class="keyword">if</span> (border1 != border2) &#123;</span><br><span class="line">                is_success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_success) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://blog.cairui99.cn/2019/10/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/10/18/排序算法-堆排序/</id>
    <published>2019-10-18T02:38:03.000Z</published>
    <updated>2019-10-28T03:31:12.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来设计的一种排序算法。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将整个数组构建成大根堆</li><li>依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置<ul><li>在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组</li></ul></li><li>当堆中所有元素弹出完毕，此时数组已全部有序</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Heap.buildBigHeap(arr,arr.length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            Heap.heapPop(arr,arr.length-i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        ArrayUtil.swap(arr,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        heapFalling(arr,length-<span class="number">2</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向堆中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组中(0 ~ index-1)为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ArrayUtil.swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;</p><p>最差时间复杂度: <strong>O(n*logn)</strong>;</p><p>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(1)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>不稳定</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h3&gt;&lt;p&gt;堆排序是利用&lt;a href=&quot;https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/&quot;&gt;堆结构&lt;/a&gt;的特点来设计的一种排序算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://blog.cairui99.cn/2019/10/16/数据结构-堆/</id>
    <published>2019-10-16T09:34:42.000Z</published>
    <updated>2019-10-18T06:33:45.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。</p><a id="more"></a><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>首先堆的结构是一颗 <strong>完全二叉树</strong></p><ul><li><strong>完全二叉树</strong>：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图：<br><img src="https://s2.ax1x.com/2019/10/17/KkXhRO.jpg" alt="KkXhRO.jpg"></li></ul><p>在程序中，我们可以使用数组结构来抽象出一颗完全二叉树：</p><ul><li>数组中的0位置代表根节点</li><li>假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为：<ul><li>左孩子：<strong>2*i+1</strong></li><li>右孩子：<strong>2*i+2</strong></li></ul></li><li>假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为：<ul><li>父节点：<strong>(i-1)/2</strong></li><li>根节点的父节点是自己：(0-1)/2 = 0</li></ul></li></ul><p>使用上面的抽象规则，我们就可以把 <strong>任意数组抽象为一颗完全二叉树。</strong></p><h4 id="构建推结构"><a href="#构建推结构" class="headerlink" title="构建推结构"></a>构建推结构</h4><p>堆分为两种：</p><ul><li>大根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最大值</strong> 都是头部</li><li>小根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最小值</strong> 都是头部</li></ul><p>以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？</p><p><strong>步骤：</strong></p><ul><li>首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中</li><li>后面通过遍历数组，将每个元素依次进堆</li><li>进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止</li><li>数组中所有元素进堆完毕，则大根堆构建完成</li></ul><p>时间复杂度：O(n)</p><h4 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a>弹出堆顶元素</h4><p>在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。</p><p><strong>步骤：</strong></p><ul><li>将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中</li><li>对此时的堆顶元素进行<strong>下沉</strong>操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉)<ul><li>下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子<strong>(如果没有右孩子就不比较，但一定有左孩子)</strong> 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉</li></ul></li><li>堆顶元素下沉完毕后，此时又重新构建好了堆结构</li></ul><p>时间复杂度：O(logn)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        swap(arr,<span class="number">0</span>,length);</span><br><span class="line">        heapFalling(arr,length-<span class="number">1</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Heap.buildBigHeap(arr,<span class="number">1</span>);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">        <span class="keyword">int</span> min = Heap.heapPop(arr,arr.length-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h3&gt;&lt;p&gt;堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://blog.cairui99.cn/2019/10/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/10/12/排序算法-快速排序/</id>
    <published>2019-10-12T07:04:19.000Z</published>
    <updated>2019-10-28T08:28:55.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>选取数组中的中的一个数作为基准数，然后将数组调整为两部分：左部分的数全部小于等于基准数、右部分的数全部大于基准数(子序列中内部不需要有序)</li><li>递归的对数组两个部分继续执行上述步骤，直至数组有序</li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul><li>将数组划分为三个部分，小于、等于、大于区域 (<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">具体实现</a>)</li><li>这时等于区域的数就已经位于理想的位置，因此只需要递归小于区域和大于区域 <strong>(在有很多重复数字的情况下效率提升会很明显)</strong></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = grouping(arr,left,right);</span><br><span class="line">        <span class="comment">//递归小于区域和大于区域</span></span><br><span class="line">        quickSort(arr,left,index[<span class="number">0</span>]);</span><br><span class="line">        quickSort(arr,index[<span class="number">1</span>],right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分出小于、等于、大于区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] grouping(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">int</span> indexFront = left;</span><br><span class="line">        <span class="keyword">int</span> indexMid = left;</span><br><span class="line">        <span class="keyword">int</span> indexRear = right;</span><br><span class="line">        <span class="keyword">int</span> num = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">                swap(arr, indexMid, indexFront);</span><br><span class="line">                <span class="keyword">if</span> (indexMid + <span class="number">1</span> &gt; indexRear) <span class="keyword">break</span>;</span><br><span class="line">                indexMid++;</span><br><span class="line">                indexFront++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMid + <span class="number">1</span> &gt; indexRear) <span class="keyword">break</span>;</span><br><span class="line">                indexMid++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMid &gt; indexRear - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                swap(arr, indexMid, indexRear);</span><br><span class="line">                indexRear--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回临界值坐标</span></span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        index[<span class="number">0</span>] = (arr[indexFront] == num) ? (indexFront - <span class="number">1</span>) : indexFront;</span><br><span class="line">        index[<span class="number">1</span>] = (arr[indexRear] == num) ? (indexRear + <span class="number">1</span>) : indexRear;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">        arr[x] = arr[y];</span><br><span class="line">        arr[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;</p><p>最差时间复杂度: <strong>O(n2)</strong>; (快排在最差情况下会退化为冒泡)</p><p>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(logn)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>不稳定</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-向git推送更新失败</title>
    <link href="http://blog.cairui99.cn/2019/10/11/Hexo-%E5%90%91git%E6%8E%A8%E9%80%81%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5/"/>
    <id>http://blog.cairui99.cn/2019/10/11/Hexo-向git推送更新失败/</id>
    <published>2019-10-11T09:31:12.000Z</published>
    <updated>2019-10-12T06:29:04.616Z</updated>
    
    <content type="html"><![CDATA[<p>今天在更新博客时发生了 <strong>hexo d</strong> 时推送失败的情况。</p><p>报错信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 52.74.223.119 port 22</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><a id="more"></a><p>这表示git客户端无法连接至github，原因大概是防火墙禁止了ip为52.74.223.119端口22的ssh连接</p><p><strong>解决方法：</strong></p><p><strong>(1)</strong> 我的解决的方法是切换网络，将wifi切成手机热点就提交成功了。</p><p><strong>(2)</strong> 如果条件不允许或者切换网络依旧不成功，需要手动将防火墙中的 <strong>22端口设置为允许连接</strong></p><p><a href="https://www.cnblogs.com/Diamond-sjh/p/11352156.html" target="_blank" rel="noopener">具体操作请参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在更新博客时发生了 &lt;strong&gt;hexo d&lt;/strong&gt; 时推送失败的情况。&lt;/p&gt;
&lt;p&gt;报错信息:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Connection reset by 52.74.223.119 port 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: Could not read from remote repository.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="问题整理" scheme="http://blog.cairui99.cn/categories/%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Hexo" scheme="http://blog.cairui99.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题</title>
    <link href="http://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/10/11/算法题-荷兰国旗问题/</id>
    <published>2019-10-11T06:44:37.000Z</published>
    <updated>2019-10-30T06:20:48.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。</p><a id="more"></a><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路 时间复杂度(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badMethod</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;num) &#123;</span><br><span class="line">            alist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n==num) &#123;</span><br><span class="line">            blist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clist.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index = setArray(arr,index,alist);</span><br><span class="line">    index = setArray(arr,index,blist);</span><br><span class="line">    setArray(arr,index,clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, @NotNull List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度改进为O(1)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlag</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">            swap(arr,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用三个指针，交换全部在数组内部进行，三个指针的含义为：</p><ul><li>indexFront : 指针前面的所有数都满足小于num</li><li>indexMid : 指针前面所有的数都满足小于等于num</li><li>indexRear : 指针后面所有的数都满足大于num</li></ul><p>终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>IDEA-批量修改变量名</title>
    <link href="http://blog.cairui99.cn/2019/10/11/IDEA-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    <id>http://blog.cairui99.cn/2019/10/11/IDEA-批量修改变量名/</id>
    <published>2019-10-11T05:44:15.000Z</published>
    <updated>2019-10-11T05:49:08.470Z</updated>
    
    <content type="html"><![CDATA[<p>双击选中修改对象后： <strong>Shift+F6</strong></p><p>变量名填写完成后按回车执行修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;双击选中修改对象后： &lt;strong&gt;Shift+F6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量名填写完成后按回车执行修改&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="IDEA快捷键" scheme="http://blog.cairui99.cn/tags/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>小和问题</title>
    <link href="http://blog.cairui99.cn/2019/09/27/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/09/27/算法题-小和问题/</id>
    <published>2019-09-27T07:35:43.000Z</published>
    <updated>2019-10-30T06:21:20.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p><p>现在给出一个数组请求出数组的小和。</p><a id="more"></a><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>数组：[1,3,4,2,5]</p><p>1左边比1小的数，没有；</p><p>3左边比3小的数，1；</p><p>4左边比4小的数，1、3；</p><p>2左边比2小的数，1；</p><p>5左边比5小的数，1、3、4、2；</p><p>所以小和为1+1+3+1+1+3+4+2=16</p><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路,O(n2)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">badMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[j]) smallSum += arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>在<a href="https://blog.cairui99.cn/2019/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>的基础上进行改进，在merge左右两个有序数组时候，<strong>如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和</strong>，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用分治思想,O(n*logn)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left - (left-right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,left,mid) + getSmallSum(arr,mid+<span class="number">1</span>,right) + merge(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] merge_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> index_merge = left;</span><br><span class="line">    <span class="keyword">int</span> index_left = left;</span><br><span class="line">    <span class="keyword">int</span> index_right = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外排</span></span><br><span class="line">    <span class="keyword">while</span> (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数)</span></span><br><span class="line">        smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+<span class="number">1</span>) * arr[index_left] : <span class="number">0</span>;</span><br><span class="line">        merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = index_left&lt;=mid ? index_left : index_right;</span><br><span class="line">    <span class="keyword">int</span> end = index_left&lt;=mid ? mid : arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line">        merge_arr[index_merge++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排好序的结果赋给原数组</span></span><br><span class="line">    System.arraycopy(merge_arr, left, arr, left, right + <span class="number">1</span> - left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时算法的时间复杂度就提升到了O(n*logn)的级别</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。&lt;/p&gt;
&lt;p&gt;现在给出一个数组请求出数组的小和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="http://blog.cairui99.cn/2019/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/09/26/排序算法-归并排序/</id>
    <published>2019-09-26T08:00:54.000Z</published>
    <updated>2019-10-08T08:47:00.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 <strong>(将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)</strong>，归并排序是分治法的典型应用。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>将数组分解为各含n/2个元素的子数组，递归的拆分数组，当子数组长度为1时，默认子数组是就有序的</li><li>将两个有序的数组通过外排合并为一个有序的数组</li><li>当全部子数组合并完成时，原数组变为有序</li></ul><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://s2.ax1x.com/2019/09/27/uu5ia4.gif" alt="uu5ia4.gif"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * author:Cai Rui</span></span><br><span class="line"><span class="comment"> * date:2019-09-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = left - (left-right)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr,left,mid);</span><br><span class="line">mergeSort(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">merge(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] merge_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">int</span> index_merge = left;</span><br><span class="line"><span class="keyword">int</span> index_left = left;</span><br><span class="line"><span class="keyword">int</span> index_right = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外排</span></span><br><span class="line"><span class="keyword">while</span> (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123;</span><br><span class="line">merge_arr[index_merge++] = (arr[index_left] &gt; arr[index_right]) ? arr[index_right++] : arr[index_left++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start = index_left&lt;=mid ? index_left : index_right;</span><br><span class="line"><span class="keyword">int</span> end = index_left&lt;=mid ? mid : arr.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line">merge_arr[index_merge++] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将排好序的结果赋给原数组</span></span><br><span class="line">System.arraycopy(merge_arr, left, arr, left, right + <span class="number">1</span> - left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;<br>最差时间复杂度: <strong>O(n*logn)</strong> ;<br>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(n)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>稳定</strong>(在外排过程中，当遇到相等元素先存左边的数，就可以保证排序结果是稳定的)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 &lt;strong&gt;(将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)&lt;/strong&gt;，归并排序是分治法的典型应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>依赖倒置原则</title>
    <link href="http://blog.cairui99.cn/2019/09/24/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/09/24/设计原则-依赖倒置原则/</id>
    <published>2019-09-24T11:11:34.000Z</published>
    <updated>2019-10-08T08:46:58.297Z</updated>
    
    <content type="html"><![CDATA[<p>依赖倒置原则简单来说就是我们常说的 <strong>面向接口编程——OOD</strong>.</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</strong></p><p>翻译过来就是：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p>每一个逻辑的具体实现就是低层模块(一般指方法)，各种逻辑的组装就是高层模块。</p><p>抽象是指接口或者抽象类，属于不能被示例化的；细节就是可以被实例化的实现类，一般指实现接口或继承抽象类的类。</p><p>依赖倒置原则在开发过程中的体现就是：</p><ul><li>模块间的依赖通过抽象发生，实现类之间不直接发生依赖，其依赖关系是通过接口或抽象类产生的</li><li>接口或抽象类不依赖实现类</li><li>实现类依赖接口或抽象类</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>看一个应用到依赖倒置原则的例子：</p><p>下图是在不使用依赖倒置原则的情况下，奔驰车和驾车司机的类图设计：<br><img src="https://s2.ax1x.com/2019/09/26/umFHPI.png" alt="umFHPI.png"><br>奔驰车中提供run方法，表示车辆运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"奔驰汽车开始运行..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>司机通过调用奔驰车的run方法来驾驶奔驰车：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Benz benz)</span></span>&#123;</span><br><span class="line">    benz.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>司机驾驶奔驰汽车的场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">    Benz benz = <span class="keyword">new</span> Benz();</span><br><span class="line">    driver.drive(benz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了司机开动奔驰车的功能，目前为止程序的功能没有任何问题。</p><p>此时如果我们现在不仅有奔驰车，又添加了一辆宝马车，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"宝马汽车开始运行..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了宝马车之后，我们发现司机竟然没有办法把宝马车开动起来，这是因为目前的司机和奔驰车是紧耦合的关系，要想让司机开动奔驰车就必须修改司机类的代码，被依赖者的变更竟然需要依赖者来承担修改的代价，可见上面的程序稳定性和可维护性都是非常差的</p><p>在比较大一些项目开发中，团队中每个人都会负责不同的模块，这里假设这个项目的团队中甲负责汽车类的维护，乙负责司机类的维护，如果按照上面的思路开发，那么在甲开发完成之前乙是不能编写drive方法，因为缺少汽车类，所以此时团队的开发工作是无法做到并行开发的，这严重影响了项目的开发效率</p><p>为了解决以上问题，对该项目引入依赖倒置原则后的类图如图所示：<br><img src="https://s2.ax1x.com/2019/09/26/umdtij.png" alt="umdtij.png"></p><p>列出采用依赖倒置原则的三种写法：</p><p>(1)构造函数传入依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ICar car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">(ICar _car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = _car;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构造函数来设置驾驶汽车的类型</p><p>(2)set方法传递依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ICar car;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行drive方法之前通过setCar方法来指定汽车的类型</p><p>(3)接口声明依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line">    car.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"奔驰汽车开始运行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"宝马汽车开始运行..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务场景实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IDriver zhangSan = <span class="keyword">new</span> Driver();</span><br><span class="line">    ICar benz = <span class="keyword">new</span> Benz();</span><br><span class="line">    zhangSan.drive(benz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>为什么是依赖“倒置”：以正常人的思维方式，类之间的依赖关系是实现类之间的依赖，例如司机要开奔驰车，就直接依赖奔驰车，这种就属于“正置”；在编写程序中我们要做到的是对现实世界的事物进行抽象，来实现扩展性和维护性更高的代码，抽象就是抽象类和接口，让我们的的系统产生对抽象的依赖，代替正常人们传统的思维方式(对事物的依赖)，这就是“倒置”的含义</p><p>采用依赖倒置原则带来的好处：</p><ul><li>减少类间的耦合性</li><li>提高系统的稳定性</li><li>降低并行开发的风险</li><li>提高代码的可读性和可维护性</li></ul><p>在项目开发中应遵循：</p><ul><li>实体类尽量有接口或抽象类：有抽象才能进行依赖倒置</li><li>变量的表面类型尽量是接口或抽象类</li><li>不要从具体类中派生出子类</li><li>尽量不重写父类的方法：对依赖的稳定性会有影响</li></ul><p>采用依赖倒置原则的优势在小型项目中很难体现，一般适用于大中型项目，让项目在后续的扩展和维护中更加方便快捷稳定。</p><p><strong>以上内容参考&lt;&lt;设计模式之禅&gt;&gt;</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;依赖倒置原则简单来说就是我们常说的 &lt;strong&gt;面向接口编程——OOD&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
