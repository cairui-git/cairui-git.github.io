<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>坚持是一种品格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2019-09-18T07:38:59.489Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈继承的特点</title>
    <link href="http://blog.cairui99.cn/2019/09/18/%E6%B5%85%E8%B0%88%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <id>http://blog.cairui99.cn/2019/09/18/浅谈继承的特点/</id>
    <published>2019-09-18T06:16:36.000Z</published>
    <updated>2019-09-18T07:38:59.489Z</updated>
    
    <content type="html"><![CDATA[<p>继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。</p><a id="more"></a><p><strong>特点</strong>：</p><ul><li>子类继承后自动拥有父类所有的非private属性和方法,父类的构造方法无法被继承</li><li>子类可以拥有自己的属性和方法</li><li>子类可以重写从父类继承过来的方法，但方法的访问权限只能扩大或不变，不能缩小(public&gt;protect&gt;(默认)&gt;private)</li><li>当创建一个子类对象时，会先调用父类的构造方法，再调用子类的构造方法</li><li>被关键字final修饰的类无法被继承</li><li>支持向下转型，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过父类创建子类</span></span><br><span class="line">Person person = <span class="keyword">new</span> Teacher();</span><br><span class="line">Teacher teacher = (Teacher)p;</span><br></pre></td></tr></table></figure></li></ul><p><strong>优点</strong>：</p><ul><li>提高代码的复用性，减少工作量</li><li>提高代码的可读性，让层次更清晰</li><li>提高代码的易维护性：所有子类共用父类的方法，方法变更时只需修改父类一处</li><li>提高代码的拓展性：子类可实现特有的方法</li></ul><p><strong>缺点</strong>：</p><ul><li>继承是侵入的，只要继承，子类就必须拥有父类的所有非私有的属性和方法</li><li>继承是高耦合的形式：当父类修改方法时，需要考虑对所有子类的影响，如果有子类重写了该方法，可能会造成非常严重的后果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="基础知识" scheme="http://blog.cairui99.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-冒泡排序</title>
    <link href="http://blog.cairui99.cn/2019/09/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/09/17/排序算法-冒泡排序/</id>
    <published>2019-09-17T03:45:02.000Z</published>
    <updated>2019-09-17T07:09:34.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数</li><li>重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数</li><li>针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序</li></ul><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://s2.ax1x.com/2019/09/17/n5pJwq.gif" alt="n5pJwq.gif"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">boolean</span> is_change = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">is_change = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一次完整的遍历中,没有触发过交换，则数组已经有序</span></span><br><span class="line"><span class="keyword">if</span>(!is_change)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[n];</span><br><span class="line">arr[n] = arr[m];</span><br><span class="line">arr[m] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个测试函数，在后续的排序算法中也复用该函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个随机数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min 最小值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> max 最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray(<span class="keyword">int</span> length,<span class="keyword">int</span> min,<span class="keyword">int</span> max)&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>)(min+Math.random()*(max-min+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">System.out.print(num+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = SortTest.getArray(<span class="number">10</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">System.out.print(<span class="string">"随机产生的数组 : "</span>);</span><br><span class="line">SortTest.printArray(arr);</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.print(<span class="string">"冒泡排序后的数组 : "</span>);</span><br><span class="line">SortTest.printArray(BubbleSort.bubbleSort(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随机产生的数组 : 7 1 5 16 12 2 6 11 7 6</span><br><span class="line"></span><br><span class="line">冒泡排序后的数组 : 1 2 5 6 6 7 7 11 12 16</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n)</strong> ;<br>最差时间复杂度: <strong>O(n2)</strong> ;<br>平均时间复杂度: <strong>O(n2)</strong></p><p>空间复杂度: O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用数据结构&amp;应用场景</title>
    <link href="http://blog.cairui99.cn/2019/09/12/Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://blog.cairui99.cn/2019/09/12/Redis常用数据结构-应用场景/</id>
    <published>2019-09-12T08:25:12.000Z</published>
    <updated>2019-09-16T06:21:21.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>get($key) 获取key的值</li><li>set($key,$value) 设置key的值</li><li>incr($key) 将key的值+1</li><li>decr($key) 将key的值-1</li><li>mget($key1,$key2,…) 获取多个key的值</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。</p><a id="more"></a><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>hget($key,$field) 返回hash表中指定字段的值</li><li>hset($key,$field,$value) 设置hash中指定字段的值</li><li>hgetall($key) 返回指定key下，哈希表中所有字段和值</li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部</li><li>rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部</li><li>lpop($key) 移除指定列表的第一个元素</li><li>rpop($key) 移除指定列表的最后一个元素</li><li>lrange($key,$start,$stop) 获取指定列表指定范围内的元素</li><li>blpop($key,$timeOut) 移除指定列表第一个元素，<strong>如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</strong></li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>最新消息排行;</p><p>消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set集合的特点是在插入元素时Redis会提供去重的功能</p><h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，<strong>已经存在与集合中的元素将被忽略</strong></li><li>spop($key) 移除集合中的一个随机元素</li><li>srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略</li><li>smembers($key) 获取指定集合中的所有元素</li><li>sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集</li><li>sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集</li></ul><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重</p><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。</p><h3 id="SortSet"><a href="#SortSet" class="headerlink" title="SortSet"></a>SortSet</h3><p>有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>zadd</li><li>zrange</li><li>zrem</li><li>zcard</li></ul><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。</p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>可以用于需要不重复、有序的场景中。例如各种排行榜</p><p>延迟队列 <strong>(如何实现延迟队列后续详细介绍)</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h3&gt;&lt;h4 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;get($key) 获取key的值&lt;/li&gt;
&lt;li&gt;set($key,$value) 设置key的值&lt;/li&gt;
&lt;li&gt;incr($key) 将key的值+1&lt;/li&gt;
&lt;li&gt;decr($key) 将key的值-1&lt;/li&gt;
&lt;li&gt;mget($key1,$key2,…) 获取多个key的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h4&gt;&lt;p&gt;String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&amp;lt;&amp;lt;Redis设计与实现&amp;gt;&amp;gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Redis" scheme="http://blog.cairui99.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>php中字符串与0比较问题</title>
    <link href="http://blog.cairui99.cn/2019/09/06/php%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E0%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/09/06/php中字符串与0比较问题/</id>
    <published>2019-09-06T03:29:27.000Z</published>
    <updated>2019-09-06T05:49:52.518Z</updated>
    
    <content type="html"><![CDATA[<p>由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。</p><p>问题是 在代码中我用一个 <strong>字符串和0作比较</strong>，结果竟然是 <strong>相等</strong>。</p><a id="more"></a><p>后来自己写了一个例子验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str = <span class="string">"CaiRui"</span>;</span><br><span class="line"><span class="keyword">if</span>($str==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"==0成立"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"==0不成立"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：==<span class="number">0</span>成立</span><br></pre></td></tr></table></figure><p>发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。</p><p>最后列出一些可以得到正确结果的写法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str = <span class="string">"CaiRui"</span>;</span><br><span class="line"><span class="keyword">if</span>($str===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"===0成立"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"===0不成立"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：===<span class="number">0</span>不成立</span><br></pre></td></tr></table></figure><p>===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。<br>在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str = <span class="string">"CaiRui"</span>;</span><br><span class="line"><span class="keyword">if</span>($str==<span class="string">"0"</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"==0成立"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"==0不成立"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：==<span class="number">0</span>不成立</span><br></pre></td></tr></table></figure><p>也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。<br>这种写法不会影响str值为0时的预期结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。&lt;/p&gt;
&lt;p&gt;问题是 在代码中我用一个 &lt;strong&gt;字符串和0作比较&lt;/strong&gt;，结果竟然是 &lt;strong&gt;相等&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题整理" scheme="http://blog.cairui99.cn/categories/%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-单一职责原则</title>
    <link href="http://blog.cairui99.cn/2019/09/04/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/09/04/设计原则-单一职责原则/</id>
    <published>2019-09-04T12:18:10.000Z</published>
    <updated>2019-09-18T02:57:30.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>There should never be more than one reason for a class to change.</strong></p><p>单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。<strong>（单一职责原则同样适用于接口和方法）</strong></p><a id="more"></a><p><strong>看几个例子：</strong></p><p>（1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）：</p><p><img src="https://s2.ax1x.com/2019/09/05/nnOuRK.png" alt="nnOuRK.png"></p><p><strong><center>图1-1 用户信息类图</center></strong></p><p>问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图：</p><p><img src="https://s2.ax1x.com/2019/09/05/nnjA41.png" alt="nnjA41.png"></p><p><strong><center>图1-2 划分职责后的用户类图</center></strong></p><p>按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。</p><p>(2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具有照相的功能的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPhotograph</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Photograph</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具有播放音乐功能的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPlayMusic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlayMusic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现照相、播放音乐的手机类</span></span><br><span class="line">public class MobilePhone : IPhotograph, IPlayMusic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Photograph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"拍照片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放音乐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayMusic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"播放音乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。</p><p>所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现播放音乐功能的音乐播放器类</span></span><br><span class="line">class MusicPlayer : IPlayMusic</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayMusic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"播放音乐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现照相功能的摄像机类</span></span><br><span class="line">class Carmera : IPhotograph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Photograph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"拍照片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。</p><p>我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;There should never be more than one reason for a class to change.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。&lt;strong&gt;（单一职责原则同样适用于接口和方法）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式开篇</title>
    <link href="http://blog.cairui99.cn/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E7%AF%87/"/>
    <id>http://blog.cairui99.cn/2019/09/02/设计模式开篇/</id>
    <published>2019-09-02T10:23:46.000Z</published>
    <updated>2019-09-12T09:49:57.553Z</updated>
    
    <content type="html"><![CDATA[<p>今天开设一个新的模块-设计模式</p><p>学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客</p><p>其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。</p><p>为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？</p><a id="more"></a><p>那就是，设计模式！</p><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring、Yii这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。</p><p>只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。</p><p>希望在不久的将来，通过对设计模式的理解和工作经验的积累，自己可以站在一个更高的层次来审视、赏析程序代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开设一个新的模块-设计模式&lt;/p&gt;
&lt;p&gt;学习途径：&amp;lt;&amp;lt;设计模式之禅&amp;gt;&amp;gt;、以及相关内容的博客&lt;/p&gt;
&lt;p&gt;其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。&lt;/p&gt;
&lt;p&gt;为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>First Write</title>
    <link href="http://blog.cairui99.cn/2019/08/28/First%20Write/"/>
    <id>http://blog.cairui99.cn/2019/08/28/First Write/</id>
    <published>2019-08-28T06:02:35.984Z</published>
    <updated>2019-09-03T03:12:34.111Z</updated>
    
    <content type="html"><![CDATA[<p>2019年，终于毕业了，结束了学生生涯</p><p>这次搭建了自己的网站，我会花时间来慢慢丰富这个博客</p><p>记录自己的成长.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年，终于毕业了，结束了学生生涯&lt;/p&gt;
&lt;p&gt;这次搭建了自己的网站，我会花时间来慢慢丰富这个博客&lt;/p&gt;
&lt;p&gt;记录自己的成长.&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://blog.cairui99.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
