<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>坚持是一种品格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2019-11-21T06:24:36.101Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链与比特币</title>
    <link href="http://blog.cairui99.cn/2019/11/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://blog.cairui99.cn/2019/11/20/区块链与比特币/</id>
    <published>2019-11-20T07:17:39.000Z</published>
    <updated>2019-11-21T06:24:36.101Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/21/M5LtMt.png" alt="M5LtMt.png"></p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>2008年11月1日， <strong>中本聪</strong>（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“<strong>比特币</strong>”的电子货币及其算法，其中实现比特币的底层技术：<strong>chain of blocks</strong> 在最早的比特币白皮书中文翻译版中，将 <strong>chain of blocks</strong> 翻译成了 <strong>区块链</strong>，这是区块链这一中文词的第一次出现。</p><a id="more"></a><h4 id="想要解决的问题"><a href="#想要解决的问题" class="headerlink" title="想要解决的问题"></a>想要解决的问题</h4><p>我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？</p><p>想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。</p><p>好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。</p><p>你也许会问，我依赖第三方机构有什么问题？</p><p>问题在于，你所拥有的不过是清一色的数字，并且修改权不在你：</p><ul><li>要是中央数据库的数据丢失了呢？</li><li>要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？</li><li>要是，他根本就是有意为之呢？你真的可以完全信任他吗？</li></ul><p><strong>多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。</strong></p><p>现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？</p><p>我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？</span><br></pre></td></tr></table></figure><p>是的， <strong>区块链</strong> 就是这个问题的答案，区块链被很多人定义为 <strong>加密的分布式记账技术</strong>,它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。</p><p>下面就来介绍一下这个分散式账簿是如何实现的。</p><p>待更新…</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348" target="_blank" rel="noopener">https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/21/M5LtMt.png&quot; alt=&quot;M5LtMt.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h3&gt;&lt;p&gt;2008年11月1日， &lt;strong&gt;中本聪&lt;/strong&gt;（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“&lt;strong&gt;比特币&lt;/strong&gt;”的电子货币及其算法，其中实现比特币的底层技术：&lt;strong&gt;chain of blocks&lt;/strong&gt; 在最早的比特币白皮书中文翻译版中，将 &lt;strong&gt;chain of blocks&lt;/strong&gt; 翻译成了 &lt;strong&gt;区块链&lt;/strong&gt;，这是区块链这一中文词的第一次出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="拓展知识" scheme="http://blog.cairui99.cn/categories/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="区块链" scheme="http://blog.cairui99.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySql-使用explain分析sql</title>
    <link href="http://blog.cairui99.cn/2019/11/14/MySql-%E4%BD%BF%E7%94%A8explain%E5%88%86%E6%9E%90sql/"/>
    <id>http://blog.cairui99.cn/2019/11/14/MySql-使用explain分析sql/</id>
    <published>2019-11-14T05:54:05.000Z</published>
    <updated>2019-11-14T07:22:04.283Z</updated>
    
    <content type="html"><![CDATA[<p>在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。</p><p>Expliain语法：explain + sql语句</p><a id="more"></a><p>Expliain执行后包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+</span><br></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序：</p><ul><li>id相同：执行顺序由上至下执行</li><li>id不同，按id由大到小执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>表示select的类型，包含以下几种：</p><table><thead><tr><th align="center">select_type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">简单SELECT(不使用UNION或子查询等)</td></tr><tr><td align="center">PRIMARY</td><td align="center">最外层的 select 查询(使用到主键作为查询条件)</td></tr><tr><td align="center">UNION</td><td align="center">UNION中的第二个或后面的SELECT语句</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">UNION中的第二个或后面的SELECT语句，取决于外面的查询</td></tr><tr><td align="center">UNION RESULT</td><td align="center">UNION的结果</td></tr><tr><td align="center">SUBQUERY</td><td align="center">子查询中的第一个SELECT,不依赖于外部查询的结果集</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">子查询中的第一个select查询,依赖于外部查询的结果集</td></tr><tr><td align="center">DERIVED</td><td align="center">导出表的SELECT(FROM子句的子查询)</td></tr></tbody></table><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示该条查询的表名</p><p>如果查询是使用了别名，显示的是别名</p><p>如果不涉及数据库表，显示NULL</p><p>如果显示结果别<derived n>这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N</derived></p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。</p><p>常用的几个type： <strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</strong> 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。</p><table><thead><tr><th align="center">type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</td></tr><tr><td align="center">const</td><td align="center">使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</td></tr><tr><td align="center">eq_ref</td><td align="center">出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</td></tr><tr><td align="center">ref</td><td align="center">不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</td></tr><tr><td align="center">fulltext</td><td align="center">全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</td></tr><tr><td align="center">ref_or_null</td><td align="center">与ref方法类似，只是增加了null值的比较。实际用的不多</td></tr><tr><td align="center">unique_subquery</td><td align="center">用于where中的in形式子查询，子查询返回不重复值唯一值</td></tr><tr><td align="center">index_subquery</td><td align="center">用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</td></tr><tr><td align="center">range</td><td align="center">索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</td></tr><tr><td align="center">index_merge</td><td align="center">表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</td></tr><tr><td align="center">index</td><td align="center">索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user</td></tr><tr><td align="center">all</td><td align="center">这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</td></tr></tbody></table><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>显出可能使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询中实际使用到的索引</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示使用哪个列或常数与key一起从表中选择行。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>显示MySQL认为它执行查询时必须检查的行数</p><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。&lt;/p&gt;
&lt;p&gt;Expliain语法：explain + sql语句&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://blog.cairui99.cn/categories/Mysql/"/>
    
    
      <category term="sql优化" scheme="http://blog.cairui99.cn/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>判断k是否在矩阵中</title>
    <link href="http://blog.cairui99.cn/2019/11/12/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%ADk%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%AD/"/>
    <id>http://blog.cairui99.cn/2019/11/12/算法题-判断k是否在矩阵中/</id>
    <published>2019-11-12T08:23:01.000Z</published>
    <updated>2019-11-12T09:19:58.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：</p><p><img src="https://s2.ax1x.com/2019/11/12/M3ZfoQ.png" alt="M3ZfoQ.png"></p><p>要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点</li><li>假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素</li><li>跟据该特性，判断指针所在位置的元素和整数k的关系：<ul><li>等于k：返回true</li><li>大于k：指针向左移动，如果移动后超过了矩阵边界返回false</li><li>小于k：指针向下移动，如果移动后超过了矩阵边界返回false</li></ul></li><li>重复执行上述步骤，直至函数return</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的.</span></span><br><span class="line"><span class="comment"> * 实现一个函数,判断K是否在matrix中</span></span><br><span class="line"><span class="comment"> * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMatrixNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] &gt; num) &#123;</span><br><span class="line">                index[<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index[<span class="number">0</span>] &gt;= matrix.length || index[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/12/M3ZfoQ.png&quot; alt=&quot;M3ZfoQ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>旋转正方形矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/07/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/07/算法题-旋转正方形矩阵/</id>
    <published>2019-11-07T07:43:14.000Z</published>
    <updated>2019-11-07T08:29:53.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><a id="more"></a><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。&lt;/p&gt;
&lt;p&gt;要求：额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>之字形打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/05/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/05/算法题-之字形打印矩阵/</id>
    <published>2019-11-05T07:43:50.000Z</published>
    <updated>2019-11-07T10:51:28.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：</p><ul><li>1</li><li>2 5</li><li>9 6 3</li><li>4 7 10 13</li><li>14 11 8</li><li>12 15</li><li>16</li></ul><a id="more"></a><p>要求：额外空间复杂度为O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角</li><li>指针A、B每次同时移动一格，移动规则为：<ul><li>指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动</li><li>指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动</li></ul></li><li>在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印)</li><li>最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之字型打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] indexA = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] indexB = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAToB = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            printStraightLine(matrix,indexA,indexB,isAToB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>) &amp;&amp; indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123; <span class="comment">//终点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新A、B坐标</span></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexA[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexA[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexB[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexB[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isAToB = !isAToB;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印点A~B这条线的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStraightLine</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] indexA, <span class="keyword">int</span>[] indexB, <span class="keyword">boolean</span> isAToB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (indexA[<span class="number">0</span>] == indexB[<span class="number">0</span>] &amp;&amp; indexA[<span class="number">1</span>] == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.println(matrix[indexA[<span class="number">0</span>]][indexA[<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能改变数组中的值,用变量代替</span></span><br><span class="line">        <span class="keyword">int</span> x = isAToB ? indexA[<span class="number">0</span>] : indexB[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = isAToB ? indexA[<span class="number">1</span>] : indexB[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isAToB) &#123; <span class="comment">// 从A打印到B</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == indexB[<span class="number">0</span>] &amp;&amp; y == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从B打印到A</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (indexA[<span class="number">0</span>] == x &amp;&amp; indexA[<span class="number">1</span>] == y) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ZigZagPrintMatrix.zigZagPrintMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/11/05/M9pE11.png" alt="M9pE11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2 5&lt;/li&gt;
&lt;li&gt;9 6 3&lt;/li&gt;
&lt;li&gt;4 7 10 13&lt;/li&gt;
&lt;li&gt;14 11 8&lt;/li&gt;
&lt;li&gt;12 15&lt;/li&gt;
&lt;li&gt;16&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习笔记</title>
    <link href="http://blog.cairui99.cn/2019/11/01/go-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.cairui99.cn/2019/11/01/go-go语言学习笔记/</id>
    <published>2019-11-01T06:04:02.000Z</published>
    <updated>2019-11-20T12:10:00.897Z</updated>
    
    <content type="html"><![CDATA[<center>从零开始，持续更新</center><p><img src="https://s2.ax1x.com/2019/11/01/K7h5QA.png" alt="K7h5QA.png"></p><a id="more"></a><p>参考书籍：<strong>《Go程序设计语言》</strong></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="前往官网下载源码"><a href="#前往官网下载源码" class="headerlink" title="前往官网下载源码"></a>前往官网下载源码</h3><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">点击此处官网</a>(可能需要翻墙)</p><p>根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的</p><p><a href="https://imgchr.com/i/K7XWYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7XWYn.md.png" alt="K7XWYn.md.png"></a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar  -zxvf  go1.13.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建workspace</span><br><span class="line">$ mkdir -p workspace/src</span><br><span class="line"></span><br><span class="line">2.配置环境变量</span><br><span class="line">$ vi ~/.bashrc</span><br><span class="line"></span><br><span class="line">将以下配置添加进bashrc中</span><br><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export GOPATH=$HOME/workspace</span><br><span class="line">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH</span><br><span class="line"></span><br><span class="line">使配置生效</span><br><span class="line">$ source ~/.bashrc</span><br><span class="line"></span><br><span class="line">3.验证是否成功</span><br><span class="line">$ go version</span><br></pre></td></tr></table></figure><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>创建一个 HelloWorld.go 文件 <strong>(注意创建在你的GOPATH目录下)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run HelloWorld.go</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build HelloWorld.go</span><br></pre></td></tr></table></figure><p>此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./HelloWorld</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>下面说一下代码：<br>Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。</p><p>每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。</p><p>package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。</p><p>在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。</p><p>Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句</p><p>Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。</p><h3 id="输出命令行参数"><a href="#输出命令行参数" class="headerlink" title="输出命令行参数"></a>输出命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s, sep <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">s += sep + os.Args[i]</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。</p><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo.go 1 3 -X ?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 3 -X ?</span><br></pre></td></tr></table></figure><p>使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串</p><p>循环变量i在for循环的开始处声明，使用 <strong>:=</strong> 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。</p><p>注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且<strong>左大括号不能独立成行</strong>，必须和前置语句在同一行</p><p>for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中三个部分都是可以省略的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环 while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环这种形式可以通过如break、return等语句进行终止</p><p>还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s, sep := <span class="string">""</span>, <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">s += sep + arg</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义简洁方便，通常在函数内部使用，不适用于包级别的变量</span></span><br><span class="line">s := <span class="string">""</span></span><br><span class="line"><span class="comment">//使用默认初始化值时的定义方式</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="comment">//很少使用，除非定义多个变量时使用</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">""</span></span><br><span class="line"><span class="comment">//在类型不一致时，强调类型使用</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 <strong>_</strong> 这个变量，<strong>_</strong> 在go语言中表示 <strong>空标识符</strong> ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。</p><p>如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果不关心格式或者只是调试程序时，可以直接使用Println：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果和预期很像，只是两边有括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo4.go 1 2 s d ?</span><br><span class="line"></span><br><span class="line">[1 2 s d ?]</span><br></pre></td></tr></table></figure><h3 id="找出重复行"><a href="#找出重复行" class="headerlink" title="找出重复行"></a>找出重复行</h3><h4 id="从控制台输入"><a href="#从控制台输入" class="headerlink" title="从控制台输入"></a>从控制台输入</h4><p>下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>,n,line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup1.go</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">21</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。</p><p>接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。</p><p>在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。</p><p>为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。</p><p>下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。</p><p>例如程序中的 <strong>“%d\t%s\n”</strong>含义为： <strong>%d</strong> 为将一个整数格式化为十进制形式、 <strong>\t</strong> 制表符、 <strong>%s</strong> 把参数输入为字符串、 <strong>\n</strong> 换行符。</p><p>下面给出一些常用的Printf转义字符，Go程序员将其称为verb：</p><table><thead><tr><th align="center">verb</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">十进制整数</td></tr><tr><td align="center">%x, %o, %b</td><td align="center">十六进制、八进制、二进制整数</td></tr><tr><td align="center">%f, %g, %e</td><td align="center">浮点型</td></tr><tr><td align="center">%t</td><td align="center">布尔型</td></tr><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%q</td><td align="center">带引号的字符串(“abc”或者’c’)</td></tr><tr><td align="center">%v</td><td align="center">内置格式的任何值</td></tr><tr><td align="center">%T</td><td align="center">任何值的类型</td></tr><tr><td align="center">%%</td><td align="center">百分号本身</td></tr></tbody></table><h4 id="流式读取文件"><a href="#流式读取文件" class="headerlink" title="流式读取文件"></a>流式读取文件</h4><p>下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">files := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">countLines(os.Stdin, counts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := os.Open(arg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">countLines(f, counts)</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(f)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for test：</p><p>首先创建一个测试文件，名为test.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup2.go test.txt</span><br><span class="line"></span><br><span class="line">3123</span><br><span class="line">212</span><br></pre></td></tr></table></figure><p>os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。</p><p>可以看出 <strong>在go中函数的声明次序是任意的，包括main函数。</strong></p><p>在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。</p><h4 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h4><p>上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。</p><p>下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">data, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup3: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="keyword">string</span>(data), <span class="string">"\n"</span>) &#123;</span><br><span class="line">counts[line]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行方式与结果同dup2.go</p><p>ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。</p><h3 id="获取URL的内容"><a href="#获取URL的内容" class="headerlink" title="获取URL的内容"></a>获取URL的内容</h3><p>程序fetch通过命令行来读取url，通过net包下面的方法来获取指定url的内容，然后不加解析地输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: %v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: reading %s: %v\n"</span>, url, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序使用net/http包的http.Get函数来产生一个HTTP请求，在没有出错的情况下返回结果会保存到resp中，其中resp.Body为一个可读数据流，通过ioutil.ReadAll来读取整个响应结果并存入b，随后关闭Body数据流来避免起源泄露。</p><h3 id="并发获取多个URL的内容"><a href="#并发获取多个URL的内容" class="headerlink" title="并发获取多个URL的内容"></a>并发获取多个URL的内容</h3><p>Go语言的特点之一就是支持并发编程，我们通过下面程序的程序简单了解下go的主要并发机制、goroutine和通道(channel)。<br>下面程序用来从命令行读取很多个URL，并发的获取这些URL的内容，并返回获取每个URL的时间与程序执行的总时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprint(err) <span class="comment">//发送到通道ch</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"while reading %s: %v"</span>, url, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">secs := time.Since(start).Seconds()</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"%.2fs %7d %s"</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="keyword">go</span> fetch(url, ch) <span class="comment">//启动一个goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">//从通道ch接收</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%.2fs elapsed\n"</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run fetchall.go http://www.rong360.com http://www.jd.com http://www.weibo.com http://www.baidu.com</span><br><span class="line"></span><br><span class="line">0.03s  156218 http://www.baidu.com</span><br><span class="line">0.14s  106674 http://www.jd.com</span><br><span class="line">0.15s     611 http://www.weibo.com</span><br><span class="line">0.17s  110858 http://www.rong360.com</span><br><span class="line">0.17s  elapsed</span><br></pre></td></tr></table></figure><p>goroutin是一个并发执行的函数，本质是协程。main函数就是在一个goroutine中执行的，在main中可以使用 <strong>go</strong> 关键字来创建额外的goroutine。goroutine之前可以使用channel来进行通信或者说是数据共享。</p><p>go语言中使用 <strong>chan</strong> 关键字来声明channel，在上面的程序中使用了make创建了一个字符串通道ch，接下来在for循环中每次循环都创建一个新的goroutine，可以实现异步的调用fetch()方法来获取URL内容，在fetch中将读取到的信息传入channel中，在main函数的第二个for循环中依次接收。</p><p>持续更新中…</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;从零开始，持续更新&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/01/K7h5QA.png&quot; alt=&quot;K7h5QA.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.cairui99.cn/categories/Go/"/>
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/Go/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="go语言基础" scheme="http://blog.cairui99.cn/tags/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-最少知识原则</title>
    <link href="http://blog.cairui99.cn/2019/11/01/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E6%B3%95%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/11/01/设计原则-最少知识法则/</id>
    <published>2019-11-01T03:31:11.000Z</published>
    <updated>2019-11-01T06:00:02.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最少知识法则也称为迪米特原则，定义为：<strong>一个对象应该对其他对象有最少的了解。</strong></p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>迪米特法则对实现类的低耦合提出了明确的要求，规则如下：</p><h5 id="1-只和直接的朋友通信"><a href="#1-只和直接的朋友通信" class="headerlink" title="1.只和直接的朋友通信"></a>1.只和直接的朋友通信</h5><p>直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。</p><p>类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。</p><h5 id="2-朋友间也需要有距离"><a href="#2-朋友间也需要有距离" class="headerlink" title="2.朋友间也需要有距离"></a>2.朋友间也需要有距离</h5><p>一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。</p><h5 id="3-是自己的就是自己的"><a href="#3-是自己的就是自己的" class="headerlink" title="3.是自己的就是自己的"></a>3.是自己的就是自己的</h5><p>如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;最少知识法则也称为迪米特原则，定义为：&lt;strong&gt;一个对象应该对其他对象有最少的了解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-接口隔离原则</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/10/30/设计原则-接口隔离原则/</id>
    <published>2019-10-30T07:25:09.000Z</published>
    <updated>2019-10-31T12:16:35.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Clients should not be forced to depend upon interfaces that they don’t use.</strong></p><p><strong>“客户端不应该依赖它不需要的接口”</strong>，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。</p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实现接口时尽量做到以下规范：</p><ul><li>接口要做到高内聚：尽量少的公布public方法，降低变更的风险</li><li>定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法</li><li>有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口</li><li>已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理</li><li>接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Clients should not be forced to depend upon interfaces that they don’t use.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户端不应该依赖它不需要的接口”&lt;/strong&gt;，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E7%AE%97%E6%B3%95%E9%A2%98-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/10/30/算法题-顺时针打印矩阵/</id>
    <published>2019-10-30T06:11:01.000Z</published>
    <updated>2019-11-07T10:55:10.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下：</p><ul><li>在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1)</li><li>完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标</li><li>重复执行上述步骤，直至得到的坐标无法构成矩阵为止</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwisePrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (B[<span class="number">0</span>] &gt;= A[<span class="number">0</span>] &amp;&amp; B[<span class="number">1</span>] &gt;= A[<span class="number">1</span>]) &#123;</span><br><span class="line">            print(matrix,A[<span class="number">0</span>]++,A[<span class="number">1</span>]++,B[<span class="number">0</span>]--,B[<span class="number">1</span>]--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角坐标(a,b)</span></span><br><span class="line"><span class="comment">     * 右下角坐标(c,d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (a, b) -&gt; (a, d)</span></span><br><span class="line">        <span class="keyword">int</span> index = b;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; d) &#123;</span><br><span class="line">            System.out.print(arr[a][index++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (a, d) -&gt; (c, d)</span></span><br><span class="line">        index = a;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; c) &#123;</span><br><span class="line">            System.out.print(arr[index++][d] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, d) -&gt; (c, b)</span></span><br><span class="line">        index = d;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; b) &#123;</span><br><span class="line">            System.out.print(arr[c][index--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, b) -&gt; (a, b)</span></span><br><span class="line">        index = c;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; a) &#123;</span><br><span class="line">            System.out.print(arr[index--][b]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ClockwisePrintMatrix.printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>栈实现队列&amp;队列实现栈</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-栈实现队列-队列实现栈/</id>
    <published>2019-10-28T07:02:20.000Z</published>
    <updated>2019-10-30T05:45:28.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>要求使用栈实现队列的如下方法：</p><ul><li>offer(入队)</li><li>poll(出队)</li><li>peek(查看栈顶元素)</li></ul><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个栈，push栈和pop栈</li><li>offer()：push栈正常入栈</li><li>poll(): 弹出pop栈的栈顶元素并返回 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li><li>peek(): 返回pop栈的栈顶元素 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; push = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pop  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        push.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!push.isEmpty()) &#123;</span><br><span class="line">            pop.push(push.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列实现栈结构"><a href="#队列实现栈结构" class="headerlink" title="队列实现栈结构"></a>队列实现栈结构</h3><p>要求使用队列实现栈结构的如下方法：</p><ul><li>push(入栈)</li><li>pop(出栈)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个队列，data队列和help队列</li><li>push(): data队列正常入队</li><li>pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回</li><li>peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列实现栈结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBecomeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        data.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> help.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = data.remove();</span><br><span class="line">        help.offer(ret);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈实现队列&quot;&gt;&lt;a href=&quot;#栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;栈实现队列&quot;&gt;&lt;/a&gt;栈实现队列&lt;/h3&gt;&lt;p&gt;要求使用栈实现队列的如下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offer(入队)&lt;/li&gt;
&lt;li&gt;poll(出队)&lt;/li&gt;
&lt;li&gt;peek(查看栈顶元素)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Min栈的实现</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-Min%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-Min栈的实现/</id>
    <published>2019-10-28T06:46:05.000Z</published>
    <updated>2019-10-30T06:21:34.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：</p><ul><li>1．pop、push、peek、getMin操作的时间复杂度都是O(1)。</li><li>2．设计的栈类型可以使用现成的栈结构。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>内部创建两个栈，data栈和min栈</li><li>元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是<strong>(min栈的栈顶存的永远是data栈中的最小值)</strong></li><li>出栈时data栈和min栈一起正常出栈</li><li>getMin()方法只需要返回min栈的栈顶元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span></span><br><span class="line"><span class="comment"> * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。</span></span><br><span class="line"><span class="comment"> *         2．设计的栈类型可以使用现成的栈结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        data.push(num);</span><br><span class="line">        min.push((min.peek() &gt; num) ? num : min.peek());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.pop();</span><br><span class="line">        <span class="keyword">return</span> data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1．pop、push、peek、getMin操作的时间复杂度都是O(1)。&lt;/li&gt;
&lt;li&gt;2．设计的栈类型可以使用现成的栈结构。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>更快的获取中位数</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-更快的获取中位数/</id>
    <published>2019-10-28T05:56:44.000Z</published>
    <updated>2019-10-30T06:20:33.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。</p><p>此时收集数的操作是 <strong>O(1)</strong>，获取中位数的操作是 <strong>O(n*logn)</strong></p><p>如果接口被频繁调用，排序的代价就太高了，下面利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来进行优化：</p><ul><li>创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下：<ul><li>假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中</li><li>两个堆中元素数量保持平衡，差值不大于1</li></ul></li><li>如何获取中位数：<ul><li>如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素</li><li>如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值</li></ul></li></ul><p> 此时收集数的操作需要进行一次heapInsert 代价是 <strong>O(logn)</strong>，而获取中位数的操作变为了 <strong>O(1)</strong>，效率得到了很大的提升 <strong>O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianQuick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bigSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smallSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberInsert</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.automaticCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &gt; bigHeap[<span class="number">0</span>]) &#123; <span class="comment">//较大的数进小根堆</span></span><br><span class="line">            smallHeap[smallSize++] = number;</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//较小的数进大根堆</span></span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//平衡堆中元素数量，差值不等大于1</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize - smallSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,<span class="number">0</span>);</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize - bigSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,<span class="number">1</span>);</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(bigHeap[<span class="number">0</span>] + smallHeap[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bigSize &gt; smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> smallHeap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">automaticCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.bigHeap.length+<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.smallHeap.length+<span class="number">100</span>];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.bigHeap, <span class="number">0</span>, bigHeap, <span class="number">0</span>, bigSize);</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.smallHeap, <span class="number">0</span>, smallHeap, <span class="number">0</span>, smallSize);</span><br><span class="line">        <span class="keyword">this</span>.bigHeap = bigHeap;</span><br><span class="line">        <span class="keyword">this</span>.smallHeap = smallHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">Heap类的相关代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数组实现队列</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-数组实现队列/</id>
    <published>2019-10-28T03:39:43.000Z</published>
    <updated>2019-10-30T06:20:58.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>使用数组实现队列结构，实现方法：</p><ul><li>add(向队尾添加元素)</li><li>poll(返回队首元素，并移除)</li><li>peek(返回队首元素)</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针start、end和一个变量size，初始值都为0<ul><li>start表示队首元素的位置</li><li>end表示下一个元素入队时要添加的位置</li><li>size表示队列大小</li><li><strong>start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组</strong></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个元素到队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = num;</span><br><span class="line">        end = (end == arr.length - <span class="number">1</span>) ? <span class="number">0</span> : ++end;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素，并移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> result = arr[start];</span><br><span class="line">        start = start == arr.length - <span class="number">1</span> ? <span class="number">0</span> : ++start;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//预计输出：1 1 2 3 3</span></span><br><span class="line">        ArrayBecomeQueue queue = <span class="keyword">new</span> ArrayBecomeQueue(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        queue.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;使用数组实现队列结构，实现方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add(向队尾添加元素)&lt;/li&gt;
&lt;li&gt;poll(返回队首元素，并移除)&lt;/li&gt;
&lt;li&gt;peek(返回队首元素)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>相邻两数最大差值</title>
    <link href="http://blog.cairui99.cn/2019/10/22/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%9B%B8%E9%82%BB%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/"/>
    <id>http://blog.cairui99.cn/2019/10/22/算法题-相邻两数最大差值/</id>
    <published>2019-10-22T06:08:22.000Z</published>
    <updated>2019-10-24T06:02:09.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)</p><a id="more"></a><p>举个例子：</p><ul><li>给定数组：{4,5,1,2}</li><li>排好序后的数组是：{1,2,4,5}</li><li>相邻两数的差值分别为：1,2,1</li><li>需要返回最大差值，所以最终结果就是2</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先把数组排序，再遍历数组求出所有差值，返回最大的那一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">            result = border;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用</strong></p><h3 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h3><p>这里利用了桶的概念，但没有进行桶排序</p><p>思路：</p><ul><li>假设数组中有N个数，创建N+1个桶</li><li>遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶</li><li>然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中   (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：<strong>1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5</strong>)</li></ul><p>这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 <strong>产生最大差值的两个相邻数绝对不会来自于相同桶</strong></p><p>有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了</p><p>所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 <strong>相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorderCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBorderCount</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤非法数据</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶</span></span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录桶是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span>[] existNumber = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值和最大值相等：返回0</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr);</span><br><span class="line">        <span class="keyword">int</span> minNum = criticalMap.get(<span class="string">"Min"</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = criticalMap.get(<span class="string">"Max"</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNum == maxNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值放在第一个桶，最大值放在最后一个桶</span></span><br><span class="line">        min[<span class="number">0</span>] = minNum;</span><br><span class="line">        max[<span class="number">0</span>] = minNum;</span><br><span class="line">        existNumber[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        min[min.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        max[max.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        existNumber[existNumber.length-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个桶中存放的数值范围</span></span><br><span class="line">        <span class="keyword">double</span> scope = (<span class="keyword">double</span>) (min[min.length-<span class="number">1</span>] - min[<span class="number">0</span>])/min.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == min[<span class="number">0</span>] || num == max[max.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该元素应该存放的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.ceil((num - min[<span class="number">0</span>]) / scope)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existNumber[index]) &#123;</span><br><span class="line">                min[index] = num;</span><br><span class="line">                max[index] = num;</span><br><span class="line">                existNumber[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; max[index]) &#123;</span><br><span class="line">                    max[index] = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min[index]) &#123;</span><br><span class="line">                    min[index] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录非空桶的坐标</span></span><br><span class="line">        List&lt;Integer&gt; existIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existNumber.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existNumber[i]) &#123;</span><br><span class="line">                existIndex.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最大差值</span></span><br><span class="line">        <span class="keyword">int</span> maxBorderCount = max[<span class="number">0</span>] - min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existIndex.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = min[existIndex.get(i+<span class="number">1</span>)] - max[existIndex.get(i)];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; maxBorderCount) &#123;</span><br><span class="line">                maxBorderCount = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxBorderCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值和最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; <span class="title">getMaxAndMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">"Max"</span>,max);</span><br><span class="line">        result.put(<span class="string">"Min"</span>,min);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">                result = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; testCount;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = ArrayUtil.getArray(<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span> border1 = BorderCount.getBorderCount(arr1);</span><br><span class="line">            <span class="keyword">int</span> border2 = BorderCount.testMethod(arr2);</span><br><span class="line">            <span class="keyword">if</span> (border1 != border2) &#123;</span><br><span class="line">                is_success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_success) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://blog.cairui99.cn/2019/10/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/10/18/排序算法-堆排序/</id>
    <published>2019-10-18T02:38:03.000Z</published>
    <updated>2019-10-28T03:31:12.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来设计的一种排序算法。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将整个数组构建成大根堆</li><li>依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置<ul><li>在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组</li></ul></li><li>当堆中所有元素弹出完毕，此时数组已全部有序</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Heap.buildBigHeap(arr,arr.length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            Heap.heapPop(arr,arr.length-i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        ArrayUtil.swap(arr,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        heapFalling(arr,length-<span class="number">2</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向堆中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组中(0 ~ index-1)为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ArrayUtil.swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;</p><p>最差时间复杂度: <strong>O(n*logn)</strong>;</p><p>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(1)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>不稳定</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h3&gt;&lt;p&gt;堆排序是利用&lt;a href=&quot;https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/&quot;&gt;堆结构&lt;/a&gt;的特点来设计的一种排序算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://blog.cairui99.cn/2019/10/16/数据结构-堆/</id>
    <published>2019-10-16T09:34:42.000Z</published>
    <updated>2019-10-18T06:33:45.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。</p><a id="more"></a><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>首先堆的结构是一颗 <strong>完全二叉树</strong></p><ul><li><strong>完全二叉树</strong>：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图：<br><img src="https://s2.ax1x.com/2019/10/17/KkXhRO.jpg" alt="KkXhRO.jpg"></li></ul><p>在程序中，我们可以使用数组结构来抽象出一颗完全二叉树：</p><ul><li>数组中的0位置代表根节点</li><li>假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为：<ul><li>左孩子：<strong>2*i+1</strong></li><li>右孩子：<strong>2*i+2</strong></li></ul></li><li>假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为：<ul><li>父节点：<strong>(i-1)/2</strong></li><li>根节点的父节点是自己：(0-1)/2 = 0</li></ul></li></ul><p>使用上面的抽象规则，我们就可以把 <strong>任意数组抽象为一颗完全二叉树。</strong></p><h4 id="构建推结构"><a href="#构建推结构" class="headerlink" title="构建推结构"></a>构建推结构</h4><p>堆分为两种：</p><ul><li>大根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最大值</strong> 都是头部</li><li>小根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最小值</strong> 都是头部</li></ul><p>以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？</p><p><strong>步骤：</strong></p><ul><li>首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中</li><li>后面通过遍历数组，将每个元素依次进堆</li><li>进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止</li><li>数组中所有元素进堆完毕，则大根堆构建完成</li></ul><p>时间复杂度：O(n)</p><h4 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a>弹出堆顶元素</h4><p>在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。</p><p><strong>步骤：</strong></p><ul><li>将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中</li><li>对此时的堆顶元素进行<strong>下沉</strong>操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉)<ul><li>下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子<strong>(如果没有右孩子就不比较，但一定有左孩子)</strong> 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉</li></ul></li><li>堆顶元素下沉完毕后，此时又重新构建好了堆结构</li></ul><p>时间复杂度：O(logn)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        swap(arr,<span class="number">0</span>,length);</span><br><span class="line">        heapFalling(arr,length-<span class="number">1</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Heap.buildBigHeap(arr,<span class="number">1</span>);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">        <span class="keyword">int</span> min = Heap.heapPop(arr,arr.length-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h3&gt;&lt;p&gt;堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://blog.cairui99.cn/2019/10/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/10/12/排序算法-快速排序/</id>
    <published>2019-10-12T07:04:19.000Z</published>
    <updated>2019-10-28T08:28:55.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>选取数组中的中的一个数作为基准数，然后将数组调整为两部分：左部分的数全部小于等于基准数、右部分的数全部大于基准数(子序列中内部不需要有序)</li><li>递归的对数组两个部分继续执行上述步骤，直至数组有序</li></ul><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><ul><li>将数组划分为三个部分，小于、等于、大于区域 (<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">具体实现</a>)</li><li>这时等于区域的数就已经位于理想的位置，因此只需要递归小于区域和大于区域 <strong>(在有很多重复数字的情况下效率提升会很明显)</strong></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = grouping(arr,left,right);</span><br><span class="line">        <span class="comment">//递归小于区域和大于区域</span></span><br><span class="line">        quickSort(arr,left,index[<span class="number">0</span>]);</span><br><span class="line">        quickSort(arr,index[<span class="number">1</span>],right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分出小于、等于、大于区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] grouping(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">int</span> indexFront = left;</span><br><span class="line">        <span class="keyword">int</span> indexMid = left;</span><br><span class="line">        <span class="keyword">int</span> indexRear = right;</span><br><span class="line">        <span class="keyword">int</span> num = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">                swap(arr, indexMid, indexFront);</span><br><span class="line">                <span class="keyword">if</span> (indexMid + <span class="number">1</span> &gt; indexRear) <span class="keyword">break</span>;</span><br><span class="line">                indexMid++;</span><br><span class="line">                indexFront++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMid + <span class="number">1</span> &gt; indexRear) <span class="keyword">break</span>;</span><br><span class="line">                indexMid++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMid &gt; indexRear - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                swap(arr, indexMid, indexRear);</span><br><span class="line">                indexRear--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回临界值坐标</span></span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        index[<span class="number">0</span>] = (arr[indexFront] == num) ? (indexFront - <span class="number">1</span>) : indexFront;</span><br><span class="line">        index[<span class="number">1</span>] = (arr[indexRear] == num) ? (indexRear + <span class="number">1</span>) : indexRear;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">        arr[x] = arr[y];</span><br><span class="line">        arr[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;</p><p>最差时间复杂度: <strong>O(n2)</strong>; (快排在最差情况下会退化为冒泡)</p><p>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(logn)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>不稳定</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-向git推送更新失败</title>
    <link href="http://blog.cairui99.cn/2019/10/11/Hexo-%E5%90%91git%E6%8E%A8%E9%80%81%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5/"/>
    <id>http://blog.cairui99.cn/2019/10/11/Hexo-向git推送更新失败/</id>
    <published>2019-10-11T09:31:12.000Z</published>
    <updated>2019-10-12T06:29:04.616Z</updated>
    
    <content type="html"><![CDATA[<p>今天在更新博客时发生了 <strong>hexo d</strong> 时推送失败的情况。</p><p>报错信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection reset by 52.74.223.119 port 22</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><a id="more"></a><p>这表示git客户端无法连接至github，原因大概是防火墙禁止了ip为52.74.223.119端口22的ssh连接</p><p><strong>解决方法：</strong></p><p><strong>(1)</strong> 我的解决的方法是切换网络，将wifi切成手机热点就提交成功了。</p><p><strong>(2)</strong> 如果条件不允许或者切换网络依旧不成功，需要手动将防火墙中的 <strong>22端口设置为允许连接</strong></p><p><a href="https://www.cnblogs.com/Diamond-sjh/p/11352156.html" target="_blank" rel="noopener">具体操作请参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在更新博客时发生了 &lt;strong&gt;hexo d&lt;/strong&gt; 时推送失败的情况。&lt;/p&gt;
&lt;p&gt;报错信息:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Connection reset by 52.74.223.119 port 22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal: Could not read from remote repository.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="问题整理" scheme="http://blog.cairui99.cn/categories/%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Hexo" scheme="http://blog.cairui99.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题</title>
    <link href="http://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/10/11/算法题-荷兰国旗问题/</id>
    <published>2019-10-11T06:44:37.000Z</published>
    <updated>2019-10-30T06:20:48.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。</p><a id="more"></a><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路 时间复杂度(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badMethod</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;num) &#123;</span><br><span class="line">            alist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n==num) &#123;</span><br><span class="line">            blist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clist.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index = setArray(arr,index,alist);</span><br><span class="line">    index = setArray(arr,index,blist);</span><br><span class="line">    setArray(arr,index,clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, @NotNull List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度改进为O(1)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlag</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">            swap(arr,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用三个指针，交换全部在数组内部进行，三个指针的含义为：</p><ul><li>indexFront : 指针前面的所有数都满足小于num</li><li>indexMid : 指针前面所有的数都满足小于等于num</li><li>indexRear : 指针后面所有的数都满足大于num</li></ul><p>终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>IDEA-批量修改变量名</title>
    <link href="http://blog.cairui99.cn/2019/10/11/IDEA-%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%90%8D/"/>
    <id>http://blog.cairui99.cn/2019/10/11/IDEA-批量修改变量名/</id>
    <published>2019-10-11T05:44:15.000Z</published>
    <updated>2019-10-11T05:49:08.470Z</updated>
    
    <content type="html"><![CDATA[<p>双击选中修改对象后： <strong>Shift+F6</strong></p><p>变量名填写完成后按回车执行修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;双击选中修改对象后： &lt;strong&gt;Shift+F6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量名填写完成后按回车执行修改&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="IDEA快捷键" scheme="http://blog.cairui99.cn/tags/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
</feed>
