<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>人类真是毫无长进的生物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2020-06-04T08:07:57.773Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法题题解整理</title>
    <link href="http://blog.cairui99.cn/2020/06/04/%E7%AE%97%E6%B3%95%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86/"/>
    <id>http://blog.cairui99.cn/2020/06/04/算法题题解整理/</id>
    <published>2020-06-04T07:53:27.000Z</published>
    <updated>2020-06-04T08:07:57.773Z</updated>
    
    <content type="html"><![CDATA[<p>一些整理了出了题解的常见算法题，代码都是自己写的</p><a id="more"></a><h2 id="复制含有随机指针的链表"><a href="#复制含有随机指针的链表" class="headerlink" title="复制含有随机指针的链表"></a>复制含有随机指针的链表</h2><p>Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandNode next;</span><br><span class="line">    <span class="keyword">public</span> RandNode rand;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。</p><p><strong>进阶：</strong> 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。</p><h3 id="HashMap实现"><a href="#HashMap实现" class="headerlink" title="HashMap实现"></a>HashMap实现</h3><p>使用辅助结构HashMap实现：</p><ul><li>创建一个HashMap，key、value都是RandNode类型</li><li>遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中</li><li>遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点</li><li>重新遍历原链表，将map中所有的value的next、rand指针进行连接</li><li>返回复制后链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">hashMapMethod</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;RandNode, RandNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        map.put(node, copy_node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = map.get(node);</span><br><span class="line">        copy_node.next = map.get(node.next);</span><br><span class="line">        copy_node.rand = map.get(node.rand);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用有限变量实现"><a href="#使用有限变量实现" class="headerlink" title="使用有限变量实现"></a>使用有限变量实现</h3><p>借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表：</p><ul><li>遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null)</li><li>此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点</li><li>下面遍历链表，将所有复制节点的rand指针指向正确的位置</li><li>最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用有限的变量实现 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">randPointNode</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点连到对应原节点后面</span></span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        copy_node.next = node.next;</span><br><span class="line">        node.next = copy_node;</span><br><span class="line">        node = copy_node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置复制节点的rand指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        copy_node.rand = node.rand != <span class="keyword">null</span> ? node.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        node = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点分离出来</span></span><br><span class="line">    RandNode result = head.next;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (copy_node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = copy_node.next;</span><br><span class="line">            copy_node.next = copy_node.next.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            copy_node.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更快的获取中位数"><a href="#更快的获取中位数" class="headerlink" title="更快的获取中位数"></a>更快的获取中位数</h2><p>一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。</p><p>此时收集数的操作是 <strong>O(1)</strong>，获取中位数的操作是 <strong>O(n*logn)</strong></p><p>如果接口被频繁调用，排序的代价就太高了，下面利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来进行优化：</p><ul><li>创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下：<ul><li>假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中</li><li>两个堆中元素数量保持平衡，差值不大于1</li></ul></li><li>如何获取中位数：<ul><li>如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素</li><li>如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值</li></ul></li></ul><p> 此时收集数的操作需要进行一次heapInsert 代价是 <strong>O(logn)</strong>，而获取中位数的操作变为了 <strong>O(1)</strong>，效率得到了很大的提升 <strong>O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianQuick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bigSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smallSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberInsert</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.automaticCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &gt; bigHeap[<span class="number">0</span>]) &#123; <span class="comment">//较大的数进小根堆</span></span><br><span class="line">            smallHeap[smallSize++] = number;</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//较小的数进大根堆</span></span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//平衡堆中元素数量，差值不等大于1</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize - smallSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,<span class="number">0</span>);</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize - bigSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,<span class="number">1</span>);</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(bigHeap[<span class="number">0</span>] + smallHeap[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bigSize &gt; smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> smallHeap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">automaticCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.bigHeap.length+<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.smallHeap.length+<span class="number">100</span>];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.bigHeap, <span class="number">0</span>, bigHeap, <span class="number">0</span>, bigSize);</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.smallHeap, <span class="number">0</span>, smallHeap, <span class="number">0</span>, smallSize);</span><br><span class="line">        <span class="keyword">this</span>.bigHeap = bigHeap;</span><br><span class="line">        <span class="keyword">this</span>.smallHeap = smallHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">Heap类的相关代码</a></p><h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。</p><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路 时间复杂度(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badMethod</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;num) &#123;</span><br><span class="line">            alist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n==num) &#123;</span><br><span class="line">            blist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clist.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index = setArray(arr,index,alist);</span><br><span class="line">    index = setArray(arr,index,blist);</span><br><span class="line">    setArray(arr,index,clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, @NotNull List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度改进为O(1)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlag</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">            swap(arr,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用三个指针，交换全部在数组内部进行，三个指针的含义为：</p><ul><li>indexFront : 指针前面的所有数都满足小于num</li><li>indexMid : 指针前面所有的数都满足小于等于num</li><li>indexRear : 指针后面所有的数都满足大于num</li></ul><p>终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置</p><h2 id="荷兰国旗问题-单向链表版"><a href="#荷兰国旗问题-单向链表版" class="headerlink" title="荷兰国旗问题-单向链表版"></a>荷兰国旗问题-单向链表版</h2><p>将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。</p><p>进阶：左、中、右三个部分内部需要与原链表顺序一致</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用辅助数组实现：</p><ul><li>创建一个辅助数组，遍历链表将节点放入数组中</li><li>在数组中调整元素的位置，具体操作可见<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">荷兰国旗问题</a></li><li>在数组中调整好顺序后再将值赋给原链表</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用辅助数组</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(indexMid) &lt; num) &#123;</span><br><span class="line">            swap(list,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(indexMid) == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(list,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        node.value = integer;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = list.get(x);</span><br><span class="line">    list.set(x, list.get(y));</span><br><span class="line">    list.set(y, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作：</p><ul><li>遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点</li><li>将三条子链表头尾连接，变为一条完整的链表返回即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进阶版</span></span><br><span class="line"><span class="comment"> * 保证稳定性，同时空间复杂度达到O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlagListNode</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode less_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode less_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                less_head = head;</span><br><span class="line">                less_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                less_tail.next = head;</span><br><span class="line">                less_tail = less_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eq_head = head;</span><br><span class="line">                eq_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eq_tail.next = head;</span><br><span class="line">                eq_tail = eq_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (more_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                more_head = head;</span><br><span class="line">                more_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                more_tail.next = head;</span><br><span class="line">                more_tail = more_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接小于、等于、大于部分</span></span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (less_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = less_head;</span><br><span class="line">        tail = less_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eq_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = eq_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = eq_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = eq_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = more_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = more_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = more_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部至空，防止链表成环</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="keyword">null</span> &amp;&amp; tail.next != <span class="keyword">null</span>) tail.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两条单链表相交的问题"><a href="#两条单链表相交的问题" class="headerlink" title="两条单链表相交的问题"></a>两条单链表相交的问题</h2><p>给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先判断两条单链表是否成环，如果有环则获取到入环节点，然后分情况讨论：</p><ol><li>两条非环单链表：遍历两条链表获取链表的长度，将较长的那条的头节点向后移动两条链表头部的差值，然后两条单链表从头节点同时向后移动：<ul><li>如果产生交点则两条链表相交，返回该节点</li><li>抵达尾部时都没有产生交点则不相交，返回null</li></ul></li><li>一条单链表成环，一条单链表非环：必无交点</li><li>两条成环单链表：<ul><li>入环节点相同，必相交：将入环节点视为终点，此时两条链表可以视为非环单链表，寻找两条单链表的交点时则可以使用两条非环单链表的判断方法找到交点</li><li>入环节点不同，需要判断是否相交：选择其中一条链表的入环节点开始遍历，如果遍历过程中遇到了另一条链表的入环节点，则两条链表相交；如果遍历一整圈都没有相遇则两条链表无交点</li></ul></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个单链表的头节点,判断是否相交,如果相交返回相交的节点,不相交返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-12-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">isIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode isCyclization1 = isCyclization(head1);</span><br><span class="line">        ListNode isCyclization2 = isCyclization(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCyclization1 == <span class="keyword">null</span> &amp;&amp; isCyclization2 == <span class="keyword">null</span>) &#123; <span class="comment">//两条非环单链表</span></span><br><span class="line">            <span class="keyword">return</span> getIntersect(head1, head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCyclization1 != <span class="keyword">null</span> &amp;&amp; isCyclization2 != <span class="keyword">null</span>) &#123; <span class="comment">//两条成环单链表</span></span><br><span class="line">            <span class="keyword">if</span> (isCyclization1 == isCyclization2) &#123; <span class="comment">//入环节点相同,必相交</span></span><br><span class="line">                ListNode tempNode = isCyclization1.next;</span><br><span class="line">                isCyclization1.next = <span class="keyword">null</span>;</span><br><span class="line">                ListNode resultNode = getIntersect(head1, head2);</span><br><span class="line">                isCyclization1.next = tempNode;</span><br><span class="line">                <span class="keyword">return</span> resultNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//入环节点不同需要判断是否相交</span></span><br><span class="line">                ListNode node = isCyclization1.next;</span><br><span class="line">                <span class="keyword">while</span> (node != isCyclization1) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == isCyclization2) &#123; <span class="comment">//在环中遇到了另一个链表的入环节点,说明两条链表相交</span></span><br><span class="line">                        <span class="keyword">return</span> isCyclization1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表是否成环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入环节点,不成环则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">isCyclization</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用快慢指针判断是否成环</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回入环节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两条非环单链表的交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1Length = getNodeLength(head1);</span><br><span class="line">        <span class="keyword">int</span> node2Length = getNodeLength(head2);</span><br><span class="line">        ListNode longerNode = node1Length &gt; node2Length ? head1 : head2;</span><br><span class="line">        ListNode shortNode  = node1Length &gt; node2Length ? head2 : head1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.abs(node1Length - node2Length); i++) &#123;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (shortNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shortNode == longerNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortNode;</span><br><span class="line">            &#125;</span><br><span class="line">            shortNode  = shortNode.next;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取非环单链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否为回文结构"><a href="#判断链表是否为回文结构" class="headerlink" title="判断链表是否为回文结构"></a>判断链表是否为回文结构</h2><p>给定一个链表的头节点head,请判断该链表是否为回文结构。</p><p>回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)：</p><ul><li>将链表从头到尾依次入栈</li><li>再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等</li><li>如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈结构</span></span><br><span class="line"><span class="comment"> * 额外空间O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">stackMethod</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)：</p><ul><li>使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点</li><li>将链表的后半部分逆序，同时将中间节点指向null</li><li>此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等</li><li>如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论</li><li>将链表调整为最初的状态(如果需要的话)，然后返回结论</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针+逆序链表</span></span><br><span class="line"><span class="comment"> * 额外空间O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="comment">//链表元素的个数是否为单数</span></span><br><span class="line">    <span class="keyword">boolean</span> isSingular = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//寻找链表的中心点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isSingular = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序链表的后半部分</span></span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSingular) &#123;</span><br><span class="line">        node2 = reverseListNode(slow);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        node2 = reverseListNode(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否是回文结构</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    ListNode tailNode = node2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.value != node2.value) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整链表至最初状态</span></span><br><span class="line">    reverseListNode(tailNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode before = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        node.next = before;</span><br><span class="line">        before = node;</span><br><span class="line">        node = next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断k是否在矩阵中"><a href="#判断k是否在矩阵中" class="headerlink" title="判断k是否在矩阵中"></a>判断k是否在矩阵中</h2><p>给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：</p><p><img src="https://s2.ax1x.com/2019/11/12/M3ZfoQ.png" alt="M3ZfoQ.png"></p><p>要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点</li><li>假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素</li><li>跟据该特性，判断指针所在位置的元素和整数k的关系：<ul><li>等于k：返回true</li><li>大于k：指针向左移动，如果移动后超过了矩阵边界返回false</li><li>小于k：指针向下移动，如果移动后超过了矩阵边界返回false</li></ul></li><li>重复执行上述步骤，直至函数return</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的.</span></span><br><span class="line"><span class="comment"> * 实现一个函数,判断K是否在matrix中</span></span><br><span class="line"><span class="comment"> * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMatrixNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] &gt; num) &#123;</span><br><span class="line">                index[<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index[<span class="number">0</span>] &gt;= matrix.length || index[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h2><p>使用数组实现队列结构，实现方法：</p><ul><li>add(向队尾添加元素)</li><li>poll(返回队首元素，并移除)</li><li>peek(返回队首元素)</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针start、end和一个变量size，初始值都为0<ul><li>start表示队首元素的位置</li><li>end表示下一个元素入队时要添加的位置</li><li>size表示队列大小</li><li><strong>start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组</strong></li></ul></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个元素到队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = num;</span><br><span class="line">        end = (end == arr.length - <span class="number">1</span>) ? <span class="number">0</span> : ++end;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素，并移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> result = arr[start];</span><br><span class="line">        start = start == arr.length - <span class="number">1</span> ? <span class="number">0</span> : ++start;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//预计输出：1 1 2 3 3</span></span><br><span class="line">        ArrayBecomeQueue queue = <span class="keyword">new</span> ArrayBecomeQueue(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        queue.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下：</p><ul><li>在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1)</li><li>完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标</li><li>重复执行上述步骤，直至得到的坐标无法构成矩阵为止</li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwisePrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (B[<span class="number">0</span>] &gt;= A[<span class="number">0</span>] &amp;&amp; B[<span class="number">1</span>] &gt;= A[<span class="number">1</span>]) &#123;</span><br><span class="line">            print(matrix,A[<span class="number">0</span>]++,A[<span class="number">1</span>]++,B[<span class="number">0</span>]--,B[<span class="number">1</span>]--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角坐标(a,b)</span></span><br><span class="line"><span class="comment">     * 右下角坐标(c,d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (a, b) -&gt; (a, d)</span></span><br><span class="line">        <span class="keyword">int</span> index = b;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; d) &#123;</span><br><span class="line">            System.out.print(arr[a][index++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (a, d) -&gt; (c, d)</span></span><br><span class="line">        index = a;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; c) &#123;</span><br><span class="line">            System.out.print(arr[index++][d] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, d) -&gt; (c, b)</span></span><br><span class="line">        index = d;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; b) &#123;</span><br><span class="line">            System.out.print(arr[c][index--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, b) -&gt; (a, b)</span></span><br><span class="line">        index = c;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; a) &#123;</span><br><span class="line">            System.out.print(arr[index--][b]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ClockwisePrintMatrix.printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相邻两数最大差值"><a href="#相邻两数最大差值" class="headerlink" title="相邻两数最大差值"></a>相邻两数最大差值</h2><p>给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)</p><p>举个例子：</p><ul><li>给定数组：{4,5,1,2}</li><li>排好序后的数组是：{1,2,4,5}</li><li>相邻两数的差值分别为：1,2,1</li><li>需要返回最大差值，所以最终结果就是2</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先把数组排序，再遍历数组求出所有差值，返回最大的那一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">            result = border;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用</strong></p><h3 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h3><p>这里利用了桶的概念，但没有进行桶排序</p><p>思路：</p><ul><li>假设数组中有N个数，创建N+1个桶</li><li>遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶</li><li>然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中   (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：<strong>1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5</strong>)</li></ul><p>这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 <strong>产生最大差值的两个相邻数绝对不会来自于相同桶</strong></p><p>有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了</p><p>所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 <strong>相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorderCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBorderCount</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤非法数据</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶</span></span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录桶是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span>[] existNumber = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值和最大值相等：返回0</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr);</span><br><span class="line">        <span class="keyword">int</span> minNum = criticalMap.get(<span class="string">"Min"</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = criticalMap.get(<span class="string">"Max"</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNum == maxNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值放在第一个桶，最大值放在最后一个桶</span></span><br><span class="line">        min[<span class="number">0</span>] = minNum;</span><br><span class="line">        max[<span class="number">0</span>] = minNum;</span><br><span class="line">        existNumber[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        min[min.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        max[max.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        existNumber[existNumber.length-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个桶中存放的数值范围</span></span><br><span class="line">        <span class="keyword">double</span> scope = (<span class="keyword">double</span>) (min[min.length-<span class="number">1</span>] - min[<span class="number">0</span>])/min.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == min[<span class="number">0</span>] || num == max[max.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该元素应该存放的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.ceil((num - min[<span class="number">0</span>]) / scope)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existNumber[index]) &#123;</span><br><span class="line">                min[index] = num;</span><br><span class="line">                max[index] = num;</span><br><span class="line">                existNumber[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; max[index]) &#123;</span><br><span class="line">                    max[index] = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min[index]) &#123;</span><br><span class="line">                    min[index] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录非空桶的坐标</span></span><br><span class="line">        List&lt;Integer&gt; existIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existNumber.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existNumber[i]) &#123;</span><br><span class="line">                existIndex.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最大差值</span></span><br><span class="line">        <span class="keyword">int</span> maxBorderCount = max[<span class="number">0</span>] - min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existIndex.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = min[existIndex.get(i+<span class="number">1</span>)] - max[existIndex.get(i)];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; maxBorderCount) &#123;</span><br><span class="line">                maxBorderCount = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxBorderCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值和最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; <span class="title">getMaxAndMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">"Max"</span>,max);</span><br><span class="line">        result.put(<span class="string">"Min"</span>,min);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">                result = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; testCount;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = ArrayUtil.getArray(<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span> border1 = BorderCount.getBorderCount(arr1);</span><br><span class="line">            <span class="keyword">int</span> border2 = BorderCount.testMethod(arr2);</span><br><span class="line">            <span class="keyword">if</span> (border1 != border2) &#123;</span><br><span class="line">                is_success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_success) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p><p>现在给出一个数组请求出数组的小和。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>数组：[1,3,4,2,5]</p><p>1左边比1小的数，没有；</p><p>3左边比3小的数，1；</p><p>4左边比4小的数，1、3；</p><p>2左边比2小的数，1；</p><p>5左边比5小的数，1、3、4、2；</p><p>所以小和为1+1+3+1+1+3+4+2=16</p><h3 id="常见思路-1"><a href="#常见思路-1" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路,O(n2)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">badMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[j]) smallSum += arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进</p><h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h3><p>在<a href="https://blog.cairui99.cn/2019/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>的基础上进行改进，在merge左右两个有序数组时候，<strong>如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和</strong>，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用分治思想,O(n*logn)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left - (left-right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,left,mid) + getSmallSum(arr,mid+<span class="number">1</span>,right) + merge(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] merge_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> index_merge = left;</span><br><span class="line">    <span class="keyword">int</span> index_left = left;</span><br><span class="line">    <span class="keyword">int</span> index_right = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外排</span></span><br><span class="line">    <span class="keyword">while</span> (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数)</span></span><br><span class="line">        smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+<span class="number">1</span>) * arr[index_left] : <span class="number">0</span>;</span><br><span class="line">        merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = index_left&lt;=mid ? index_left : index_right;</span><br><span class="line">    <span class="keyword">int</span> end = index_left&lt;=mid ? mid : arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line">        merge_arr[index_merge++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排好序的结果赋给原数组</span></span><br><span class="line">    System.arraycopy(merge_arr, left, arr, left, right + <span class="number">1</span> - left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时算法的时间复杂度就提升到了O(n*logn)的级别</p><h2 id="旋转正方形矩阵"><a href="#旋转正方形矩阵" class="headerlink" title="旋转正方形矩阵"></a>旋转正方形矩阵</h2><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure><h2 id="栈实现队列-amp-队列实现栈"><a href="#栈实现队列-amp-队列实现栈" class="headerlink" title="栈实现队列&amp;队列实现栈"></a>栈实现队列&amp;队列实现栈</h2><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>要求使用栈实现队列的如下方法：</p><ul><li>offer(入队)</li><li>poll(出队)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个栈，push栈和pop栈</li><li>offer()：push栈正常入栈</li><li>poll(): 弹出pop栈的栈顶元素并返回 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li><li>peek(): 返回pop栈的栈顶元素 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li></ul><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; push = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pop  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        push.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!push.isEmpty()) &#123;</span><br><span class="line">            pop.push(push.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列实现栈结构"><a href="#队列实现栈结构" class="headerlink" title="队列实现栈结构"></a>队列实现栈结构</h3><p>要求使用队列实现栈结构的如下方法：</p><ul><li>push(入栈)</li><li>pop(出栈)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个队列，data队列和help队列</li><li>push(): data队列正常入队</li><li>pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回</li><li>peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回</li></ul><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列实现栈结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBecomeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        data.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> help.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = data.remove();</span><br><span class="line">        help.offer(ret);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="之字形打印矩阵"><a href="#之字形打印矩阵" class="headerlink" title="之字形打印矩阵"></a>之字形打印矩阵</h2><p>输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：</p><ul><li>1</li><li>2 5</li><li>9 6 3</li><li>4 7 10 13</li><li>14 11 8</li><li>12 15</li><li>16</li></ul><p>要求：额外空间复杂度为O(1)</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角</li><li>指针A、B每次同时移动一格，移动规则为：<ul><li>指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动</li><li>指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动</li></ul></li><li>在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印)</li><li>最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束</li></ul><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之字型打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] indexA = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] indexB = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAToB = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            printStraightLine(matrix,indexA,indexB,isAToB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>) &amp;&amp; indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123; <span class="comment">//终点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新A、B坐标</span></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexA[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexA[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexB[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexB[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isAToB = !isAToB;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印点A~B这条线的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStraightLine</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] indexA, <span class="keyword">int</span>[] indexB, <span class="keyword">boolean</span> isAToB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (indexA[<span class="number">0</span>] == indexB[<span class="number">0</span>] &amp;&amp; indexA[<span class="number">1</span>] == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.println(matrix[indexA[<span class="number">0</span>]][indexA[<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能改变数组中的值,用变量代替</span></span><br><span class="line">        <span class="keyword">int</span> x = isAToB ? indexA[<span class="number">0</span>] : indexB[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = isAToB ? indexA[<span class="number">1</span>] : indexB[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isAToB) &#123; <span class="comment">// 从A打印到B</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == indexB[<span class="number">0</span>] &amp;&amp; y == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从B打印到A</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (indexA[<span class="number">0</span>] == x &amp;&amp; indexA[<span class="number">1</span>] == y) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ZigZagPrintMatrix.zigZagPrintMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/11/05/M9pE11.png" alt="M9pE11.png"></p><h2 id="Min栈的实现"><a href="#Min栈的实现" class="headerlink" title="Min栈的实现"></a>Min栈的实现</h2><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：</p><ul><li>1．pop、push、peek、getMin操作的时间复杂度都是O(1)。</li><li>2．设计的栈类型可以使用现成的栈结构。</li></ul><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul><li>内部创建两个栈，data栈和min栈</li><li>元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是<strong>(min栈的栈顶存的永远是data栈中的最小值)</strong></li><li>出栈时data栈和min栈一起正常出栈</li><li>getMin()方法只需要返回min栈的栈顶元素</li></ul><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span></span><br><span class="line"><span class="comment"> * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。</span></span><br><span class="line"><span class="comment"> *         2．设计的栈类型可以使用现成的栈结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        data.push(num);</span><br><span class="line">        min.push((min.peek() &gt; num) ? num : min.peek());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.pop();</span><br><span class="line">        <span class="keyword">return</span> data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些整理了出了题解的常见算法题，代码都是自己写的&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://blog.cairui99.cn/2020/06/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2020/06/01/Java并发编程/</id>
    <published>2020-06-01T02:39:50.000Z</published>
    <updated>2020-06-03T12:18:25.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是并发编程"><a href="#什么是并发编程" class="headerlink" title="什么是并发编程"></a>什么是并发编程</h3><a id="more"></a><p>并发是指同一个时间段内多个任务同时在执行，此时线程的数量一般是大于CPU核数的，当一个线程占用CPU运行时，其他任务就会被挂起，当占用CPU的线程时间片用完后，会保留当前线程执行的上下文，并把CPU让给其他线程使用。（其中上下文切换是有额外开销的）</p><p>如果是在双CPU配置下，两个线程同时运行，这种情况称为并行运行，而不会并发。</p><h3 id="Java中的线程安全问题"><a href="#Java中的线程安全问题" class="headerlink" title="Java中的线程安全问题"></a>Java中的线程安全问题</h3><p>产生线程安全问题的核心是多个线程间存在 <strong>共享资源：</strong> 共享资源是可以被多个线程所持有或者多个线程可以去访问的资源。</p><p>那么线程间存在共享资源的情况下，何时才会产生线程安全的问题呢？ 如果多个线程都只是读取共享资源，是不会产生线程安全问题的。  <strong>只有当至少一个线程修改共享资源时才会存在线程安全问题，</strong> 例如线程A在操作修改共享资源时，线程B读取到的值是没有同步的，此时线程A的修改结果还没有更新到主内存中，产生了线程安全问题。</p><h3 id="Java中共享变量的内存可见性问题"><a href="#Java中共享变量的内存可见性问题" class="headerlink" title="Java中共享变量的内存可见性问题"></a>Java中共享变量的内存可见性问题</h3><p>首先看看在多线程下的Java内存模型</p><p><img src="https://s1.ax1x.com/2020/06/01/tGHgzR.jpg" alt="tGHgzR.jpg"></p><p>Java内存模型规定，所有的变量都存放在主内存中，当线程使用变量时，会把主内存的变量复制到自己的工作空间或者叫工作内存中，当线程进行读写操作时操作的是自己工作内存中的变量，如果是写操作会在操作后将值更新到主内存的共享变量中。</p><h3 id="Java中的synchronized关键字"><a href="#Java中的synchronized关键字" class="headerlink" title="Java中的synchronized关键字"></a>Java中的synchronized关键字</h3><h4 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h4><p>synchronized块是Java提供的一种原子性内置锁，也叫监视器锁。</p><p>线程执行到synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者调用了wait系列方法时释放内置锁。</p><p>synchronized会阻塞和唤醒线程，线程需要进行上下文切换，是比较消耗性能的。</p><h4 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="headerlink" title="synchronized的内存语义"></a>synchronized的内存语义</h4><p>前面说了线程安全问题主要是共享变量在线程的工作内存的可见性问题导致的，下面说一下synchronized的内存语义：</p><ul><li>进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，也就是说在synchronized内使用的变量将不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</li></ul><p>除了解决共享变量内存的可见性问题外，synchronized还经常被用来实现原子性操作。</p><h3 id="Java中的Lock锁"><a href="#Java中的Lock锁" class="headerlink" title="Java中的Lock锁"></a>Java中的Lock锁</h3><p>使用Java中的Lock，可以得到和synchronized相同的效果。</p><p>Lock是Java1.5后在java.util.concurrent.locks包下提供的一种实现同步的方法，那么显然的，synchronized一定是有什么做不到的或者缺陷，才导致了Lock的诞生。</p><h4 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h4><p>缺点如下：</p><ul><li>当一个代码块被synchronized修饰的时候，一个线程获取到了锁，并且执行代码块，那么其他的线程需要等待正在使用的线程释放掉这个锁，那么释放锁的方法只有两种，一种是代码执行完毕自动释放，一种是发生异常以后jvm会让线程去释放锁。那么如果这个正在执行的线程遇到什么问题，比如等待IO或者调用sleep方法等等被阻塞了，无法释放锁，而这时候其他线程只能一直等待，将会特别影响效率。</li><li>当一个文件，同时被多个线程操作时，读操作和写操作会发生冲突，写操作和写操作会发生冲突，而读操作和读操作并不会冲突，但是如果我们用synchronized的话，会导致一个线程在读的时候，其他线程想要读的话只能等待</li><li>在使用synchronized时，我们无法得知线程是否成功获取到锁</li></ul><p>Lock的出现则是为了解决如下问题。</p><h4 id="Lock锁概述"><a href="#Lock锁概述" class="headerlink" title="Lock锁概述"></a>Lock锁概述</h4><p>Lock锁，使用时手动获取锁和释放锁，比synchronized更加灵活；可中断的获取锁；超时获取锁。</p><p>Lock是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。</p><p>Lock 锁的基本用法， l.lock()方法进行上锁， l.unlock()方法进行解锁，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 上锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock锁的Api"><a href="#Lock锁的Api" class="headerlink" title="Lock锁的Api"></a>Lock锁的Api</h4><p>Api如下：</p><ul><li><strong>void lock():</strong> 获得锁</li><li><strong>void lockInterruptibly​()：</strong> 获得锁，可中断。举个例子，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li><li><strong>boolean tryLock​()：</strong> 锁在空闲的才能获取锁（未获得锁不会等待）。举个例子：当两个线程同时通过lock.trylock()想获取某个锁时，假若此时线程A获取到了锁，而线程B不会等待，直接放弃获取锁。</li><li><strong>boolean tryLock​(long time, TimeUnit unit)：</strong> 如果锁定可用，则此方法立即返回值true。如果锁不可用，则当前线程将被禁用以进行线程调度，并且在发生以下三种情况之一之前处于休眠状态：<ul><li>当前线程获取锁</li><li>其他一些线程中断当前线程</li><li>等待时间过去了，返回false</li></ul></li><li><strong>void unlock()：</strong> 释放锁</li></ul><p>只看api就可以看出，lock锁相对于synchronized来说使用是非常灵活的。</p><h3 id="Java中的volatile关键字"><a href="#Java中的volatile关键字" class="headerlink" title="Java中的volatile关键字"></a>Java中的volatile关键字</h3><p>前面介绍了使用锁的方式来解决共享变量内存可见性问题，但是锁太笨重，会带来线程上下文切换的开销。因此对于内存可见性问题，Java还提供了一种弱形式的同步，就是 <strong>volatile</strong> 关键字。</p><p>volatile关键字关键字的作用是，可以让被volatile修饰的共享变量的更新对其他线程马上可见。</p><p>当一个变量被volatile修饰时，线程在修改变量值时不会把值更新在私有内存中，而是更新到主内存里；当其他线程读取共享变量时，也是直接从主内存中读取共享变量的值。</p><p>volatile的内存语义就是：当线程每次写入时都会刷新主内存中的值，线程每次读取都会先去同步主内存中的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是并发编程&quot;&gt;&lt;a href=&quot;#什么是并发编程&quot; class=&quot;headerlink&quot; title=&quot;什么是并发编程&quot;&gt;&lt;/a&gt;什么是并发编程&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java注解/</id>
    <published>2020-05-18T09:33:13.000Z</published>
    <updated>2020-05-19T05:42:03.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><p>Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。</p><a id="more"></a><p>注解不同与注释，注解的内容会被嵌入到字节码中，我们可以通过反射来获取到注解内容。</p><h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p><strong>作用在代码里的注解：</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p><strong>作用再其他注解上的注解（元注解）：</strong></p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p><strong>Java7之后新增的注解：</strong></p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><h3 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h3><p><a href="https://imgchr.com/i/Yhn4Vf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/18/Yhn4Vf.jpg" alt="Yhn4Vf.jpg"></a></p><p>可以看到，Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p><p>Annotation 的每一个实现类，都 <strong>和 1 个 RetentionPolicy 关联</strong> 并且 <strong>和 1~n 个 ElementType 关联</strong></p><h3 id="Annotation组成部分"><a href="#Annotation组成部分" class="headerlink" title="Annotation组成部分"></a>Annotation组成部分</h3><p>组成Annotation的三个类分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line"></span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Annotation是个接口，实现类需要实现自该接口。</strong></p><p><strong>ElementType是Enum 枚举类型，它用来指定 Annotation 的类型：</strong> 当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p><p> <strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同：</strong></p><ul><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ul><h3 id="Annotation通用定义"><a href="#Annotation通用定义" class="headerlink" title="Annotation通用定义"></a>Annotation通用定义</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们自定义了一个注解，定义成功后，我们可以在代码中通过@MyAnnotation1来使用它。</p><p>其中@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的：</p><ul><li><strong>@interface</strong> ：使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。<strong>定义 Annotation 时，@interface 是必须的。</strong></li><li><strong>@Documented</strong> : 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</li><li><strong>@Target (ElementType.TYPE)</strong> : 用来指定 Annotation 的类型属性。@Target(ElementType.TYPE)意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。<strong>(定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方)</strong></li><li><strong>@Retention(RetentionPolicy.RUNTIME)</strong>: 指定 Annotation 的策略属性。@Retention(RetentionPolicy.RUNTIME) 的意思就是指编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<strong>(定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS)</strong></li></ul><p>总结：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型（ElementType），@Retention 用来指定 Annotation 的策略（RetentionPolicy）。</p><h3 id="java常用的Annotation"><a href="#java常用的Annotation" class="headerlink" title="java常用的Annotation"></a>java常用的Annotation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>继承性是指：我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了<br>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><p>可以让编译器忽略掉某些警告，例如在方法中添加 <strong>@SuppressWarnings(value={“deprecation”})</strong> 后，在方法中使用了某些不赞成的类或方法时将不在给予警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure><h3 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用"></a>Annotation的作用</h3><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p><p>在编程中经常会使用到的 Annotation 作用有：</p><h4 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h4><p>例如，@SuppressWarnings , @Deprecated 和 @Override 都具有编译检查作用。</p><p>灵活使用注解可以让编译器发现或忽略特定的错误。</p><h4 id="在反射中使用Annotation"><a href="#在反射中使用Annotation" class="headerlink" title="在反射中使用Annotation"></a>在反射中使用Annotation</h4><p>可以通过 Method.getAnnotation(Class);来获取注解信息并使用。</p><h4 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h4><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>可以通过反射来获取到我们自定义的注解，来实现某些功能。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>参考自博客: <a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java注解&quot;&gt;&lt;a href=&quot;#Java注解&quot; class=&quot;headerlink&quot; title=&quot;Java注解&quot;&gt;&lt;/a&gt;Java注解&lt;/h2&gt;&lt;p&gt;Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="注解" scheme="http://blog.cairui99.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java线程基础</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java线程基础/</id>
    <published>2020-05-18T05:57:48.000Z</published>
    <updated>2020-06-02T11:10:25.718Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍：<strong>Java并发编程之美</strong></p><a id="more"></a><h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><p>讨论线程前必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。</p><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源是是把资源分配给进程的，但是CPU资源比较特殊，它是分配给线程的，因为真正要占用CPU资源的是线程，所以也说 <strong>线程是CPU分配的基本单位</strong></p><p>在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是JVM进程中的一个线程，main函数线程也称为 <strong>主线程</strong></p><p><img src="https://s1.ax1x.com/2020/05/17/YRVXZQ.png" alt="YRVXZQ.png"></p><p>可以看到图中一个进程中有多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域。</p><p>程序计数器是用来记录线程当前要执行的指令地址，那为什么要记录呢?前面说了线程是占用CPU执行的基本单位，而CPU一般是使用时间片轮转的方式让线程轮询占用的，所以当前占有CPU资源的线程CPU时间片用完后就要让出CPU资源，等到下次轮到自己时再继续执行，所以此时就需要程序计数器记录该线程让出CPU时的执行地址，等到下次可以继续执行。</p><p>另外每个线程都有自己的栈资源，用于存储该线程的局部变量，这些都是该线程私有的，其他线程访问不了，除此之外还有用来存放线程的调用栈帧。</p><p>堆是进程中最大的一块内存，是所有线程共享的，里面主要存放使用new操作创建的对象实例。</p><p>方法区则用来存放JVM加载的类信息、常量、静态变量等信息，也是线程共享的。</p><h3 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h3><p>线程的创建有三种方式：</p><ul><li>继承Thread类，重写run方法</li><li>实现Runnable接口的run方法</li><li>实现Callable接口的call()方法</li></ul><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是创建线程时线程并没有启动，只有调用start方法时线程才会启动 <strong>（调用start方法后线程会处于就绪状态，需要等待获取cpu资源后才会真正处于运行状态）</strong> ，当run方法执行完毕，线程会处于终止状态。</p><p>使用继承的好处：在run()方法中直接使用this就可以直接获取当前线程；缺点是java不支持多继承，继承Thread类后无法继承其他类。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunableTask task = <span class="keyword">new</span> RunableTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个线程共用了一个task代码逻辑，如果需要可以给RunableTask添加参数进行任务区分，同时RunableTask也可以继承其他类。</p><p>但还是有一个问题，就是任务没有返回值，下面给出实现Callable接口的方式</p><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="comment">//异步获取返回值</span></span><br><span class="line">    String result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set<br>方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线<br>程里面被声明为 final 变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类，<br>那么子类不能再继承其他类，而 Runable 则没有这个限制 。前两种方式都没办法拿到任务<br>的返回结果，但是 Futuretask 方式可以。</p><h3 id="线程的通知与等待"><a href="#线程的通知与等待" class="headerlink" title="线程的通知与等待"></a>线程的通知与等待</h3><p>线程的通知与等待相关的函数使用的是Object类中自带的方法，java中所有的类都可以使用。</p><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h4><p>当一个线程调用一个共享变量的wait()方法时，该调用线程会被 <strong>阻塞挂起</strong>，同时释放掉该共享变量的监视器锁，唤醒被wait()方法挂起的线程的方法是：</p><ul><li>其他线程调用了该共享变量的notify()或notifyAll()方法</li><li>其他线程调用了该线程的interrupt()方法，该线程会抛出InterruptedException异常返回</li></ul><p>如果当前线程在调用共享变量的wait()时没有获取到该共享变量的监视器锁，此时会抛出IllegalMonitorStateException异常，一般使用synchronized关键字来拿到对象的监视器锁。</p><p>需要注意的是，使用wait()方法只会让线程释放掉该共享变量的锁，并不会释放线程持有的其他锁，下面是个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA get resourceA lock"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadA get resourceB lock"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"threadA release resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB get resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"threadB get resourceB lock"</span>);</span><br><span class="line">                            System.out.println(<span class="string">"threadB release resourceA lock"</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待两个线程执行结束</span></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main over"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadA get resourceA lock</span><br><span class="line">threadA get resourceB lock</span><br><span class="line">threadA release resourceA lock</span><br><span class="line">threadB get resourceA lock</span><br></pre></td></tr></table></figure><p>线程A在调用resourceA的wait()方法后释放了它锁持有的resourceA的监视器锁，但没有释放掉它所持有的其他共享变量的锁。</p><h4 id="wait-long-timeout-函数"><a href="#wait-long-timeout-函数" class="headerlink" title="wait(long timeout)函数"></a>wait(long timeout)函数</h4><p>如果线程在timeout的规定时间内没有被其他线程通过notify()或notifyAll()方法唤醒，那么该线程也会因为超时而被唤醒。</p><h4 id="notify-函数"><a href="#notify-函数" class="headerlink" title="notify()函数"></a>notify()函数</h4><p>当一个线程调用共享变量的notify()方法后，会随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。</p><p>被唤醒的线程不一定会继续执行，它必须先获取到共享对象的锁，但该线程可能需要和其他线程共同竞争这把锁。</p><p>同wait()方法，notify()方法也需要在获取到共享变量的监视器锁后，才可以调用，否则会抛异常。</p><h4 id="notifyAll-函数"><a href="#notifyAll-函数" class="headerlink" title="notifyAll()函数"></a>notifyAll()函数</h4><p>唤醒所有在该共享变量上调用wait系列方法被挂起的线程。</p><h3 id="等待线程执行终止的join方法"><a href="#等待线程执行终止的join方法" class="headerlink" title="等待线程执行终止的join方法"></a>等待线程执行终止的join方法</h3><p>join()方法是由Thread类提供的无参、无返回值的方法。</p><p>如果程序需要等待某个或多个线程执行完毕程序再继续往下执行的情况，此时可以用到join()方法来实现。</p><p>比如在main方法中，也是就使用主线程调用线程A的join方法，主线程就会被阻塞，等待线程A执行完毕后，主线程才会继续执行，</p><p>此时如果调用主线程在阻塞过程中调用了interrupt()方法，会抛出InterruptedException异常。</p><h3 id="让线程睡眠的sleep方法"><a href="#让线程睡眠的sleep方法" class="headerlink" title="让线程睡眠的sleep方法"></a>让线程睡眠的sleep方法</h3><p>sleep()是Thread类中的静态方法，调用的线程会让出指定时间的执行权，也就是这期间不参与CPU的调度，<strong>但该线程持有的监视器锁还是持有不让出的，</strong> sleep的执行时间过后，线程就会变为就绪状态，等待CPU的调度然后继续执行。</p><p>线程在sleep期间</p><h3 id="让出CPU执行权的yield方法"><a href="#让出CPU执行权的yield方法" class="headerlink" title="让出CPU执行权的yield方法"></a>让出CPU执行权的yield方法</h3><p>yield()方法是Thread类中的静态方法，相当于告诉线程调度器自己占有的时间片还没有使用完但是自己不想再使用了，暗示线程调度器现在可以进行下一轮的线程调度了。</p><p>当一个线程调用yield方法时，当前线程就会让出CPU使用权，然后变为就绪状态，线程调度器会从就绪队列中获取一个优先级最高的线程来给与CPU的执行权，当前这个优先级最高的线程也可能是刚刚调用yield方法的这个线程。</p><p>总结sleep和yield的区别，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，这期间线程调度器不会去调度该线程；而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到该线程执行。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>java中线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理：</p><ul><li><strong>void interrupt()方法：</strong> 中断线程，例如线程A在运行时，线程B可以调用线程A的interrupt()方法将线程A的中断标志置为true并立即返回，如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起时，线程A会抛出InterruptedException异常返回</li><li><strong>boolean isInterrupted()方法：</strong> 检测当前线程是否被中断</li><li><strong>boolean interrupted()方法：</strong> 检测当前线程是否被中断，与 isInterrupted()不同的是，如果发现线程被中断则清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。</li></ul><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>在多线程环境下，线程个数一般都大于CPU个数，而每个CPU同一时刻只能被一个线程使用，为了让用户感觉到所有线程是同时运行的，CPU资源的分配采用了时间片轮转的策略，也就是为每一个线程分配一个时间片，当前线程时间片用完后，线程会变为就绪状态并让出CPU让其他线程占用，这就是 <strong>上下文切换</strong></p><p>线程上下文切换时机有：</p><ul><li>当前线程的CPU时间片使用完，并处于就绪状态</li><li>当前线程被其他线程中断</li></ul><p>程序计数器会记录当前线程运行到哪里了，待下次执行时可以恢复执行现场。</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><strong>死锁必须具备的四个条件：</strong></p><ul><li>互斥条件：表示该资源同时只能由一个线程占用</li><li>请求并保持条件：指一个线程已经持有了至少一个资源，但又同时再请求新的资源，而新资源已被其他线程占有，当前线程就会被阻塞，并且不会释放自己持有的资源</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占</li><li>环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链</li></ul><p>下面是一个死锁的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main is finish"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get ResourceB</span><br></pre></td></tr></table></figure><p>可以看到程序并没有结束，而是两个线程都在互相请求对方持有的资源，永远的等待下去，构成了死锁状态</p><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>避免线程死锁只需破坏掉至少一个死锁的必要条件即可，目前只有请求并保持和环路等待条件是可以破坏的。</p><p>造成死锁的原因与申请资源的顺序有很大关系，使用资源申请的有序性原则就可以有效的避免死锁。</p><p>在上面死锁的例子中，只需要将线程B的代码进行如下修改，即可避免死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get resourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">main is finish</span><br></pre></td></tr></table></figure><h3 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h3><p>Java中的线程分为两类，分别为 <strong>守护线程</strong> 和 <strong>用户线程</strong> ,在JVM启动时调用main函数所在的线程就是一个用户线程，同时JVM还会启动好多守护线程，例如垃圾回收线程。</p><p>守护线程与用户线程的区别是：</p><ul><li>当最后一个非守护线程结束时，JVM就会正常退出，也就是说守护线程是否结束并不影响JVM的退出。</li></ul><p>在Java中使用下面的方式创建守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread daemonThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程环境下访问同一个共享资源很容易出现并发问题，为了保证线程安全需要对共享变量进行同步。</p><p>同步的措施一般是加锁，但也可以使用ThreadLoacal的方式，使每个线程变量进行访问的时候访问的是自己线程的变量。</p><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有一个这个变量的本地副本，当操作变量时实际操作的是自己本地内存里的变量，从而避免了线程安全的问题。</p><h4 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">        <span class="comment">//localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadOne local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadOne"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadOne remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadTwo local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadTwo"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadTwo remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadTwo remove after:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadOne remove after:threadOne local variable</span><br></pre></td></tr></table></figure><p>去掉print方法中的注释后，输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadTwo remove after:null</span><br><span class="line">threadOne remove after:null</span><br></pre></td></tr></table></figure><p>没写完，待更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考书籍：&lt;strong&gt;Java并发编程之美&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://blog.cairui99.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="http://blog.cairui99.cn/2020/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://blog.cairui99.cn/2020/05/03/Java虚拟机/</id>
    <published>2020-05-03T13:39:38.000Z</published>
    <updated>2020-05-10T13:16:24.801Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍：<strong>深入理解java虚拟机（第三版）</strong></p><a id="more"></a><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java虚拟机简单来说就是Java的代码编译好之后，是跑在一台虚拟的机器（VM）上的，这台虚拟的机器负责分配内存和维护调用堆栈。</p><p>为什么要做成虚拟的机器这要从Java的一次编译到处执行来说。事实上一次编译到处执行是不可能的，因为每个机器不一样，所以传统上我们必须针对每一种机器编译代码，才能在这个机器上运行。而Java通过引入虚拟机（VM）的概念，让编译后的代码直接跑在一台虚拟的机器上，无论最终的目标平台是什么，都在上面构建出一个虚拟的一致的虚拟机出来，就可以达到一次编译到处执行的效果了。</p><h2 id="JVM内存模型与内存溢出异常"><a href="#JVM内存模型与内存溢出异常" class="headerlink" title="JVM内存模型与内存溢出异常"></a>JVM内存模型与内存溢出异常</h2><p>与C、C++不同，Java程序不再需要为每一个new操作去写配对的delete/free代码，在java中由JVM来帮忙管理、分配内存。</p><p>虽然jvm来管理内存带来了便利，不过一旦出现内存泄漏和溢出方面的问题，如果不了解java虚拟机是怎么使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>为了更好的理解java虚拟机的内存模型，我们把java虚拟机所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。</p><p>java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图：</p><p><img src="https://s1.ax1x.com/2020/05/03/Ypykhd.jpg" alt="Ypykhd.jpg"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>一块较小的内存空间，是<strong>线程私有</strong>的，可以看作是 <strong>当前线程所执行的字节码的行号指示器</strong></p><p>行号指示器就是在程序执行时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>与程序计数器一样，java虚拟机栈也是 <strong>线程私有的</strong> ，它的生命周期与线程相同。</p><p>虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个 <strong>栈帧</strong> ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。通常我们说的”栈”，一般是指java虚拟机栈中的 <strong>局部变量表</strong> 部分。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF73ZT.png" alt="YF73ZT.png"></p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，例如递归函数没有被正常终止时；</p><p>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）</p><h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行 <strong>方法调用</strong> 和 <strong>方法执行</strong> 的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。</p><p>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。</p><p>在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p><img src="https://s1.ax1x.com/2020/05/05/YFqeiD.png" alt="YFqeiD.png"></p><p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为 <strong>当前栈帧</strong> ，与这个栈帧相关联的方法称为 <strong>当前方法</strong> 。</p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放 <strong>方法参数</strong> 和方法内部定义的 <strong>局部变量</strong> 。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表存放了编译期可知的各种基本数据类型，对象引用(reference类型) 和 returnAddress类型（它指向了一条字节码指令的地址）</p><p><strong>这里的变量仅指方法中的局部变量，成员变量是各个线程共享的，保存在堆中。</strong></p><h5 id="reference（对象实例的引用"><a href="#reference（对象实例的引用" class="headerlink" title="reference（对象实例的引用)"></a>reference（对象实例的引用)</h5><p>类似于一个超链接，如图：</p><p><img src="https://s1.ax1x.com/2020/05/05/YkMUV1.png" alt="YkMUV1.png"></p><h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><p>也就是方法被调用的位置，在方法退出时将返回值传递给上层的方法调用者。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥得作用是相同的。区别是java虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是 <strong>为虚拟机使用到本地（Native）方法服务</strong> 。</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>java堆是虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域。用来 <strong>存放对象实例。</strong></p><p>java堆也是垃圾收集器管理的内存区域，所以java堆中经常出现新生代、老年代、永久代等名词。</p><p>根据虚拟机的规范，java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视作为连续的，类似于磁盘存储。</p><p>java堆是可以实现扩展的，通过参数-Xmx和-Xms设定，如果堆中还没有完成内存分配并且无法扩展时，java虚拟机会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和堆一样，方法区是一块所有线程共享的内存区域。</p><p>方法去用来保存<strong>类的信息</strong>。比如类的字段、方法、常量池等。方法区的大小决定系统可以保存多少个类。如果系统</p><p>定义太多的类，导致方法区溢出。虚拟机同样会抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，用于存放编译期生成的字面量与符号引用。</p><p>字面量相当于java语言中常量的概念；</p><p>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考书籍：&lt;strong&gt;深入理解java虚拟机（第三版）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://blog.cairui99.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitHub_Page自定义域名失效问题</title>
    <link href="http://blog.cairui99.cn/2020/04/28/GitHub-Page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/28/GitHub-Page自定义域名失效问题/</id>
    <published>2020-04-28T14:37:19.000Z</published>
    <updated>2020-04-28T14:40:12.566Z</updated>
    
    <content type="html"><![CDATA[<p>使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置</p><p>解决方法： <strong>在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更新域名了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置&lt;/p&gt;
&lt;p&gt;解决方法： &lt;strong&gt;在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 每日一题</title>
    <link href="http://blog.cairui99.cn/2020/04/26/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/26/LeetCode-每日一题/</id>
    <published>2020-04-26T13:46:10.000Z</published>
    <updated>2020-06-04T07:44:22.007Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode活动：每日一题，看能坚持多久</p><a id="more"></a><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并K个排序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_end = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!is_end) &#123;</span><br><span class="line">            is_end = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">                ListNode listNode = lists[i];</span><br><span class="line">                <span class="keyword">if</span> (listNode != <span class="keyword">null</span> &amp;&amp; listNode.val &lt; min) &#123;</span><br><span class="line">                    is_end = <span class="keyword">false</span>;</span><br><span class="line">                    min = listNode.val;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!is_end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                lists[index] = lists[index].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (front &lt;= back) &#123;</span><br><span class="line">            mid = (front + back) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> scope = <span class="keyword">this</span>.getScope(nums, mid, front, back, target);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">1</span>) &#123;</span><br><span class="line">                back = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">2</span>) &#123;</span><br><span class="line">                front = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缩小target的范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int -1=&gt;不存在，0=&gt;中间，1=&gt;左边, 2=&gt;右边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getScope</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> front, <span class="keyword">int</span> back, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[front];</span><br><span class="line">        <span class="keyword">int</span> right = nums[back];</span><br><span class="line">        <span class="keyword">int</span> middle = nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (middle == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123; <span class="comment">//数组没有被旋转过</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; target &amp;&amp; middle &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &lt; target &amp;&amp; right &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &gt; target &amp;&amp; middle &lt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; target &amp;&amp; middle &gt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中数字出现的次数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            k ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得k中最低位的1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((k &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="comment">//分组</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                answer[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（工作忙，鸽了两天。。。心态崩了）</strong></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-two-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caiui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1.val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2.val;</span><br><span class="line">            min = Math.min(val1, val2);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = val1 &gt;= val2 ? l1 : l1.next;</span><br><span class="line">            l2 = val1 &lt;  val2 ? l2 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nowLength = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(strs[j]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nowLength++;</span><br><span class="line">                    map.put(strs[j], strs[j]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nowLength &gt; maxLength) &#123;</span><br><span class="line">                maxLength = nowLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strs.length - i - <span class="number">1</span>) &lt;= maxLength) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大子序和</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            now = (num + now &lt; <span class="number">0</span>) ? num : num + now;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; max) &#123;</span><br><span class="line">                max = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/jump-game-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> new_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (index + nums[index]); i &gt; index; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                    new_index = nums.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] - count) &gt; max) &#123;</span><br><span class="line">                    max = nums[i] - count;</span><br><span class="line">                    new_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            jump++;</span><br><span class="line">            index = new_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证二叉搜索树</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/validate-binary-search-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution98</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = node.val;</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!helper(node.right, val, upper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(node.left, lower, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h3><p>待优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最低票价</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/minimum-cost-for-tickets/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution983</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getWeekCount(<span class="keyword">int</span>[] days, <span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] weekCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> week = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_day = days[index] + <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> day = days[index++];</span><br><span class="line">            <span class="keyword">if</span> (day &lt;= next_day) &#123;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next_day = next_day + <span class="number">7</span>;</span><br><span class="line">                week++;</span><br><span class="line">                <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weekCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span>[] costs, <span class="keyword">int</span>[] weekCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekCount.length; i++) &#123;</span><br><span class="line">            money += Math.min(weekCount[i] * costs[<span class="number">0</span>], costs[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextMonthIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next_Month_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next_Month = days[index] + <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[i] &gt; next_Month) &#123;</span><br><span class="line">                next_Month_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next_Month_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="comment">//一个月内每周都有多少天</span></span><br><span class="line">            <span class="keyword">int</span>[] weekCount = <span class="keyword">this</span>.getWeekCount(days, index);</span><br><span class="line">            money += Math.min(<span class="keyword">this</span>.getMoney(costs, weekCount), costs[<span class="number">2</span>]);</span><br><span class="line">            index = <span class="keyword">this</span>.getNextMonthIndex(index, days);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pow(x, n)</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/powx-n/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution50</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> pow = x;</span><br><span class="line">        <span class="keyword">long</span> multiple = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (multiple != Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple * <span class="number">2</span> &lt;= Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                pow = pow * pow;</span><br><span class="line">                multiple = multiple * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> temp = pow;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((multiple + (multiple - count)) &gt; Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                    temp = temp / x;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                pow = pow * temp;</span><br><span class="line">                multiple += (multiple - count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (multiple == <span class="number">0</span>) &#123;</span><br><span class="line">                pow = Double.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pow = <span class="number">1</span> / pow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution102</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</span><br><span class="line">                List&lt;TreeNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (nodeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodeList.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode treeNode : nodeList) &#123;</span><br><span class="line">                    integerList.add(treeNode.val);</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.left);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.right);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                answer.add(integerList);</span><br><span class="line">                nodeList = newNodeList;</span><br><span class="line">                <span class="keyword">if</span> (!isContinue) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/single-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            num = num ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a>课程表 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程表 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/course-schedule-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = list.get(prerequisite[<span class="number">0</span>]);</span><br><span class="line">            temp.add(prerequisite[<span class="number">1</span>]);</span><br><span class="line">            list.set(prerequisite[<span class="number">0</span>], temp);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i).size() == <span class="number">0</span> &amp;&amp; map.get(i) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.put(i, i);</span><br><span class="line">                    answer[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> isStudy = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = list.get(i);</span><br><span class="line">                <span class="keyword">int</span> begin = temp.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = temp.get(j);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(num) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isStudy = <span class="keyword">true</span>;</span><br><span class="line">                        temp.remove(j);</span><br><span class="line">                        list.set(i, temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isStudy) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乘积最大子数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-product-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> negativeCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[index++];</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    isZero = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    negativeCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negativeCount % <span class="number">2</span> == <span class="number">0</span> || temp.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">this</span>.getProduct(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ArrayList&lt;Integer&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//第一个负数的位置</span></span><br><span class="line">                <span class="keyword">int</span> negativeIndex = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.get(i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        negativeIndex = (negativeIndex == -<span class="number">1</span>) ? i : negativeIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == negativeCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp1.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = negativeIndex + <span class="number">1</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    temp2.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                negative = Math.max(<span class="keyword">this</span>.getProduct(temp1), <span class="keyword">this</span>.getProduct(temp2));</span><br><span class="line">            &#125;</span><br><span class="line">            answer = Math.max(negative, answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (answer &lt; <span class="number">0</span> &amp;&amp; isZero) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getProduct</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            answer = answer * integer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串-Ⅱ"><a href="#验证回文字符串-Ⅱ" class="headerlink" title="验证回文字符串 Ⅱ"></a>验证回文字符串 Ⅱ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证回文字符串 Ⅱ</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/valid-palindrome-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution680</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back  = strs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front] != strs[back]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(strs, front + <span class="number">1</span>, back)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strs, front, back - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span>[] strs, <span class="keyword">int</span> front, <span class="keyword">int</span> back)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front++] != strs[back--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isOdd = (nums1.length + nums2.length) % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (nums1.length + nums2.length) / <span class="number">2</span>;</span><br><span class="line">        midIndex = isOdd ? midIndex : midIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; nums1.length &amp;&amp; index2 &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">double</span> num = (nums1[index1] &lt;= nums2[index2]) ? nums1[index1++] : nums2[index2++];</span><br><span class="line">            <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() != <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() != <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums = index1 &lt; nums1.length ? nums1 : nums2;</span><br><span class="line">            <span class="keyword">int</span> index = index1 &lt; nums1.length ? index1 : index2;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add((<span class="keyword">double</span>) nums[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : (list.get(<span class="number">0</span>) + list.get(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存机制</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/lru-cache/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; keyList   = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; valueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.valueList.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isExist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                isExist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(i, value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.size() &lt; <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">                <span class="keyword">this</span>.keyList.add(key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.add(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = countMap.get(keyList.get(i));</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; minCount) &#123;</span><br><span class="line">                        minCount = count;</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.keyList.set(index, key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(index, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找重复数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/find-the-duplicate-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution287</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == i &amp;&amp; ++count == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拥有最多糖果的孩子"><a href="#拥有最多糖果的孩子" class="headerlink" title="拥有最多糖果的孩子"></a>拥有最多糖果的孩子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拥有最多糖果的孩子</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1431</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; answerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; candy) &#123;</span><br><span class="line">                max = candy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            answerList.add(candy + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求1+2+…+n</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/qiu-12n-lcof/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution64</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新21点"><a href="#新21点" class="headerlink" title="新21点"></a>新21点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新21点</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/new-21-game/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution837</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] probabilityFront = <span class="keyword">new</span> <span class="keyword">double</span>[K + W -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> basisProbability = <span class="number">1</span> / (<span class="keyword">double</span>)W;</span><br><span class="line">        <span class="keyword">double</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算抽到 1 ~ (K + W) 的概率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= (K + W - <span class="number">1</span>); num++) &#123;</span><br><span class="line">            <span class="keyword">double</span> probability = (num &lt;= W) &amp;&amp; (K &gt; <span class="number">0</span>) ? basisProbability : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> begin = (num &gt; (K - <span class="number">1</span>)) ? (K - <span class="number">1</span>) : (num - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num2 = begin; num2 &gt;= <span class="number">1</span>; num2--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num - num2) &gt; W) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                probability += probabilityFront[num2 - <span class="number">1</span>] * basisProbability;</span><br><span class="line">            &#125;</span><br><span class="line">            probabilityFront[num - <span class="number">1</span>] = probability;</span><br><span class="line">            <span class="comment">// 记录超过N的概率</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; N) &#123;</span><br><span class="line">                answer += probability;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除自身以外数组的乘积</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/product-of-array-except-self/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution238</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 左边数的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] left   = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            left[i] = (i == <span class="number">0</span>) ? <span class="number">1</span> : (left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边数的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] right  = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right[i] = (i == (nums.length - <span class="number">1</span>)) ? <span class="number">1</span> : right[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案等于左边的乘积乘上右边的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            answer[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode活动：每日一题，看能坚持多久&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-ping通ip但ping不通域名</title>
    <link href="http://blog.cairui99.cn/2020/02/27/Linux-ping%E9%80%9Aip%E4%BD%86ping%E4%B8%8D%E9%80%9A%E5%9F%9F%E5%90%8D/"/>
    <id>http://blog.cairui99.cn/2020/02/27/Linux-ping通ip但ping不通域名/</id>
    <published>2020-02-27T06:51:10.000Z</published>
    <updated>2020-02-27T06:53:38.384Z</updated>
    
    <content type="html"><![CDATA[<p>原因：机器的域名解析有问题</p><p>解决方法：修改DNS配置</p><ul><li>sudo vi /etc/resolv.conf</li><li>添加  nameserver 8.8.8.8</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原因：机器的域名解析有问题&lt;/p&gt;
&lt;p&gt;解决方法：修改DNS配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sudo vi /etc/resolv.conf&lt;/li&gt;
&lt;li&gt;添加  nameserver 8.8.8.8&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr服务器搭建</title>
    <link href="http://blog.cairui99.cn/2020/01/03/ssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.cairui99.cn/2020/01/03/ssr服务器搭建/</id>
    <published>2020-01-03T07:28:52.000Z</published>
    <updated>2020-02-27T06:50:01.709Z</updated>
    
    <content type="html"><![CDATA[<p>搭建代理服务器前首先要有一台自己的机器，我是在这里办的 <a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a> ，优点是可以随时注销、随时办理，按小时收费。</p><a id="more"></a><p>有了自己的服务器后，登陆进去，依次输入下面几条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>运行成功后，会提示你设置你代理的密码、端口、协议等信息：</p><ul><li>如提示（Please enter password for ShadowsocksR）：设置密码，自己设定</li><li>如提示（Please enter a port for ShadowsocksR [1-65535]）：设置服务器端口，如不设定会随机生成</li><li>如提示（Please select stream cipher for ShadowsocksR）：设置加密方式，建议 <strong>chacha20</strong></li><li>如提示（Please select protocol for ShadowsocksR）：设置协议，默认为 <strong>origin</strong></li><li>如提示（Please select obfs for ShadowsocksR）：选择混淆方式，建议选择 <strong>http_simple</strong></li><li>至此所有配置已经设置完成，等待几分钟，配置成功会显示出所有配置信息，建议截图保存，以免遗忘</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建代理服务器前首先要有一台自己的机器，我是在这里办的 &lt;a href=&quot;https://my.vultr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.vultr.com/&lt;/a&gt; ，优点是可以随时注销、随时办理，按小时收费。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用natapp实现内网穿透功能</title>
    <link href="http://blog.cairui99.cn/2019/12/12/linux-%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://blog.cairui99.cn/2019/12/12/linux-使用natapp实现内网穿透功能/</id>
    <published>2019-12-12T06:07:07.000Z</published>
    <updated>2019-12-31T06:55:31.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单</p><a id="more"></a><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>前往官网 <a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a> 注册账号，并登录</p><p><a href="https://imgchr.com/i/Q4tFIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q4tFIS.md.png" alt="Q4tFIS.md.png"></a></p><h4 id="购买隧道"><a href="#购买隧道" class="headerlink" title="购买隧道"></a>购买隧道</h4><ol><li>登陆成功后，进入个人中心选择购买隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4N9SJ.png" alt="Q4N9SJ.png"></p><ol start="2"><li>个人使用选择：免费隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UK4U.png" alt="Q4UK4U.png"></p><ol start="3"><li>隧道协议选择：Web  点击免费购买（注：免费隧道的域名会随机更换，所以不适合长期使用，这里仅用来测试）</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UDvd.png" alt="Q4UDvd.png"></p><h4 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h4><ol><li>进入官网的客户端下载，选择linux</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q40nsJ.png" alt="Q40nsJ.png"></p><ol start="2"><li>下载并解压，解压后获得一个natapp的文件</li></ol><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>至此环境已经部署完成，下面开始运行natapp</p><h4 id="获取authtoken"><a href="#获取authtoken" class="headerlink" title="获取authtoken"></a>获取authtoken</h4><p>点击我的隧道，可以查看隧道的authtoken，用来启动客户端</p><p><img src="https://s2.ax1x.com/2019/12/17/QoEWbd.png" alt="QoEWbd.png"></p><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h4><p>进入natapp所在目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./natapp -authtoken=xxx</span><br></pre></td></tr></table></figure><p>可以看到客户端启动成功，Forwarding下的网址就是你的外网域名</p><p><img src="https://s2.ax1x.com/2019/12/17/Qot8c4.png" alt="Qot8c4.png"></p><h3 id="后台运行natapp"><a href="#后台运行natapp" class="headerlink" title="后台运行natapp"></a>后台运行natapp</h3><p>直接启动natapp有一个缺点，就是当终端窗口关闭或者ctrl+c的时候natapp进程会被终止，这时需要natapp在后台异步执行</p><p>虽然官网给出了后台运行的方案和教程： <strong>nohup + 命令 + &amp;</strong></p><p>但使用这种方式后我们需要的获取到的域名却不知道上哪里找了，虽然能后台运行了，但获取不到域名我运行你干什么。。。</p><p><strong>解决方案：</strong></p><ul><li>在natapp客户端的同级目录下引入一个config.ini的文件，下载地址：<a href="http://download.natapp.cn/assets/downloads/config.ini" target="_blank" rel="noopener">http://download.natapp.cn/assets/downloads/config.ini</a></li><li>打开config.ini，将<strong>loglevel</strong>的值设置为<strong>INFO</strong></li><li>执行命名：<strong>nohup ./natapp -authtoken=xxx &amp;</strong></li><li>此时在目录下会生成一个nohup.out的日志文件，打开即可查看到你的外网域名</li></ul><p><a href="https://imgchr.com/i/lEFJw8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEFJw8.md.png" alt="lEFJw8.md.png"></a></p><p>使用ps命令查看进程状态，发现natapp已经在后台运行了：<br><a href="https://imgchr.com/i/l12RYt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/31/l12RYt.md.png" alt="l12RYt.md.png"></a></p><p>需要注意的是，免费隧道的域名不是永久有效的，natapp可能随时会将你的域名强制更换，这时还需要到日志中查找最新的域名，所以如果想要稳定的服务还是需要购买付费隧道。</p><p>当然域名换的也不会很频繁，临时测试的话免费的就够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux后台运行php常驻进程</title>
    <link href="http://blog.cairui99.cn/2019/12/11/php-linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cphp%E5%B8%B8%E9%A9%BB%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2019/12/11/php-linux后台运行php常驻进程/</id>
    <published>2019-12-11T06:54:11.000Z</published>
    <updated>2019-12-12T05:56:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行</p><a id="more"></a><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><p>加在一个命令的最后，可以把这个命令放在后台执行</p><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使用 <strong>&amp;</strong> 命令使程序在后台执行，当终端关闭时程序会被终止，这时需要使用nohup命令，可以在你退出账户/关闭终端之后继续运行相应的进程。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohub 命令 &gt; /home/user/log/xxx.log &amp;</span><br></pre></td></tr></table></figure><p>在使用nohup命令时，该程序所有的输出默认会被重定向到一个名为nohup.out的文件中，除非指定了输出文件，比如上面的/home/user/log/xxx.log</p><h4 id="查看进程-amp-杀死进程"><a href="#查看进程-amp-杀死进程" class="headerlink" title="查看进程&amp;杀死进程"></a>查看进程&amp;杀死进程</h4><p>使用命令ps查看进程运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep xxx</span><br></pre></td></tr></table></figure><p>xxx代表命令的关键字，如果命令在运行则可以得到进程的pid</p><p>使用命令kill，杀死进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
      <category term="linux命令" scheme="http://blog.cairui99.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="http://blog.cairui99.cn/2019/12/04/%E9%80%BB%E8%BE%91%E9%A2%98-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/04/逻辑题-赛马问题/</id>
    <published>2019-12-04T03:48:08.000Z</published>
    <updated>2019-12-04T07:03:40.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？</p><a id="more"></a><p>下面是我的思路，不能保证是最优解：</p><ul><li>所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234</li><li>把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123</li><li>将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况：<ul><li>前3名全部来自于第1名的小组，前三名直接晋级，只需比 <strong>10场</strong></li><li>前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 <strong>11场</strong></li></ul></li></ul><p> 题目中问最少，所以答案应是 <strong>10场。</strong></p><p> 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="逻辑题" scheme="http://blog.cairui99.cn/tags/%E9%80%BB%E8%BE%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>检查是否安装某种php扩展</title>
    <link href="http://blog.cairui99.cn/2019/11/27/php-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%9F%90%E7%A7%8Dphp%E6%89%A9%E5%B1%95/"/>
    <id>http://blog.cairui99.cn/2019/11/27/php-检查是否安装某种php扩展/</id>
    <published>2019-11-27T08:21:22.000Z</published>
    <updated>2019-11-27T08:26:37.687Z</updated>
    
    <content type="html"><![CDATA[<p>1、linux下使用命令：php -m 可列出已安装的php扩展</p><p>2、使用phpInfo()函数，可展示已安装的php扩展</p><p>3、使用如下代码验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$extension= <span class="string">''</span>; <span class="comment">//需要验证的某种扩展</span></span><br><span class="line"><span class="keyword">if</span> (extension_loaded($extension)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'开启了扩展'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'没有开启扩展'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、linux下使用命令：php -m 可列出已安装的php扩展&lt;/p&gt;
&lt;p&gt;2、使用phpInfo()函数，可展示已安装的php扩展&lt;/p&gt;
&lt;p&gt;3、使用如下代码验证：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="操作" scheme="http://blog.cairui99.cn/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>区块链与比特币</title>
    <link href="http://blog.cairui99.cn/2019/11/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://blog.cairui99.cn/2019/11/20/区块链与比特币/</id>
    <published>2019-11-20T07:17:39.000Z</published>
    <updated>2020-01-14T11:18:40.878Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/21/M5LtMt.png" alt="M5LtMt.png"></p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>2008年11月1日， <strong>中本聪</strong>（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“<strong>比特币</strong>”的电子货币及其算法，其中实现比特币的底层技术：<strong>chain of blocks</strong> 在最早的比特币白皮书中文翻译版中，将 <strong>chain of blocks</strong> 翻译成了 <strong>区块链</strong>，这是区块链这一中文词的第一次出现。</p><a id="more"></a><h4 id="想要解决的问题"><a href="#想要解决的问题" class="headerlink" title="想要解决的问题"></a>想要解决的问题</h4><p>我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？</p><p>想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。</p><p>好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。</p><p>你也许会问，我依赖第三方机构有什么问题？</p><p>问题在于，你所拥有的不过是清一色的数字，并且修改权不在你：</p><ul><li>要是中央数据库的数据丢失了呢？</li><li>要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？</li><li>要是，他根本就是有意为之呢？你真的可以完全信任他吗？</li></ul><p><strong>多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。</strong></p><p>现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？</p><p>我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？</span><br></pre></td></tr></table></figure><p>是的， <strong>区块链</strong> 就是这个问题的答案，区块链被很多人定义为 <strong>加密的分布式记账技术</strong>，它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。</p><p>下面就来介绍一下这个分散式账簿是如何实现的。</p><h4 id="区块链是如何工作的？"><a href="#区块链是如何工作的？" class="headerlink" title="区块链是如何工作的？"></a>区块链是如何工作的？</h4><p>使用区块链维护账簿的要求是： <strong>必修有足够的人不想依赖第三方，</strong> 至少要三个。</p><p>一个简单的例子，假设有10个人打算使用区块链来维护彼此之间的账簿：</p><p><img src="https://s2.ax1x.com/2019/12/06/QJuHDf.png" alt="QJuHDf.png"></p><p>这10个人一直拥有着彼此的账号信息，但不知道真实身份。</p><h5 id="一个空的文件夹"><a href="#一个空的文件夹" class="headerlink" title="一个空的文件夹"></a>一个空的文件夹</h5><p>一开始的时候，每个人都拥有一个空的文件夹和一些空的纸张。</p><h5 id="一笔交易发生的时候"><a href="#一笔交易发生的时候" class="headerlink" title="一笔交易发生的时候"></a>一笔交易发生的时候</h5><p>在这个网络中的每个人都纸笔在手，随时准备记录下每时每刻发生的任何交易。</p><p>现在假设2号想要给9号转10块钱，于是2号将这个信息广播给所有人，我想转10元钱给9号，大家都记录下来！</p><p><img src="https://s2.ax1x.com/2019/12/06/QJDmzq.png" alt="QJDmzq.png"></p><p>这时收到通知的人都通过历史的交易记录来确认2号是否有足够的余额转账，如果确认2号有足够的钱，每个人都在自己维护的账簿上记录下这笔交易。</p><p><img src="https://s2.ax1x.com/2019/12/09/QwoRoT.png" alt="QwoRoT.png"></p><p>时间过的很快，在这个网络中随时都在发生着交易，为了保证交易的成立，我们需要每隔一段时间更换新的纸张记录新的交易信息，并将上一份交易记录保存起来。</p><p>我将交易记录保存之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。 <strong>密封过后没人能够对这份大家都认同的交易记录做出更改，直至永远。</strong></p><p>如果可以做到这点，那么大家就都可以信任被密封过的交易记录。</p><p><strong>(在比特币中一般把将用来密封交易记录的东西称之为“矿”或者“工作量证明”)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第三方/中介给予我们信任，其形式是：交易发生后账簿不可更改。</span><br><span class="line"></span><br><span class="line">在区块链这样的分散式、去中心化的系统中，这把唯一的钥匙将提供信任替代。</span><br></pre></td></tr></table></figure><h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p>为了让每个人都信任密封过的交易记录无法被更改，那么这一封存手法，就是区块链中交易成立的关键。</p><p>使用到的加密算法： <strong>SHA256加密算法</strong></p><p>sha256简单来说是一种不可逆的加密算法，对于给定的任意长度的输入，sha256都会产生一个256bit长的哈希值，可以先理解为一个hash函数。</p><p><strong>请看下面这个问题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符</span><br><span class="line"></span><br><span class="line">我该从左边输入什么东西进去呢？比如000ab，或者00098，或者000fa</span><br><span class="line"></span><br><span class="line">或者其它情况中的任何一个。</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/02/lYZGff.png" alt="lYZGff.png"></p><p>貌似只有这样一个办法，穷尽宇宙中所有的数字，直到我得到了数字经过sha256之后的值为一个三个0开头的一串字符。</p><p>得到输入值是极端困难的，但是，如果其他人想要验证你的答案是否正确，却是非常容易的。</p><h6 id="如何加密账单？"><a href="#如何加密账单？" class="headerlink" title="如何加密账单？"></a>如何加密账单？</h6><p>能不能找到一个数字，让它加上这张账单中的内容以后的加密输出是一个以三个0开头的字符？为了简化问题，假设20893就是账单的内容：</p><p><img src="https://s2.ax1x.com/2020/01/02/lYyjNd.png" alt="lYyjNd.png"></p><p>在花费许多时间和电力后，我们会偶然发现一个数字，比如21191，符合了我们的要求：</p><p><img src="https://s2.ax1x.com/2020/01/02/lY6m3q.png" alt="lY6m3q.png"></p><p>此时，数字21191就可以作为账单20893的封条，但在此之前，我们还需要区块链网络中大部分人的认可：在网络中，每个人都会进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。</p><p><img src="https://s2.ax1x.com/2020/01/02/lYc3sf.png" alt="lYc3sf.png"></p><p>当有人发布了这个数字之后，每个人都立即验证它是否能产生要求的输出值， <strong>如果大部分人都同意这个密封数字，无论这个数字是什么，都会成为那个可信的密封数字。</strong></p><p>但是，如果对于某人，例如#7，那个被宣布的数字无法产生要求的输出值，此时大部分都同意了这个密封数字，无论错误的原因是什么，#7只有一个选择： <strong>放弃他记录的账单，从其他人处获得拷贝，使他可以用该数字正常密封账单。</strong> 否则他将无法在该网络中继续交易。</p><h6 id="防止对密封数字的修改"><a href="#防止对密封数字的修改" class="headerlink" title="防止对密封数字的修改"></a>防止对密封数字的修改</h6><p>想象现在已经加密好了5份历史账单，而非1份。如果我回溯到第二页纸，改动交易记录企图作弊，会怎么样？</p><p>在我企图花这笔钱的时候，密封数字+账单内容的hash值会让任何人察觉到交易记录的矛盾。那假如我更新一步、在修改完交易记录之后重新计算出了新的密封数字、让其他人无法察觉到我做了修改呢？</p><p>为了防止这个问题的发生，即有人回溯到历史区块修改了其中内容和密封数字，其实除了初始区块，正确的密封数字是这样计算出来的：</p><p>事实上，在计算密封数字时，除了需要加上该区块的转账记录，还需要加上 <strong>前一个区块的sha256输出值。</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYWEpd.png" alt="lYWEpd.png"></p><p>此时可以保证每一个区块都依赖于它的上一个区块，如果有人想要修改一个区块历史记录，那个他将必须改变该区块之后的所有区块的内容以保证链条的一致。但与此同时，在网络中每个人的努力下，新的区块也在不断的增加，作弊者一个人的速度永远无法赶上所有人的速度，导致此次作弊他将无法成功。</p><p>将会发生的事情是，从他可以尝试作弊的那一刻开始，他将要在这个网络中创造出另一条区块链，那它创造的区块链无法赶上可信的区块链，所以在区块链网络中：<strong>最长的链就是可信的链，每一笔交易只允许发生在最长的链上</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYfra8.png" alt="lYfra8.png"></p><p><strong>如果，不是一个人在作弊，而是大部分的人一起作弊呢？</strong></p><p>这种情况下，区块链将会被攻陷，协议将会落空流于表面。</p><p>这种行为被称为 <strong>51%攻击</strong>.</p><h6 id="奖励机制"><a href="#奖励机制" class="headerlink" title="奖励机制"></a>奖励机制</h6><p>我们都知道会有人算出密封数字并公布它，为什么每个人还要耗费资源来进行计算呢？为什么不坐视不理，等着抱大腿呢？</p><p>问题的答案就是激励人们加入到区块链这幅图景的地方：第一个计算出密封数字的人将得到免费的金钱作为对他的努力的奖励。</p><p>这就是比特币变为现实的方式。他是在区块链上被用来交易的第一种货币。当足够的人持有比特币，比特币会升值，升值会使更多人想要得到比特币，这使比特币进一步升值：如此循环往复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“只让人们在比特币带来的交易中获取比特币，或许是有意义的。</span><br><span class="line"></span><br><span class="line">一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009*</span><br></pre></td></tr></table></figure><p>待更新…</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348" target="_blank" rel="noopener">https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/21/M5LtMt.png&quot; alt=&quot;M5LtMt.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h3&gt;&lt;p&gt;2008年11月1日， &lt;strong&gt;中本聪&lt;/strong&gt;（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“&lt;strong&gt;比特币&lt;/strong&gt;”的电子货币及其算法，其中实现比特币的底层技术：&lt;strong&gt;chain of blocks&lt;/strong&gt; 在最早的比特币白皮书中文翻译版中，将 &lt;strong&gt;chain of blocks&lt;/strong&gt; 翻译成了 &lt;strong&gt;区块链&lt;/strong&gt;，这是区块链这一中文词的第一次出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="拓展知识" scheme="http://blog.cairui99.cn/categories/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="区块链" scheme="http://blog.cairui99.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySql-使用explain分析sql</title>
    <link href="http://blog.cairui99.cn/2019/11/14/MySql-%E4%BD%BF%E7%94%A8explain%E5%88%86%E6%9E%90sql/"/>
    <id>http://blog.cairui99.cn/2019/11/14/MySql-使用explain分析sql/</id>
    <published>2019-11-14T05:54:05.000Z</published>
    <updated>2019-11-14T07:22:04.283Z</updated>
    
    <content type="html"><![CDATA[<p>在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。</p><p>Expliain语法：explain + sql语句</p><a id="more"></a><p>Expliain执行后包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+</span><br></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序：</p><ul><li>id相同：执行顺序由上至下执行</li><li>id不同，按id由大到小执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>表示select的类型，包含以下几种：</p><table><thead><tr><th align="center">select_type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">简单SELECT(不使用UNION或子查询等)</td></tr><tr><td align="center">PRIMARY</td><td align="center">最外层的 select 查询(使用到主键作为查询条件)</td></tr><tr><td align="center">UNION</td><td align="center">UNION中的第二个或后面的SELECT语句</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">UNION中的第二个或后面的SELECT语句，取决于外面的查询</td></tr><tr><td align="center">UNION RESULT</td><td align="center">UNION的结果</td></tr><tr><td align="center">SUBQUERY</td><td align="center">子查询中的第一个SELECT,不依赖于外部查询的结果集</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">子查询中的第一个select查询,依赖于外部查询的结果集</td></tr><tr><td align="center">DERIVED</td><td align="center">导出表的SELECT(FROM子句的子查询)</td></tr></tbody></table><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示该条查询的表名</p><p>如果查询是使用了别名，显示的是别名</p><p>如果不涉及数据库表，显示NULL</p><p>如果显示结果别<derived n>这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N</derived></p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。</p><p>常用的几个type： <strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</strong> 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。</p><table><thead><tr><th align="center">type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</td></tr><tr><td align="center">const</td><td align="center">使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</td></tr><tr><td align="center">eq_ref</td><td align="center">出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</td></tr><tr><td align="center">ref</td><td align="center">不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</td></tr><tr><td align="center">fulltext</td><td align="center">全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</td></tr><tr><td align="center">ref_or_null</td><td align="center">与ref方法类似，只是增加了null值的比较。实际用的不多</td></tr><tr><td align="center">unique_subquery</td><td align="center">用于where中的in形式子查询，子查询返回不重复值唯一值</td></tr><tr><td align="center">index_subquery</td><td align="center">用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</td></tr><tr><td align="center">range</td><td align="center">索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</td></tr><tr><td align="center">index_merge</td><td align="center">表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</td></tr><tr><td align="center">index</td><td align="center">索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user</td></tr><tr><td align="center">all</td><td align="center">这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</td></tr></tbody></table><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>显出可能使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询中实际使用到的索引</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示使用哪个列或常数与key一起从表中选择行。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>显示MySQL认为它执行查询时必须检查的行数</p><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。&lt;/p&gt;
&lt;p&gt;Expliain语法：explain + sql语句&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://blog.cairui99.cn/categories/Mysql/"/>
    
    
      <category term="sql优化" scheme="http://blog.cairui99.cn/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习笔记</title>
    <link href="http://blog.cairui99.cn/2019/11/01/go-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.cairui99.cn/2019/11/01/go-go语言学习笔记/</id>
    <published>2019-11-01T06:04:02.000Z</published>
    <updated>2020-04-21T02:54:21.619Z</updated>
    
    <content type="html"><![CDATA[<center>从零开始</center><p><img src="https://s2.ax1x.com/2019/11/01/K7h5QA.png" alt="K7h5QA.png"></p><a id="more"></a><p>参考书籍：<strong>《Go程序设计语言》</strong></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="前往官网下载源码"><a href="#前往官网下载源码" class="headerlink" title="前往官网下载源码"></a>前往官网下载源码</h3><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">点击此处官网</a>(可能需要翻墙)</p><p>根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的</p><p><a href="https://imgchr.com/i/K7XWYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7XWYn.md.png" alt="K7XWYn.md.png"></a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar  -zxvf  go1.13.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建workspace</span><br><span class="line">$ mkdir -p workspace/src</span><br><span class="line"></span><br><span class="line">2.配置环境变量</span><br><span class="line">$ vi ~/.bashrc</span><br><span class="line"></span><br><span class="line">将以下配置添加进bashrc中</span><br><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export GOPATH=$HOME/workspace</span><br><span class="line">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH</span><br><span class="line"></span><br><span class="line">使配置生效</span><br><span class="line">$ source ~/.bashrc</span><br><span class="line"></span><br><span class="line">3.验证是否成功</span><br><span class="line">$ go version</span><br></pre></td></tr></table></figure><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>创建一个 HelloWorld.go 文件 <strong>(注意创建在你的GOPATH目录下)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run HelloWorld.go</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build HelloWorld.go</span><br></pre></td></tr></table></figure><p>此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./HelloWorld</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>下面说一下代码：<br>Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。</p><p>每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。</p><p>package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。</p><p>在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。</p><p>Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句</p><p>Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。</p><h3 id="输出命令行参数"><a href="#输出命令行参数" class="headerlink" title="输出命令行参数"></a>输出命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s, sep <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">s += sep + os.Args[i]</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。</p><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo.go 1 3 -X ?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 3 -X ?</span><br></pre></td></tr></table></figure><p>使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串</p><p>循环变量i在for循环的开始处声明，使用 <strong>:=</strong> 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。</p><p>注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且<strong>左大括号不能独立成行</strong>，必须和前置语句在同一行</p><p>for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中三个部分都是可以省略的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环 while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环这种形式可以通过如break、return等语句进行终止</p><p>还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s, sep := <span class="string">""</span>, <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">s += sep + arg</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义简洁方便，通常在函数内部使用，不适用于包级别的变量</span></span><br><span class="line">s := <span class="string">""</span></span><br><span class="line"><span class="comment">//使用默认初始化值时的定义方式</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="comment">//很少使用，除非定义多个变量时使用</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">""</span></span><br><span class="line"><span class="comment">//在类型不一致时，强调类型使用</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 <strong>_</strong> 这个变量，<strong>_</strong> 在go语言中表示 <strong>空标识符</strong> ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。</p><p>如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果不关心格式或者只是调试程序时，可以直接使用Println：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果和预期很像，只是两边有括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo4.go 1 2 s d ?</span><br><span class="line"></span><br><span class="line">[1 2 s d ?]</span><br></pre></td></tr></table></figure><h3 id="找出重复行"><a href="#找出重复行" class="headerlink" title="找出重复行"></a>找出重复行</h3><h4 id="从控制台输入"><a href="#从控制台输入" class="headerlink" title="从控制台输入"></a>从控制台输入</h4><p>下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>,n,line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup1.go</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">21</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。</p><p>接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。</p><p>在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。</p><p>为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。</p><p>下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。</p><p>例如程序中的 <strong>“%d\t%s\n”</strong>含义为： <strong>%d</strong> 为将一个整数格式化为十进制形式、 <strong>\t</strong> 制表符、 <strong>%s</strong> 把参数输入为字符串、 <strong>\n</strong> 换行符。</p><p>下面给出一些常用的Printf转义字符，Go程序员将其称为verb：</p><table><thead><tr><th align="center">verb</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">十进制整数</td></tr><tr><td align="center">%x, %o, %b</td><td align="center">十六进制、八进制、二进制整数</td></tr><tr><td align="center">%f, %g, %e</td><td align="center">浮点型</td></tr><tr><td align="center">%t</td><td align="center">布尔型</td></tr><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%q</td><td align="center">带引号的字符串(“abc”或者’c’)</td></tr><tr><td align="center">%v</td><td align="center">内置格式的任何值</td></tr><tr><td align="center">%T</td><td align="center">任何值的类型</td></tr><tr><td align="center">%%</td><td align="center">百分号本身</td></tr></tbody></table><h4 id="流式读取文件"><a href="#流式读取文件" class="headerlink" title="流式读取文件"></a>流式读取文件</h4><p>下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">files := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">countLines(os.Stdin, counts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := os.Open(arg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">countLines(f, counts)</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(f)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for test：</p><p>首先创建一个测试文件，名为test.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup2.go test.txt</span><br><span class="line"></span><br><span class="line">3123</span><br><span class="line">212</span><br></pre></td></tr></table></figure><p>os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。</p><p>可以看出 <strong>在go中函数的声明次序是任意的，包括main函数。</strong></p><p>在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。</p><h4 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h4><p>上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。</p><p>下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">data, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup3: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="keyword">string</span>(data), <span class="string">"\n"</span>) &#123;</span><br><span class="line">counts[line]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行方式与结果同dup2.go</p><p>ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。</p><h3 id="获取URL的内容"><a href="#获取URL的内容" class="headerlink" title="获取URL的内容"></a>获取URL的内容</h3><p>程序fetch通过命令行来读取url，通过net包下面的方法来获取指定url的内容，然后不加解析地输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: %v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: reading %s: %v\n"</span>, url, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序使用net/http包的http.Get函数来产生一个HTTP请求，在没有出错的情况下返回结果会保存到resp中，其中resp.Body为一个可读数据流，通过ioutil.ReadAll来读取整个响应结果并存入b，随后关闭Body数据流来避免起源泄露。</p><h3 id="并发获取多个URL的内容"><a href="#并发获取多个URL的内容" class="headerlink" title="并发获取多个URL的内容"></a>并发获取多个URL的内容</h3><p>Go语言的特点之一就是支持并发编程，我们通过下面程序的程序简单了解下go的主要并发机制、goroutine和通道(channel)。<br>下面程序用来从命令行读取很多个URL，并发的获取这些URL的内容，并返回获取每个URL的时间与程序执行的总时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprint(err) <span class="comment">//发送到通道ch</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"while reading %s: %v"</span>, url, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">secs := time.Since(start).Seconds()</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"%.2fs %7d %s"</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="keyword">go</span> fetch(url, ch) <span class="comment">//启动一个goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">//从通道ch接收</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%.2fs elapsed\n"</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run fetchall.go http://www.rong360.com http://www.jd.com http://www.weibo.com http://www.baidu.com</span><br><span class="line"></span><br><span class="line">0.03s  156218 http://www.baidu.com</span><br><span class="line">0.14s  106674 http://www.jd.com</span><br><span class="line">0.15s     611 http://www.weibo.com</span><br><span class="line">0.17s  110858 http://www.rong360.com</span><br><span class="line">0.17s  elapsed</span><br></pre></td></tr></table></figure><p>goroutin是一个并发执行的函数，本质是协程。main函数就是在一个goroutine中执行的，在main中可以使用 <strong>go</strong> 关键字来创建额外的goroutine。goroutine之前可以使用channel来进行通信或者说是数据共享。</p><p>go语言中使用 <strong>chan</strong> 关键字来声明channel，在上面的程序中使用了make创建了一个字符串通道ch，接下来在for循环中每次循环都创建一个新的goroutine，可以实现异步的调用fetch()方法来获取URL内容，在fetch中将读取到的信息传入channel中，在main函数的第二个for循环中依次接收。</p><h3 id="搭建一个Web服务器"><a href="#搭建一个Web服务器" class="headerlink" title="搭建一个Web服务器"></a>搭建一个Web服务器</h3><h4 id="输出url路径"><a href="#输出url路径" class="headerlink" title="输出url路径"></a>输出url路径</h4><p>使用Go的库将很容易实现一个Web服务器，用来响应像fetch那样的客户端请求，下面实现一个迷你服务器，它将展示出访问服务器的URL路径部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理回显请求部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"URL.PATH = %q\n"</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server1.go</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.ax1x.com/2019/11/27/Q9LBGD.png" alt="Q9LBGD.png"></p><p>这个程序只有寥寥几行代码，因为库函数做了大部分工作。main函数中， <strong>http.HandleFunc(“/“, handler)</strong> 代表所有以/开头的URL都将转交给handler这个方法来处理，然后启动服务器开始监听本地4000端口的请求。</p><p>一个请求由一个http.Request类型的结构体表示，其中包含请求的URL(http.Request.URL.Path)，handler函数的操作就是将URL提取出来使用Fprintf输出。</p><h4 id="输出网址的访问数量"><a href="#输出网址的访问数量" class="headerlink" title="输出网址的访问数量"></a>输出网址的访问数量</h4><p>为服务器添加功能很容易，下面的程序实现了当URL为/count时返回到现在为止请求的个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">http.HandleFunc(<span class="string">"/count"</span>, counter)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理程序回显请求的URL的路径部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">count++</span><br><span class="line">mu.Unlock()</span><br><span class="line">fmt.Fprintf(w, <span class="string">"URL.Path = %q\n"</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//counter回显目前为止调用的次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Count %d\n"</span>, count)</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序后台，服务器在不同的goroutine中运行处理函数，这样它可以同时处理多个请求，需要注意的是，在并发请求的情况下可能导致count的计数的不一致，为了避免该问题，所以使用了mu.lock()和mu.Unlock()两个方法对方法加锁，保证goroutine在同一时间最多只有一个对count变量进行操作，实现了共享变量的并发访问。</p><h4 id="输出消息头和表单数据"><a href="#输出消息头和表单数据" class="headerlink" title="输出消息头和表单数据"></a>输出消息头和表单数据</h4><p>下面是一个更完整的例子，处理函数handler可以报告它接收到的消息头和表单数据，这样可以方便服务器审查和调试请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理回显请求部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"%s %s %s\n"</span>, r.Method, r.URL, r.Proto)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Header[%q] = %q\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Host = %q\n"</span>, r.Host)</span><br><span class="line">fmt.Fprintf(w, <span class="string">"RemoteAddr = %q\n"</span>, r.RemoteAddr)</span><br><span class="line"><span class="keyword">if</span> err := r.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Form[%q] = %q\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/12/03/QM7800.png" alt="QM7800.png"></p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>Go中对于函数、变量、常量、类型、语句标签和包名的命名全部遵循一个简单的规则：名称的开头是一个字母或者下划线，并区分大小写，后面可以跟任意字符的字母、数字或下划线。</p><p>Go存在一些不能用来命名的关键字，他们只能用在语法允许的地方：</p><p><img src="https://s2.ax1x.com/2019/12/04/QlsVF1.png" alt="QlsVF1.png"></p><p>另外还有一些内置的预声明的常量、类型和函数，这些名称不属于关键字，我们可以将它们用来命名，但不建议这么做，会有冲突的风险：</p><p><img src="https://s2.ax1x.com/2019/12/04/QlsGFI.png" alt="QlsGFI.png"></p><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>Go中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问(类似于其他语言的public)；如果首字母小写，则只能在本包中使用(类似于其他语言的private)</p><p>在定义结构体时，如果结构体是大写的，则该结构体可以被任意包访问，但无法访问结构体中以小写字母开头定义的参数，如果结构体需要通过json转码，需要注意参数不能使用小写，json无法解析小写字母开头的参数。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Go程序由一个或多个以.go为后缀的文件组成，每一个.go文件以package声明开头，表名文件属于哪个包。package声明后面是import声明，然后是包级别的变量、类型、常量、函数的声明，这4种声明不区分顺序，也是Go程序中主要的4种声明类型。</p><p>例如：下面的程序声明了一个常量、一个函数和一对变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出水的沸点</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = boilingF</span><br><span class="line"><span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"boiling point = %g°F or %g°C\n"</span>, f, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量boilingF是一个包级别的声明，对包中所有源文件可见；变量f和c是属于main函数的局部变量，变量仅在main函数内部可见。</p><p>函数的声明包含一个函数名字，一个参数列表，一个可选的返回值列表（如果无需返回值可省略），以及函数体组成。</p><p>下面的程序封装了温度转换的方法fToC，在其他函数中可以进行多次调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两次华氏-摄氏温度的转换</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> freezingF, boilingF = <span class="number">32.0</span>, <span class="number">212.0</span></span><br><span class="line">fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>,freezingF, fToC(freezingF))</span><br><span class="line">fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>,boilingF,  fToC(boilingF))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fToC</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;从零开始&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/01/K7h5QA.png&quot; alt=&quot;K7h5QA.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.cairui99.cn/categories/Go/"/>
    
    
      <category term="go语言基础" scheme="http://blog.cairui99.cn/tags/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-最少知识原则</title>
    <link href="http://blog.cairui99.cn/2019/11/01/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E6%B3%95%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/11/01/设计原则-最少知识法则/</id>
    <published>2019-11-01T03:31:11.000Z</published>
    <updated>2019-11-01T06:00:02.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最少知识法则也称为迪米特原则，定义为：<strong>一个对象应该对其他对象有最少的了解。</strong></p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>迪米特法则对实现类的低耦合提出了明确的要求，规则如下：</p><h5 id="1-只和直接的朋友通信"><a href="#1-只和直接的朋友通信" class="headerlink" title="1.只和直接的朋友通信"></a>1.只和直接的朋友通信</h5><p>直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。</p><p>类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。</p><h5 id="2-朋友间也需要有距离"><a href="#2-朋友间也需要有距离" class="headerlink" title="2.朋友间也需要有距离"></a>2.朋友间也需要有距离</h5><p>一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。</p><h5 id="3-是自己的就是自己的"><a href="#3-是自己的就是自己的" class="headerlink" title="3.是自己的就是自己的"></a>3.是自己的就是自己的</h5><p>如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;最少知识法则也称为迪米特原则，定义为：&lt;strong&gt;一个对象应该对其他对象有最少的了解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-接口隔离原则</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/10/30/设计原则-接口隔离原则/</id>
    <published>2019-10-30T07:25:09.000Z</published>
    <updated>2019-10-31T12:16:35.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Clients should not be forced to depend upon interfaces that they don’t use.</strong></p><p><strong>“客户端不应该依赖它不需要的接口”</strong>，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。</p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实现接口时尽量做到以下规范：</p><ul><li>接口要做到高内聚：尽量少的公布public方法，降低变更的风险</li><li>定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法</li><li>有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口</li><li>已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理</li><li>接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Clients should not be forced to depend upon interfaces that they don’t use.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户端不应该依赖它不需要的接口”&lt;/strong&gt;，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="http://blog.cairui99.cn/2019/10/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.cairui99.cn/2019/10/18/排序算法-堆排序/</id>
    <published>2019-10-18T02:38:03.000Z</published>
    <updated>2019-10-28T03:31:12.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来设计的一种排序算法。</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将整个数组构建成大根堆</li><li>依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置<ul><li>在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组</li></ul></li><li>当堆中所有元素弹出完毕，此时数组已全部有序</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Heap.buildBigHeap(arr,arr.length,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            Heap.heapPop(arr,arr.length-i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        ArrayUtil.swap(arr,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">        heapFalling(arr,length-<span class="number">2</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向堆中添加一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组中(0 ~ index-1)为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ArrayUtil.swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ArrayUtil.swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最佳时间复杂度：<strong>O(n*logn)</strong> ;</p><p>最差时间复杂度: <strong>O(n*logn)</strong>;</p><p>平均时间复杂度: <strong>O(n*logn)</strong></p><p>空间复杂度: <strong>O(1)</strong></p><h4 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h4><p><strong>不稳定</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h3&gt;&lt;p&gt;堆排序是利用&lt;a href=&quot;https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/&quot;&gt;堆结构&lt;/a&gt;的特点来设计的一种排序算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://blog.cairui99.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="http://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <id>http://blog.cairui99.cn/2019/10/16/数据结构-堆/</id>
    <published>2019-10-16T09:34:42.000Z</published>
    <updated>2020-04-26T09:57:54.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称，堆通常是一个可以被看做一棵完全二叉树的数组对象。</p><a id="more"></a><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>首先堆的结构是一颗 <strong>完全二叉树</strong></p><ul><li><strong>完全二叉树</strong>：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图：<br><img src="https://s2.ax1x.com/2019/10/17/KkXhRO.jpg" alt="KkXhRO.jpg"></li></ul><p>在程序中，我们可以使用数组结构来抽象出一颗完全二叉树：</p><ul><li>数组中的0位置代表根节点</li><li>假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为：<ul><li>左孩子：<strong>2*i+1</strong></li><li>右孩子：<strong>2*i+2</strong></li></ul></li><li>假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为：<ul><li>父节点：<strong>(i-1)/2</strong></li><li>根节点的父节点是自己：(0-1)/2 = 0</li></ul></li></ul><p>使用上面的抽象规则，我们就可以把 <strong>任意数组抽象为一颗完全二叉树。</strong></p><h4 id="构建推结构"><a href="#构建推结构" class="headerlink" title="构建推结构"></a>构建推结构</h4><p>堆分为两种：</p><ul><li>大根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最大值</strong> 都是头部</li><li>小根堆：在一颗完全二叉树中，任何一颗子树的 <strong>最小值</strong> 都是头部</li></ul><p>以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？</p><p><strong>步骤：</strong></p><ul><li>首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中</li><li>后面通过遍历数组，将每个元素依次进堆</li><li>进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止</li><li>数组中所有元素进堆完毕，则大根堆构建完成</li></ul><p>时间复杂度：O(n)</p><h4 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a>弹出堆顶元素</h4><p>在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。</p><p><strong>步骤：</strong></p><ul><li>将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中</li><li>对此时的堆顶元素进行<strong>下沉</strong>操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉)<ul><li>下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子<strong>(如果没有右孩子就不比较，但一定有左孩子)</strong> 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉</li></ul></li><li>堆顶元素下沉完毕后，此时又重新构建好了堆结构</li></ul><p>时间复杂度：O(logn)</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组建立为堆结构</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待处理数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildBigHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            heapInsert(arr,i,heapType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出堆顶元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆在数组中的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heapType 0-&gt;大根堆 , 1-&gt;小根堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 弹出的堆顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapPop</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">        swap(arr,<span class="number">0</span>,length);</span><br><span class="line">        heapFalling(arr,length-<span class="number">1</span>,heapType);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> father = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((arr[index] &lt;= arr[father] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr,index,father);</span><br><span class="line">            index = father;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapFalling</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length,<span class="keyword">int</span> heapType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftChild  = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightChild = <span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//已经在叶子节点了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (leftChild  &gt; length)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//没有右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (rightChild &gt; length) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == <span class="number">0</span>) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有左右孩子，先判断是否需要下沉</span></span><br><span class="line">            <span class="keyword">if</span> (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                    ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//再判断与哪个孩子交换</span></span><br><span class="line">                <span class="keyword">if</span> ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == <span class="number">0</span>) ||</span><br><span class="line">                        (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == <span class="number">1</span>)) &#123;</span><br><span class="line">                    swap(arr,index,leftChild);</span><br><span class="line">                    index = leftChild;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    swap(arr,index,rightChild);</span><br><span class="line">                    index = rightChild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">54</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Heap.buildBigHeap(arr,<span class="number">1</span>);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">        <span class="keyword">int</span> min = Heap.heapPop(arr,arr.length-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(min);</span><br><span class="line">        ArrayUtil.printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h3&gt;&lt;p&gt;堆(Heap)是计算机科学中一类特殊的数据结构的统称，堆通常是一个可以被看做一棵完全二叉树的数组对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
