<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>人类真是毫无长进的生物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2020-06-02T03:36:45.406Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://blog.cairui99.cn/2020/06/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2020/06/01/Java并发编程/</id>
    <published>2020-06-01T02:39:50.000Z</published>
    <updated>2020-06-02T03:36:45.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是并发编程"><a href="#什么是并发编程" class="headerlink" title="什么是并发编程"></a>什么是并发编程</h3><p>并发是指同一个时间段内多个任务同时在执行，此时线程的数量一般是大于CPU核数的，当一个线程占用CPU运行时，其他任务就会被挂起，当占用CPU的线程时间片用完后，会保留当前线程执行的上下文，并把CPU让给其他线程使用。（其中上下文切换是有额外开销的）</p><p>如果是在双CPU配置下，两个线程同时运行，这种情况称为并行运行，而不会并发。</p><h3 id="Java中的线程安全问题"><a href="#Java中的线程安全问题" class="headerlink" title="Java中的线程安全问题"></a>Java中的线程安全问题</h3><p>产生线程安全问题的核心是多个线程间存在 <strong>共享资源：</strong> 共享资源是可以被多个线程所持有或者多个线程可以去访问的资源。</p><p>那么线程间存在共享资源的情况下，何时才会产生线程安全的问题呢？ 如果多个线程都只是读取共享资源，是不会产生线程安全问题的。  <strong>只有当至少一个线程修改共享资源时才会存在线程安全问题，</strong> 例如线程A在操作修改共享资源时，线程B读取到的值是没有同步的，此时线程A的修改结果还没有更新到主内存中，产生了线程安全问题。</p><h3 id="Java中共享变量的内存可见性问题"><a href="#Java中共享变量的内存可见性问题" class="headerlink" title="Java中共享变量的内存可见性问题"></a>Java中共享变量的内存可见性问题</h3><p>首先看看在多线程下的Java内存模型</p><p><img src="https://s1.ax1x.com/2020/06/01/tGHgzR.jpg" alt="tGHgzR.jpg"></p><p>Java内存模型规定，所有的变量都存放在主内存中，当线程使用变量时，会把主内存的变量复制到自己的工作空间或者叫工作内存中，当线程进行读写操作时操作的是自己工作内存中的变量，如果是写操作会在操作后将值更新到主内存的共享变量中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是并发编程&quot;&gt;&lt;a href=&quot;#什么是并发编程&quot; class=&quot;headerlink&quot; title=&quot;什么是并发编程&quot;&gt;&lt;/a&gt;什么是并发编程&lt;/h3&gt;&lt;p&gt;并发是指同一个时间段内多个任务同时在执行，此时线程的数量一般是大于CPU核数的，当一个线程占用CPU
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java注解/</id>
    <published>2020-05-18T09:33:13.000Z</published>
    <updated>2020-05-19T05:42:03.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><p>Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。</p><a id="more"></a><p>注解不同与注释，注解的内容会被嵌入到字节码中，我们可以通过反射来获取到注解内容。</p><h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p><strong>作用在代码里的注解：</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p><strong>作用再其他注解上的注解（元注解）：</strong></p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p><strong>Java7之后新增的注解：</strong></p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><h3 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h3><p><a href="https://imgchr.com/i/Yhn4Vf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/18/Yhn4Vf.jpg" alt="Yhn4Vf.jpg"></a></p><p>可以看到，Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p><p>Annotation 的每一个实现类，都 <strong>和 1 个 RetentionPolicy 关联</strong> 并且 <strong>和 1~n 个 ElementType 关联</strong></p><h3 id="Annotation组成部分"><a href="#Annotation组成部分" class="headerlink" title="Annotation组成部分"></a>Annotation组成部分</h3><p>组成Annotation的三个类分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line"></span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Annotation是个接口，实现类需要实现自该接口。</strong></p><p><strong>ElementType是Enum 枚举类型，它用来指定 Annotation 的类型：</strong> 当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p><p> <strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同：</strong></p><ul><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ul><h3 id="Annotation通用定义"><a href="#Annotation通用定义" class="headerlink" title="Annotation通用定义"></a>Annotation通用定义</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们自定义了一个注解，定义成功后，我们可以在代码中通过@MyAnnotation1来使用它。</p><p>其中@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的：</p><ul><li><strong>@interface</strong> ：使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。<strong>定义 Annotation 时，@interface 是必须的。</strong></li><li><strong>@Documented</strong> : 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</li><li><strong>@Target (ElementType.TYPE)</strong> : 用来指定 Annotation 的类型属性。@Target(ElementType.TYPE)意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。<strong>(定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方)</strong></li><li><strong>@Retention(RetentionPolicy.RUNTIME)</strong>: 指定 Annotation 的策略属性。@Retention(RetentionPolicy.RUNTIME) 的意思就是指编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<strong>(定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS)</strong></li></ul><p>总结：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型（ElementType），@Retention 用来指定 Annotation 的策略（RetentionPolicy）。</p><h3 id="java常用的Annotation"><a href="#java常用的Annotation" class="headerlink" title="java常用的Annotation"></a>java常用的Annotation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>继承性是指：我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了<br>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><p>可以让编译器忽略掉某些警告，例如在方法中添加 <strong>@SuppressWarnings(value={“deprecation”})</strong> 后，在方法中使用了某些不赞成的类或方法时将不在给予警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure><h3 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用"></a>Annotation的作用</h3><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p><p>在编程中经常会使用到的 Annotation 作用有：</p><h4 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h4><p>例如，@SuppressWarnings , @Deprecated 和 @Override 都具有编译检查作用。</p><p>灵活使用注解可以让编译器发现或忽略特定的错误。</p><h4 id="在反射中使用Annotation"><a href="#在反射中使用Annotation" class="headerlink" title="在反射中使用Annotation"></a>在反射中使用Annotation</h4><p>可以通过 Method.getAnnotation(Class);来获取注解信息并使用。</p><h4 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h4><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>可以通过反射来获取到我们自定义的注解，来实现某些功能。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>参考自博客: <a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java注解&quot;&gt;&lt;a href=&quot;#Java注解&quot; class=&quot;headerlink&quot; title=&quot;Java注解&quot;&gt;&lt;/a&gt;Java注解&lt;/h2&gt;&lt;p&gt;Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="注解" scheme="http://blog.cairui99.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java线程基础</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java线程基础/</id>
    <published>2020-05-18T05:57:48.000Z</published>
    <updated>2020-05-24T16:18:23.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>参考书籍：<strong>Java并发编程之美</strong></p><a id="more"></a><h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><p>讨论线程前必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。</p><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源是是把资源分配给进程的，但是CPU资源比较特殊，它是分配给线程的，因为真正要占用CPU资源的是线程，所以也说 <strong>线程是CPU分配的基本单位</strong></p><p>在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是JVM进程中的一个线程，main函数线程也称为 <strong>主线程</strong></p><p><img src="https://s1.ax1x.com/2020/05/17/YRVXZQ.png" alt="YRVXZQ.png"></p><p>可以看到图中一个进程中有多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域。</p><p>程序计数器是用来记录线程当前要执行的指令地址，那为什么要记录呢?前面说了线程是占用CPU执行的基本单位，而CPU一般是使用时间片轮转的方式让线程轮询占用的，所以当前占有CPU资源的线程CPU时间片用完后就要让出CPU资源，等到下次轮到自己时再继续执行，所以此时就需要程序计数器记录该线程让出CPU时的执行地址，等到下次可以继续执行。</p><p>另外每个线程都有自己的栈资源，用于存储该线程的局部变量，这些都是该线程私有的，其他线程访问不了，除此之外还有用来存放线程的调用栈帧。</p><p>堆是进程中最大的一块内存，是所有线程共享的，里面主要存放使用new操作创建的对象实例。</p><p>方法区则用来存放JVM加载的类信息、常量、静态变量等信息，也是线程共享的。</p><h3 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h3><p>线程的创建有三种方式：</p><ul><li>继承Thread类，重写run方法</li><li>实现Runnable接口的run方法</li><li>实现Callable接口的call()方法</li></ul><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是创建线程时线程并没有启动，只有调用start方法时线程才会启动 <strong>（调用start方法后线程会处于就绪状态，需要等待获取cpu资源后才会真正处于运行状态）</strong> ，当run方法执行完毕，线程会处于终止状态。</p><p>使用继承的好处：在run()方法中直接使用this就可以直接获取当前线程；缺点是java不支持多继承，继承Thread类后无法继承其他类。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunableTask task = <span class="keyword">new</span> RunableTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个线程共用了一个task代码逻辑，如果需要可以给RunableTask添加参数进行任务区分，同时RunableTask也可以继承其他类。</p><p>但还是有一个问题，就是任务没有返回值，下面给出实现Callable接口的方式</p><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="comment">//异步获取返回值</span></span><br><span class="line">    String result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set<br>方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线<br>程里面被声明为 final 变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类，<br>那么子类不能再继承其他类，而 Runable 则没有这个限制 。前两种方式都没办法拿到任务<br>的返回结果，但是 Futuretask 方式可以。</p><h3 id="线程的通知与等待"><a href="#线程的通知与等待" class="headerlink" title="线程的通知与等待"></a>线程的通知与等待</h3><p>线程的通知与等待相关的函数使用的是Object类中自带的方法，java中所有的类都可以使用。</p><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h4><p>当一个线程调用一个共享变量的wait()方法时，该调用线程会被 <strong>阻塞挂起</strong>，同时释放掉该共享变量的监视器锁，唤醒被wait()方法挂起的线程的方法是：</p><ul><li>其他线程调用了该共享变量的notify()或notifyAll()方法</li><li>其他线程调用了该线程的interrupt()方法，该线程会抛出InterruptedException异常返回</li></ul><p>如果当前线程在调用共享变量的wait()时没有获取到该共享变量的监视器锁，此时会抛出IllegalMonitorStateException异常，一般使用synchronized关键字来拿到对象的监视器锁。</p><p>需要注意的是，使用wait()方法只会让线程释放掉该共享变量的锁，并不会释放线程持有的其他锁，下面是个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA get resourceA lock"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadA get resourceB lock"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"threadA release resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB get resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"threadB get resourceB lock"</span>);</span><br><span class="line">                            System.out.println(<span class="string">"threadB release resourceA lock"</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待两个线程执行结束</span></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main over"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadA get resourceA lock</span><br><span class="line">threadA get resourceB lock</span><br><span class="line">threadA release resourceA lock</span><br><span class="line">threadB get resourceA lock</span><br></pre></td></tr></table></figure><p>线程A在调用resourceA的wait()方法后释放了它锁持有的resourceA的监视器锁，但没有释放掉它所持有的其他共享变量的锁。</p><h4 id="wait-long-timeout-函数"><a href="#wait-long-timeout-函数" class="headerlink" title="wait(long timeout)函数"></a>wait(long timeout)函数</h4><p>如果线程在timeout的规定时间内没有被其他线程通过notify()或notifyAll()方法唤醒，那么该线程也会因为超时而被唤醒。</p><h4 id="notify-函数"><a href="#notify-函数" class="headerlink" title="notify()函数"></a>notify()函数</h4><p>当一个线程调用共享变量的notify()方法后，会随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。</p><p>被唤醒的线程不一定会继续执行，它必须先获取到共享对象的锁，但该线程可能需要和其他线程共同竞争这把锁。</p><p>同wait()方法，notify()方法也需要在获取到共享变量的监视器锁后，才可以调用，否则会抛异常。</p><h4 id="notifyAll-函数"><a href="#notifyAll-函数" class="headerlink" title="notifyAll()函数"></a>notifyAll()函数</h4><p>唤醒所有在该共享变量上调用wait系列方法被挂起的线程。</p><h3 id="等待线程执行终止的join方法"><a href="#等待线程执行终止的join方法" class="headerlink" title="等待线程执行终止的join方法"></a>等待线程执行终止的join方法</h3><p>join()方法是由Thread类提供的无参、无返回值的方法。</p><p>如果程序需要等待某个或多个线程执行完毕程序再继续往下执行的情况，此时可以用到join()方法来实现。</p><p>比如在main方法中，也是就使用主线程调用线程A的join方法，主线程就会被阻塞，等待线程A执行完毕后，主线程才会继续执行，</p><p>此时如果调用主线程在阻塞过程中调用了interrupt()方法，会抛出InterruptedException异常。</p><h3 id="让线程睡眠的sleep方法"><a href="#让线程睡眠的sleep方法" class="headerlink" title="让线程睡眠的sleep方法"></a>让线程睡眠的sleep方法</h3><p>sleep()是Thread类中的静态方法，调用的线程会让出指定时间的执行权，也就是这期间不参与CPU的调度，<strong>但该线程持有的监视器锁还是持有不让出的，</strong> sleep的执行时间过后，线程就会变为就绪状态，等待CPU的调度然后继续执行。</p><p>线程在sleep期间</p><h3 id="让出CPU执行权的yield方法"><a href="#让出CPU执行权的yield方法" class="headerlink" title="让出CPU执行权的yield方法"></a>让出CPU执行权的yield方法</h3><p>yield()方法是Thread类中的静态方法，相当于告诉线程调度器自己占有的时间片还没有使用完但是自己不想再使用了，暗示线程调度器现在可以进行下一轮的线程调度了。</p><p>当一个线程调用yield方法时，当前线程就会让出CPU使用权，然后变为就绪状态，线程调度器会从就绪队列中获取一个优先级最高的线程来给与CPU的执行权，当前这个优先级最高的线程也可能是刚刚调用yield方法的这个线程。</p><p>总结sleep和yield的区别，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，这期间线程调度器不会去调度该线程；而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到该线程执行。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>java中线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理：</p><ul><li><strong>void interrupt()方法：</strong> 中断线程，例如线程A在运行时，线程B可以调用线程A的interrupt()方法将线程A的中断标志置为true并立即返回，如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起时，线程A会抛出InterruptedException异常返回</li><li><strong>boolean isInterrupted()方法：</strong> 检测当前线程是否被中断</li><li><strong>boolean interrupted()方法：</strong> 检测当前线程是否被中断，与 isInterrupted()不同的是，如果发现线程被中断则清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。</li></ul><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>在多线程环境下，线程个数一般都大于CPU个数，而每个CPU同一时刻只能被一个线程使用，为了让用户感觉到所有线程是同时运行的，CPU资源的分配采用了时间片轮转的策略，也就是为每一个线程分配一个时间片，当前线程时间片用完后，线程会变为就绪状态并让出CPU让其他线程占用，这就是 <strong>上下文切换</strong></p><p>线程上下文切换时机有：</p><ul><li>当前线程的CPU时间片使用完，并处于就绪状态</li><li>当前线程被其他线程中断</li></ul><p>程序计数器会记录当前线程运行到哪里了，待下次执行时可以恢复执行现场。</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><strong>死锁必须具备的四个条件：</strong></p><ul><li>互斥条件：表示该资源同时只能由一个线程占用</li><li>请求并保持条件：指一个线程已经持有了至少一个资源，但又同时再请求新的资源，而新资源已被其他线程占有，当前线程就会被阻塞，并且不会释放自己持有的资源</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占</li><li>环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链</li></ul><p>下面是一个死锁的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main is finish"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get ResourceB</span><br></pre></td></tr></table></figure><p>可以看到程序并没有结束，而是两个线程都在互相请求对方持有的资源，永远的等待下去，构成了死锁状态</p><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>避免线程死锁只需破坏掉至少一个死锁的必要条件即可，目前只有请求并保持和环路等待条件是可以破坏的。</p><p>造成死锁的原因与申请资源的顺序有很大关系，使用资源申请的有序性原则就可以有效的避免死锁。</p><p>在上面死锁的例子中，只需要将线程B的代码进行如下修改，即可避免死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get resourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">main is finish</span><br></pre></td></tr></table></figure><h3 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h3><p>Java中的线程分为两类，分别为 <strong>守护线程</strong> 和 <strong>用户线程</strong> ,在JVM启动时调用main函数所在的线程就是一个用户线程，同时JVM还会启动好多守护线程，例如垃圾回收线程。</p><p>守护线程与用户线程的区别是：</p><ul><li>当最后一个非守护线程结束时，JVM就会正常退出，也就是说守护线程是否结束并不影响JVM的退出。</li></ul><p>在Java中使用下面的方式创建守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread daemonThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程环境下访问同一个共享资源很容易出现并发问题，为了保证线程安全需要对共享变量进行同步。</p><p>同步的措施一般是加锁，但也可以使用ThreadLoacal的方式，使每个线程变量进行访问的时候访问的是自己线程的变量。</p><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有一个这个变量的本地副本，当操作变量时实际操作的是自己本地内存里的变量，从而避免了线程安全的问题。</p><h4 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">        <span class="comment">//localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadOne local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadOne"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadOne remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadTwo local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadTwo"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadTwo remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadTwo remove after:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadOne remove after:threadOne local variable</span><br></pre></td></tr></table></figure><p>去掉print方法中的注释后，输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadTwo remove after:null</span><br><span class="line">threadOne remove after:null</span><br></pre></td></tr></table></figure><p>没写完，待更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程基础&quot;&gt;&lt;a href=&quot;#线程基础&quot; class=&quot;headerlink&quot; title=&quot;线程基础&quot;&gt;&lt;/a&gt;线程基础&lt;/h2&gt;&lt;p&gt;参考书籍：&lt;strong&gt;Java并发编程之美&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://blog.cairui99.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="http://blog.cairui99.cn/2020/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://blog.cairui99.cn/2020/05/03/Java虚拟机/</id>
    <published>2020-05-03T13:39:38.000Z</published>
    <updated>2020-05-10T13:16:24.801Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍：<strong>深入理解java虚拟机（第三版）</strong></p><a id="more"></a><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java虚拟机简单来说就是Java的代码编译好之后，是跑在一台虚拟的机器（VM）上的，这台虚拟的机器负责分配内存和维护调用堆栈。</p><p>为什么要做成虚拟的机器这要从Java的一次编译到处执行来说。事实上一次编译到处执行是不可能的，因为每个机器不一样，所以传统上我们必须针对每一种机器编译代码，才能在这个机器上运行。而Java通过引入虚拟机（VM）的概念，让编译后的代码直接跑在一台虚拟的机器上，无论最终的目标平台是什么，都在上面构建出一个虚拟的一致的虚拟机出来，就可以达到一次编译到处执行的效果了。</p><h2 id="JVM内存模型与内存溢出异常"><a href="#JVM内存模型与内存溢出异常" class="headerlink" title="JVM内存模型与内存溢出异常"></a>JVM内存模型与内存溢出异常</h2><p>与C、C++不同，Java程序不再需要为每一个new操作去写配对的delete/free代码，在java中由JVM来帮忙管理、分配内存。</p><p>虽然jvm来管理内存带来了便利，不过一旦出现内存泄漏和溢出方面的问题，如果不了解java虚拟机是怎么使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>为了更好的理解java虚拟机的内存模型，我们把java虚拟机所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。</p><p>java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图：</p><p><img src="https://s1.ax1x.com/2020/05/03/Ypykhd.jpg" alt="Ypykhd.jpg"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>一块较小的内存空间，是<strong>线程私有</strong>的，可以看作是 <strong>当前线程所执行的字节码的行号指示器</strong></p><p>行号指示器就是在程序执行时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>与程序计数器一样，java虚拟机栈也是 <strong>线程私有的</strong> ，它的生命周期与线程相同。</p><p>虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个 <strong>栈帧</strong> ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。通常我们说的”栈”，一般是指java虚拟机栈中的 <strong>局部变量表</strong> 部分。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF73ZT.png" alt="YF73ZT.png"></p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，例如递归函数没有被正常终止时；</p><p>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）</p><h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行 <strong>方法调用</strong> 和 <strong>方法执行</strong> 的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。</p><p>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。</p><p>在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p><img src="https://s1.ax1x.com/2020/05/05/YFqeiD.png" alt="YFqeiD.png"></p><p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为 <strong>当前栈帧</strong> ，与这个栈帧相关联的方法称为 <strong>当前方法</strong> 。</p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放 <strong>方法参数</strong> 和方法内部定义的 <strong>局部变量</strong> 。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表存放了编译期可知的各种基本数据类型，对象引用(reference类型) 和 returnAddress类型（它指向了一条字节码指令的地址）</p><p><strong>这里的变量仅指方法中的局部变量，成员变量是各个线程共享的，保存在堆中。</strong></p><h5 id="reference（对象实例的引用"><a href="#reference（对象实例的引用" class="headerlink" title="reference（对象实例的引用)"></a>reference（对象实例的引用)</h5><p>类似于一个超链接，如图：</p><p><img src="https://s1.ax1x.com/2020/05/05/YkMUV1.png" alt="YkMUV1.png"></p><h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><p>也就是方法被调用的位置，在方法退出时将返回值传递给上层的方法调用者。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥得作用是相同的。区别是java虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是 <strong>为虚拟机使用到本地（Native）方法服务</strong> 。</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>java堆是虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域。用来 <strong>存放对象实例。</strong></p><p>java堆也是垃圾收集器管理的内存区域，所以java堆中经常出现新生代、老年代、永久代等名词。</p><p>根据虚拟机的规范，java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视作为连续的，类似于磁盘存储。</p><p>java堆是可以实现扩展的，通过参数-Xmx和-Xms设定，如果堆中还没有完成内存分配并且无法扩展时，java虚拟机会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和堆一样，方法区是一块所有线程共享的内存区域。</p><p>方法去用来保存<strong>类的信息</strong>。比如类的字段、方法、常量池等。方法区的大小决定系统可以保存多少个类。如果系统</p><p>定义太多的类，导致方法区溢出。虚拟机同样会抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，用于存放编译期生成的字面量与符号引用。</p><p>字面量相当于java语言中常量的概念；</p><p>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考书籍：&lt;strong&gt;深入理解java虚拟机（第三版）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://blog.cairui99.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitHub_Page自定义域名失效问题</title>
    <link href="http://blog.cairui99.cn/2020/04/28/GitHub-Page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/28/GitHub-Page自定义域名失效问题/</id>
    <published>2020-04-28T14:37:19.000Z</published>
    <updated>2020-04-28T14:40:12.566Z</updated>
    
    <content type="html"><![CDATA[<p>使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置</p><p>解决方法： <strong>在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更新域名了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置&lt;/p&gt;
&lt;p&gt;解决方法： &lt;strong&gt;在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 每日一题</title>
    <link href="http://blog.cairui99.cn/2020/04/26/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/26/LeetCode-每日一题/</id>
    <published>2020-04-26T13:46:10.000Z</published>
    <updated>2020-06-01T07:38:25.383Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode活动：每日一题，看能坚持多久</p><a id="more"></a><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并K个排序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_end = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!is_end) &#123;</span><br><span class="line">            is_end = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">                ListNode listNode = lists[i];</span><br><span class="line">                <span class="keyword">if</span> (listNode != <span class="keyword">null</span> &amp;&amp; listNode.val &lt; min) &#123;</span><br><span class="line">                    is_end = <span class="keyword">false</span>;</span><br><span class="line">                    min = listNode.val;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!is_end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                lists[index] = lists[index].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (front &lt;= back) &#123;</span><br><span class="line">            mid = (front + back) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> scope = <span class="keyword">this</span>.getScope(nums, mid, front, back, target);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">1</span>) &#123;</span><br><span class="line">                back = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">2</span>) &#123;</span><br><span class="line">                front = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缩小target的范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int -1=&gt;不存在，0=&gt;中间，1=&gt;左边, 2=&gt;右边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getScope</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> front, <span class="keyword">int</span> back, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[front];</span><br><span class="line">        <span class="keyword">int</span> right = nums[back];</span><br><span class="line">        <span class="keyword">int</span> middle = nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (middle == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123; <span class="comment">//数组没有被旋转过</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; target &amp;&amp; middle &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &lt; target &amp;&amp; right &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &gt; target &amp;&amp; middle &lt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; target &amp;&amp; middle &gt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中数字出现的次数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            k ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得k中最低位的1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((k &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="comment">//分组</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                answer[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（工作忙，鸽了两天。。。心态崩了）</strong></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-two-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caiui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1.val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2.val;</span><br><span class="line">            min = Math.min(val1, val2);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = val1 &gt;= val2 ? l1 : l1.next;</span><br><span class="line">            l2 = val1 &lt;  val2 ? l2 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nowLength = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(strs[j]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nowLength++;</span><br><span class="line">                    map.put(strs[j], strs[j]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nowLength &gt; maxLength) &#123;</span><br><span class="line">                maxLength = nowLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strs.length - i - <span class="number">1</span>) &lt;= maxLength) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大子序和</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            now = (num + now &lt; <span class="number">0</span>) ? num : num + now;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; max) &#123;</span><br><span class="line">                max = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/jump-game-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> new_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (index + nums[index]); i &gt; index; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                    new_index = nums.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] - count) &gt; max) &#123;</span><br><span class="line">                    max = nums[i] - count;</span><br><span class="line">                    new_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            jump++;</span><br><span class="line">            index = new_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证二叉搜索树</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/validate-binary-search-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution98</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = node.val;</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!helper(node.right, val, upper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(node.left, lower, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h3><p>待优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最低票价</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/minimum-cost-for-tickets/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution983</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getWeekCount(<span class="keyword">int</span>[] days, <span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] weekCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> week = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_day = days[index] + <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> day = days[index++];</span><br><span class="line">            <span class="keyword">if</span> (day &lt;= next_day) &#123;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next_day = next_day + <span class="number">7</span>;</span><br><span class="line">                week++;</span><br><span class="line">                <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weekCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span>[] costs, <span class="keyword">int</span>[] weekCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekCount.length; i++) &#123;</span><br><span class="line">            money += Math.min(weekCount[i] * costs[<span class="number">0</span>], costs[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextMonthIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next_Month_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next_Month = days[index] + <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[i] &gt; next_Month) &#123;</span><br><span class="line">                next_Month_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next_Month_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="comment">//一个月内每周都有多少天</span></span><br><span class="line">            <span class="keyword">int</span>[] weekCount = <span class="keyword">this</span>.getWeekCount(days, index);</span><br><span class="line">            money += Math.min(<span class="keyword">this</span>.getMoney(costs, weekCount), costs[<span class="number">2</span>]);</span><br><span class="line">            index = <span class="keyword">this</span>.getNextMonthIndex(index, days);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pow(x, n)</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/powx-n/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution50</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> pow = x;</span><br><span class="line">        <span class="keyword">long</span> multiple = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (multiple != Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple * <span class="number">2</span> &lt;= Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                pow = pow * pow;</span><br><span class="line">                multiple = multiple * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> temp = pow;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((multiple + (multiple - count)) &gt; Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                    temp = temp / x;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                pow = pow * temp;</span><br><span class="line">                multiple += (multiple - count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (multiple == <span class="number">0</span>) &#123;</span><br><span class="line">                pow = Double.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pow = <span class="number">1</span> / pow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution102</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</span><br><span class="line">                List&lt;TreeNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (nodeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodeList.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode treeNode : nodeList) &#123;</span><br><span class="line">                    integerList.add(treeNode.val);</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.left);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.right);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                answer.add(integerList);</span><br><span class="line">                nodeList = newNodeList;</span><br><span class="line">                <span class="keyword">if</span> (!isContinue) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/single-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            num = num ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a>课程表 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程表 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/course-schedule-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = list.get(prerequisite[<span class="number">0</span>]);</span><br><span class="line">            temp.add(prerequisite[<span class="number">1</span>]);</span><br><span class="line">            list.set(prerequisite[<span class="number">0</span>], temp);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i).size() == <span class="number">0</span> &amp;&amp; map.get(i) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.put(i, i);</span><br><span class="line">                    answer[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> isStudy = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = list.get(i);</span><br><span class="line">                <span class="keyword">int</span> begin = temp.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = temp.get(j);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(num) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isStudy = <span class="keyword">true</span>;</span><br><span class="line">                        temp.remove(j);</span><br><span class="line">                        list.set(i, temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isStudy) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乘积最大子数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-product-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> negativeCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[index++];</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    isZero = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    negativeCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negativeCount % <span class="number">2</span> == <span class="number">0</span> || temp.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">this</span>.getProduct(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ArrayList&lt;Integer&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//第一个负数的位置</span></span><br><span class="line">                <span class="keyword">int</span> negativeIndex = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.get(i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        negativeIndex = (negativeIndex == -<span class="number">1</span>) ? i : negativeIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == negativeCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp1.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = negativeIndex + <span class="number">1</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    temp2.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                negative = Math.max(<span class="keyword">this</span>.getProduct(temp1), <span class="keyword">this</span>.getProduct(temp2));</span><br><span class="line">            &#125;</span><br><span class="line">            answer = Math.max(negative, answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (answer &lt; <span class="number">0</span> &amp;&amp; isZero) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getProduct</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            answer = answer * integer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串-Ⅱ"><a href="#验证回文字符串-Ⅱ" class="headerlink" title="验证回文字符串 Ⅱ"></a>验证回文字符串 Ⅱ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证回文字符串 Ⅱ</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/valid-palindrome-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution680</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back  = strs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front] != strs[back]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(strs, front + <span class="number">1</span>, back)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strs, front, back - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span>[] strs, <span class="keyword">int</span> front, <span class="keyword">int</span> back)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front++] != strs[back--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isOdd = (nums1.length + nums2.length) % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (nums1.length + nums2.length) / <span class="number">2</span>;</span><br><span class="line">        midIndex = isOdd ? midIndex : midIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; nums1.length &amp;&amp; index2 &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">double</span> num = (nums1[index1] &lt;= nums2[index2]) ? nums1[index1++] : nums2[index2++];</span><br><span class="line">            <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() != <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() != <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums = index1 &lt; nums1.length ? nums1 : nums2;</span><br><span class="line">            <span class="keyword">int</span> index = index1 &lt; nums1.length ? index1 : index2;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add((<span class="keyword">double</span>) nums[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : (list.get(<span class="number">0</span>) + list.get(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存机制</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/lru-cache/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; keyList   = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; valueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.valueList.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isExist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                isExist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(i, value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.size() &lt; <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">                <span class="keyword">this</span>.keyList.add(key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.add(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = countMap.get(keyList.get(i));</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; minCount) &#123;</span><br><span class="line">                        minCount = count;</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.keyList.set(index, key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(index, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找重复数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/find-the-duplicate-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution287</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == i &amp;&amp; ++count == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拥有最多糖果的孩子"><a href="#拥有最多糖果的孩子" class="headerlink" title="拥有最多糖果的孩子"></a>拥有最多糖果的孩子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拥有最多糖果的孩子</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1431</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; answerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; candy) &#123;</span><br><span class="line">                max = candy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            answerList.add(candy + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode活动：每日一题，看能坚持多久&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-ping通ip但ping不通域名</title>
    <link href="http://blog.cairui99.cn/2020/02/27/Linux-ping%E9%80%9Aip%E4%BD%86ping%E4%B8%8D%E9%80%9A%E5%9F%9F%E5%90%8D/"/>
    <id>http://blog.cairui99.cn/2020/02/27/Linux-ping通ip但ping不通域名/</id>
    <published>2020-02-27T06:51:10.000Z</published>
    <updated>2020-02-27T06:53:38.384Z</updated>
    
    <content type="html"><![CDATA[<p>原因：机器的域名解析有问题</p><p>解决方法：修改DNS配置</p><ul><li>sudo vi /etc/resolv.conf</li><li>添加  nameserver 8.8.8.8</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原因：机器的域名解析有问题&lt;/p&gt;
&lt;p&gt;解决方法：修改DNS配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sudo vi /etc/resolv.conf&lt;/li&gt;
&lt;li&gt;添加  nameserver 8.8.8.8&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr服务器搭建</title>
    <link href="http://blog.cairui99.cn/2020/01/03/ssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.cairui99.cn/2020/01/03/ssr服务器搭建/</id>
    <published>2020-01-03T07:28:52.000Z</published>
    <updated>2020-02-27T06:50:01.709Z</updated>
    
    <content type="html"><![CDATA[<p>搭建代理服务器前首先要有一台自己的机器，我是在这里办的 <a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a> ，优点是可以随时注销、随时办理，按小时收费。</p><a id="more"></a><p>有了自己的服务器后，登陆进去，依次输入下面几条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>运行成功后，会提示你设置你代理的密码、端口、协议等信息：</p><ul><li>如提示（Please enter password for ShadowsocksR）：设置密码，自己设定</li><li>如提示（Please enter a port for ShadowsocksR [1-65535]）：设置服务器端口，如不设定会随机生成</li><li>如提示（Please select stream cipher for ShadowsocksR）：设置加密方式，建议 <strong>chacha20</strong></li><li>如提示（Please select protocol for ShadowsocksR）：设置协议，默认为 <strong>origin</strong></li><li>如提示（Please select obfs for ShadowsocksR）：选择混淆方式，建议选择 <strong>http_simple</strong></li><li>至此所有配置已经设置完成，等待几分钟，配置成功会显示出所有配置信息，建议截图保存，以免遗忘</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建代理服务器前首先要有一台自己的机器，我是在这里办的 &lt;a href=&quot;https://my.vultr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.vultr.com/&lt;/a&gt; ，优点是可以随时注销、随时办理，按小时收费。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>两条单链表相交的问题</title>
    <link href="http://blog.cairui99.cn/2019/12/16/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%9D%A1%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/16/算法题-两条单链表相交的问题/</id>
    <published>2019-12-16T06:06:14.000Z</published>
    <updated>2019-12-16T06:50:19.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先判断两条单链表是否成环，如果有环则获取到入环节点，然后分情况讨论：</p><ol><li>两条非环单链表：遍历两条链表获取链表的长度，将较长的那条的头节点向后移动两条链表头部的差值，然后两条单链表从头节点同时向后移动：<ul><li>如果产生交点则两条链表相交，返回该节点</li><li>抵达尾部时都没有产生交点则不相交，返回null</li></ul></li><li>一条单链表成环，一条单链表非环：必无交点</li><li>两条成环单链表：<ul><li>入环节点相同，必相交：将入环节点视为终点，此时两条链表可以视为非环单链表，寻找两条单链表的交点时则可以使用两条非环单链表的判断方法找到交点</li><li>入环节点不同，需要判断是否相交：选择其中一条链表的入环节点开始遍历，如果遍历过程中遇到了另一条链表的入环节点，则两条链表相交；如果遍历一整圈都没有相遇则两条链表无交点</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个单链表的头节点,判断是否相交,如果相交返回相交的节点,不相交返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-12-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">isIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode isCyclization1 = isCyclization(head1);</span><br><span class="line">        ListNode isCyclization2 = isCyclization(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCyclization1 == <span class="keyword">null</span> &amp;&amp; isCyclization2 == <span class="keyword">null</span>) &#123; <span class="comment">//两条非环单链表</span></span><br><span class="line">            <span class="keyword">return</span> getIntersect(head1, head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCyclization1 != <span class="keyword">null</span> &amp;&amp; isCyclization2 != <span class="keyword">null</span>) &#123; <span class="comment">//两条成环单链表</span></span><br><span class="line">            <span class="keyword">if</span> (isCyclization1 == isCyclization2) &#123; <span class="comment">//入环节点相同,必相交</span></span><br><span class="line">                ListNode tempNode = isCyclization1.next;</span><br><span class="line">                isCyclization1.next = <span class="keyword">null</span>;</span><br><span class="line">                ListNode resultNode = getIntersect(head1, head2);</span><br><span class="line">                isCyclization1.next = tempNode;</span><br><span class="line">                <span class="keyword">return</span> resultNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//入环节点不同需要判断是否相交</span></span><br><span class="line">                ListNode node = isCyclization1.next;</span><br><span class="line">                <span class="keyword">while</span> (node != isCyclization1) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == isCyclization2) &#123; <span class="comment">//在环中遇到了另一个链表的入环节点,说明两条链表相交</span></span><br><span class="line">                        <span class="keyword">return</span> isCyclization1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表是否成环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入环节点,不成环则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">isCyclization</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用快慢指针判断是否成环</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回入环节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两条非环单链表的交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1Length = getNodeLength(head1);</span><br><span class="line">        <span class="keyword">int</span> node2Length = getNodeLength(head2);</span><br><span class="line">        ListNode longerNode = node1Length &gt; node2Length ? head1 : head2;</span><br><span class="line">        ListNode shortNode  = node1Length &gt; node2Length ? head2 : head1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.abs(node1Length - node2Length); i++) &#123;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (shortNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shortNode == longerNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortNode;</span><br><span class="line">            &#125;</span><br><span class="line">            shortNode  = shortNode.next;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取非环单链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用natapp实现内网穿透功能</title>
    <link href="http://blog.cairui99.cn/2019/12/12/linux-%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://blog.cairui99.cn/2019/12/12/linux-使用natapp实现内网穿透功能/</id>
    <published>2019-12-12T06:07:07.000Z</published>
    <updated>2019-12-31T06:55:31.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单</p><a id="more"></a><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>前往官网 <a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a> 注册账号，并登录</p><p><a href="https://imgchr.com/i/Q4tFIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q4tFIS.md.png" alt="Q4tFIS.md.png"></a></p><h4 id="购买隧道"><a href="#购买隧道" class="headerlink" title="购买隧道"></a>购买隧道</h4><ol><li>登陆成功后，进入个人中心选择购买隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4N9SJ.png" alt="Q4N9SJ.png"></p><ol start="2"><li>个人使用选择：免费隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UK4U.png" alt="Q4UK4U.png"></p><ol start="3"><li>隧道协议选择：Web  点击免费购买（注：免费隧道的域名会随机更换，所以不适合长期使用，这里仅用来测试）</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UDvd.png" alt="Q4UDvd.png"></p><h4 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h4><ol><li>进入官网的客户端下载，选择linux</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q40nsJ.png" alt="Q40nsJ.png"></p><ol start="2"><li>下载并解压，解压后获得一个natapp的文件</li></ol><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>至此环境已经部署完成，下面开始运行natapp</p><h4 id="获取authtoken"><a href="#获取authtoken" class="headerlink" title="获取authtoken"></a>获取authtoken</h4><p>点击我的隧道，可以查看隧道的authtoken，用来启动客户端</p><p><img src="https://s2.ax1x.com/2019/12/17/QoEWbd.png" alt="QoEWbd.png"></p><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h4><p>进入natapp所在目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./natapp -authtoken=xxx</span><br></pre></td></tr></table></figure><p>可以看到客户端启动成功，Forwarding下的网址就是你的外网域名</p><p><img src="https://s2.ax1x.com/2019/12/17/Qot8c4.png" alt="Qot8c4.png"></p><h3 id="后台运行natapp"><a href="#后台运行natapp" class="headerlink" title="后台运行natapp"></a>后台运行natapp</h3><p>直接启动natapp有一个缺点，就是当终端窗口关闭或者ctrl+c的时候natapp进程会被终止，这时需要natapp在后台异步执行</p><p>虽然官网给出了后台运行的方案和教程： <strong>nohup + 命令 + &amp;</strong></p><p>但使用这种方式后我们需要的获取到的域名却不知道上哪里找了，虽然能后台运行了，但获取不到域名我运行你干什么。。。</p><p><strong>解决方案：</strong></p><ul><li>在natapp客户端的同级目录下引入一个config.ini的文件，下载地址：<a href="http://download.natapp.cn/assets/downloads/config.ini" target="_blank" rel="noopener">http://download.natapp.cn/assets/downloads/config.ini</a></li><li>打开config.ini，将<strong>loglevel</strong>的值设置为<strong>INFO</strong></li><li>执行命名：<strong>nohup ./natapp -authtoken=xxx &amp;</strong></li><li>此时在目录下会生成一个nohup.out的日志文件，打开即可查看到你的外网域名</li></ul><p><a href="https://imgchr.com/i/lEFJw8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEFJw8.md.png" alt="lEFJw8.md.png"></a></p><p>使用ps命令查看进程状态，发现natapp已经在后台运行了：<br><a href="https://imgchr.com/i/l12RYt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/31/l12RYt.md.png" alt="l12RYt.md.png"></a></p><p>需要注意的是，免费隧道的域名不是永久有效的，natapp可能随时会将你的域名强制更换，这时还需要到日志中查找最新的域名，所以如果想要稳定的服务还是需要购买付费隧道。</p><p>当然域名换的也不会很频繁，临时测试的话免费的就够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux后台运行php常驻进程</title>
    <link href="http://blog.cairui99.cn/2019/12/11/php-linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cphp%E5%B8%B8%E9%A9%BB%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2019/12/11/php-linux后台运行php常驻进程/</id>
    <published>2019-12-11T06:54:11.000Z</published>
    <updated>2019-12-12T05:56:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行</p><a id="more"></a><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><p>加在一个命令的最后，可以把这个命令放在后台执行</p><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使用 <strong>&amp;</strong> 命令使程序在后台执行，当终端关闭时程序会被终止，这时需要使用nohup命令，可以在你退出账户/关闭终端之后继续运行相应的进程。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohub 命令 &gt; /home/user/log/xxx.log &amp;</span><br></pre></td></tr></table></figure><p>在使用nohup命令时，该程序所有的输出默认会被重定向到一个名为nohup.out的文件中，除非指定了输出文件，比如上面的/home/user/log/xxx.log</p><h4 id="查看进程-amp-杀死进程"><a href="#查看进程-amp-杀死进程" class="headerlink" title="查看进程&amp;杀死进程"></a>查看进程&amp;杀死进程</h4><p>使用命令ps查看进程运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep xxx</span><br></pre></td></tr></table></figure><p>xxx代表命令的关键字，如果命令在运行则可以得到进程的pid</p><p>使用命令kill，杀死进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
      <category term="linux命令" scheme="http://blog.cairui99.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="http://blog.cairui99.cn/2019/12/04/%E9%80%BB%E8%BE%91%E9%A2%98-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/04/逻辑题-赛马问题/</id>
    <published>2019-12-04T03:48:08.000Z</published>
    <updated>2019-12-04T07:03:40.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？</p><a id="more"></a><p>下面是我的思路，不能保证是最优解：</p><ul><li>所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234</li><li>把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123</li><li>将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况：<ul><li>前3名全部来自于第1名的小组，前三名直接晋级，只需比 <strong>10场</strong></li><li>前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 <strong>11场</strong></li></ul></li></ul><p> 题目中问最少，所以答案应是 <strong>10场。</strong></p><p> 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="逻辑题" scheme="http://blog.cairui99.cn/tags/%E9%80%BB%E8%BE%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>复制含有随机指针的链表</title>
    <link href="http://blog.cairui99.cn/2019/12/02/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.cairui99.cn/2019/12/02/算法题-复制含有随机指针的链表/</id>
    <published>2019-12-02T07:30:23.000Z</published>
    <updated>2019-12-03T02:21:14.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>复制含有随机指针节点的链表</p><p>Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandNode next;</span><br><span class="line">    <span class="keyword">public</span> RandNode rand;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。</p><p><strong>进阶：</strong> 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。</p><h3 id="HashMap实现"><a href="#HashMap实现" class="headerlink" title="HashMap实现"></a>HashMap实现</h3><p>使用辅助结构HashMap实现：</p><ul><li>创建一个HashMap，key、value都是RandNode类型</li><li>遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中</li><li>遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点</li><li>重新遍历原链表，将map中所有的value的next、rand指针进行连接</li><li>返回复制后链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">hashMapMethod</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;RandNode, RandNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        map.put(node, copy_node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = map.get(node);</span><br><span class="line">        copy_node.next = map.get(node.next);</span><br><span class="line">        copy_node.rand = map.get(node.rand);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用有限变量实现"><a href="#使用有限变量实现" class="headerlink" title="使用有限变量实现"></a>使用有限变量实现</h3><p>借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表：</p><ul><li>遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null)</li><li>此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点</li><li>下面遍历链表，将所有复制节点的rand指针指向正确的位置</li><li>最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用有限的变量实现 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">randPointNode</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点连到对应原节点后面</span></span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        copy_node.next = node.next;</span><br><span class="line">        node.next = copy_node;</span><br><span class="line">        node = copy_node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置复制节点的rand指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        copy_node.rand = node.rand != <span class="keyword">null</span> ? node.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        node = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点分离出来</span></span><br><span class="line">    RandNode result = head.next;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (copy_node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = copy_node.next;</span><br><span class="line">            copy_node.next = copy_node.next.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            copy_node.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;复制含有随机指针节点的链表&lt;/p&gt;
&lt;p&gt;Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>检查是否安装某种php扩展</title>
    <link href="http://blog.cairui99.cn/2019/11/27/php-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%9F%90%E7%A7%8Dphp%E6%89%A9%E5%B1%95/"/>
    <id>http://blog.cairui99.cn/2019/11/27/php-检查是否安装某种php扩展/</id>
    <published>2019-11-27T08:21:22.000Z</published>
    <updated>2019-11-27T08:26:37.687Z</updated>
    
    <content type="html"><![CDATA[<p>1、linux下使用命令：php -m 可列出已安装的php扩展</p><p>2、使用phpInfo()函数，可展示已安装的php扩展</p><p>3、使用如下代码验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$extension= <span class="string">''</span>; <span class="comment">//需要验证的某种扩展</span></span><br><span class="line"><span class="keyword">if</span> (extension_loaded($extension)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'开启了扩展'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'没有开启扩展'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、linux下使用命令：php -m 可列出已安装的php扩展&lt;/p&gt;
&lt;p&gt;2、使用phpInfo()函数，可展示已安装的php扩展&lt;/p&gt;
&lt;p&gt;3、使用如下代码验证：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="操作" scheme="http://blog.cairui99.cn/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题-单向链表版</title>
    <link href="http://blog.cairui99.cn/2019/11/27/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%89%88/"/>
    <id>http://blog.cairui99.cn/2019/11/27/算法题-荷兰国旗问题-单向链表版/</id>
    <published>2019-11-27T05:39:20.000Z</published>
    <updated>2019-11-28T02:32:53.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。</p><p>进阶：左、中、右三个部分内部需要与原链表顺序一致</p><a id="more"></a><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用辅助数组实现：</p><ul><li>创建一个辅助数组，遍历链表将节点放入数组中</li><li>在数组中调整元素的位置，具体操作可见<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">荷兰国旗问题</a></li><li>在数组中调整好顺序后再将值赋给原链表</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用辅助数组</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(indexMid) &lt; num) &#123;</span><br><span class="line">            swap(list,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(indexMid) == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(list,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        node.value = integer;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = list.get(x);</span><br><span class="line">    list.set(x, list.get(y));</span><br><span class="line">    list.set(y, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作：</p><ul><li>遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点</li><li>将三条子链表头尾连接，变为一条完整的链表返回即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进阶版</span></span><br><span class="line"><span class="comment"> * 保证稳定性，同时空间复杂度达到O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlagListNode</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode less_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode less_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                less_head = head;</span><br><span class="line">                less_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                less_tail.next = head;</span><br><span class="line">                less_tail = less_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eq_head = head;</span><br><span class="line">                eq_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eq_tail.next = head;</span><br><span class="line">                eq_tail = eq_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (more_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                more_head = head;</span><br><span class="line">                more_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                more_tail.next = head;</span><br><span class="line">                more_tail = more_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接小于、等于、大于部分</span></span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (less_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = less_head;</span><br><span class="line">        tail = less_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eq_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = eq_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = eq_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = eq_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = more_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = more_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = more_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部至空，防止链表成环</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="keyword">null</span> &amp;&amp; tail.next != <span class="keyword">null</span>) tail.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。&lt;/p&gt;
&lt;p&gt;进阶：左、中、右三个部分内部需要与原链表顺序一致&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>判断链表是否为回文结构</title>
    <link href="http://blog.cairui99.cn/2019/11/25/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.cairui99.cn/2019/11/25/算法题-判断链表是否为回文结构/</id>
    <published>2019-11-25T03:13:31.000Z</published>
    <updated>2019-11-28T02:33:07.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表的头节点head,请判断该链表是否为回文结构。</p><p>回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构</p><a id="more"></a><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)：</p><ul><li>将链表从头到尾依次入栈</li><li>再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等</li><li>如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈结构</span></span><br><span class="line"><span class="comment"> * 额外空间O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">stackMethod</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)：</p><ul><li>使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点</li><li>将链表的后半部分逆序，同时将中间节点指向null</li><li>此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等</li><li>如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论</li><li>将链表调整为最初的状态(如果需要的话)，然后返回结论</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针+逆序链表</span></span><br><span class="line"><span class="comment"> * 额外空间O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="comment">//链表元素的个数是否为单数</span></span><br><span class="line">    <span class="keyword">boolean</span> isSingular = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//寻找链表的中心点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isSingular = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序链表的后半部分</span></span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSingular) &#123;</span><br><span class="line">        node2 = reverseListNode(slow);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        node2 = reverseListNode(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否是回文结构</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    ListNode tailNode = node2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.value != node2.value) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整链表至最初状态</span></span><br><span class="line">    reverseListNode(tailNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode before = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        node.next = before;</span><br><span class="line">        before = node;</span><br><span class="line">        node = next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个链表的头节点head,请判断该链表是否为回文结构。&lt;/p&gt;
&lt;p&gt;回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>区块链与比特币</title>
    <link href="http://blog.cairui99.cn/2019/11/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://blog.cairui99.cn/2019/11/20/区块链与比特币/</id>
    <published>2019-11-20T07:17:39.000Z</published>
    <updated>2020-01-14T11:18:40.878Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/21/M5LtMt.png" alt="M5LtMt.png"></p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>2008年11月1日， <strong>中本聪</strong>（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“<strong>比特币</strong>”的电子货币及其算法，其中实现比特币的底层技术：<strong>chain of blocks</strong> 在最早的比特币白皮书中文翻译版中，将 <strong>chain of blocks</strong> 翻译成了 <strong>区块链</strong>，这是区块链这一中文词的第一次出现。</p><a id="more"></a><h4 id="想要解决的问题"><a href="#想要解决的问题" class="headerlink" title="想要解决的问题"></a>想要解决的问题</h4><p>我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？</p><p>想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。</p><p>好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。</p><p>你也许会问，我依赖第三方机构有什么问题？</p><p>问题在于，你所拥有的不过是清一色的数字，并且修改权不在你：</p><ul><li>要是中央数据库的数据丢失了呢？</li><li>要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？</li><li>要是，他根本就是有意为之呢？你真的可以完全信任他吗？</li></ul><p><strong>多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。</strong></p><p>现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？</p><p>我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？</span><br></pre></td></tr></table></figure><p>是的， <strong>区块链</strong> 就是这个问题的答案，区块链被很多人定义为 <strong>加密的分布式记账技术</strong>，它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。</p><p>下面就来介绍一下这个分散式账簿是如何实现的。</p><h4 id="区块链是如何工作的？"><a href="#区块链是如何工作的？" class="headerlink" title="区块链是如何工作的？"></a>区块链是如何工作的？</h4><p>使用区块链维护账簿的要求是： <strong>必修有足够的人不想依赖第三方，</strong> 至少要三个。</p><p>一个简单的例子，假设有10个人打算使用区块链来维护彼此之间的账簿：</p><p><img src="https://s2.ax1x.com/2019/12/06/QJuHDf.png" alt="QJuHDf.png"></p><p>这10个人一直拥有着彼此的账号信息，但不知道真实身份。</p><h5 id="一个空的文件夹"><a href="#一个空的文件夹" class="headerlink" title="一个空的文件夹"></a>一个空的文件夹</h5><p>一开始的时候，每个人都拥有一个空的文件夹和一些空的纸张。</p><h5 id="一笔交易发生的时候"><a href="#一笔交易发生的时候" class="headerlink" title="一笔交易发生的时候"></a>一笔交易发生的时候</h5><p>在这个网络中的每个人都纸笔在手，随时准备记录下每时每刻发生的任何交易。</p><p>现在假设2号想要给9号转10块钱，于是2号将这个信息广播给所有人，我想转10元钱给9号，大家都记录下来！</p><p><img src="https://s2.ax1x.com/2019/12/06/QJDmzq.png" alt="QJDmzq.png"></p><p>这时收到通知的人都通过历史的交易记录来确认2号是否有足够的余额转账，如果确认2号有足够的钱，每个人都在自己维护的账簿上记录下这笔交易。</p><p><img src="https://s2.ax1x.com/2019/12/09/QwoRoT.png" alt="QwoRoT.png"></p><p>时间过的很快，在这个网络中随时都在发生着交易，为了保证交易的成立，我们需要每隔一段时间更换新的纸张记录新的交易信息，并将上一份交易记录保存起来。</p><p>我将交易记录保存之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。 <strong>密封过后没人能够对这份大家都认同的交易记录做出更改，直至永远。</strong></p><p>如果可以做到这点，那么大家就都可以信任被密封过的交易记录。</p><p><strong>(在比特币中一般把将用来密封交易记录的东西称之为“矿”或者“工作量证明”)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第三方/中介给予我们信任，其形式是：交易发生后账簿不可更改。</span><br><span class="line"></span><br><span class="line">在区块链这样的分散式、去中心化的系统中，这把唯一的钥匙将提供信任替代。</span><br></pre></td></tr></table></figure><h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p>为了让每个人都信任密封过的交易记录无法被更改，那么这一封存手法，就是区块链中交易成立的关键。</p><p>使用到的加密算法： <strong>SHA256加密算法</strong></p><p>sha256简单来说是一种不可逆的加密算法，对于给定的任意长度的输入，sha256都会产生一个256bit长的哈希值，可以先理解为一个hash函数。</p><p><strong>请看下面这个问题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符</span><br><span class="line"></span><br><span class="line">我该从左边输入什么东西进去呢？比如000ab，或者00098，或者000fa</span><br><span class="line"></span><br><span class="line">或者其它情况中的任何一个。</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/02/lYZGff.png" alt="lYZGff.png"></p><p>貌似只有这样一个办法，穷尽宇宙中所有的数字，直到我得到了数字经过sha256之后的值为一个三个0开头的一串字符。</p><p>得到输入值是极端困难的，但是，如果其他人想要验证你的答案是否正确，却是非常容易的。</p><h6 id="如何加密账单？"><a href="#如何加密账单？" class="headerlink" title="如何加密账单？"></a>如何加密账单？</h6><p>能不能找到一个数字，让它加上这张账单中的内容以后的加密输出是一个以三个0开头的字符？为了简化问题，假设20893就是账单的内容：</p><p><img src="https://s2.ax1x.com/2020/01/02/lYyjNd.png" alt="lYyjNd.png"></p><p>在花费许多时间和电力后，我们会偶然发现一个数字，比如21191，符合了我们的要求：</p><p><img src="https://s2.ax1x.com/2020/01/02/lY6m3q.png" alt="lY6m3q.png"></p><p>此时，数字21191就可以作为账单20893的封条，但在此之前，我们还需要区块链网络中大部分人的认可：在网络中，每个人都会进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。</p><p><img src="https://s2.ax1x.com/2020/01/02/lYc3sf.png" alt="lYc3sf.png"></p><p>当有人发布了这个数字之后，每个人都立即验证它是否能产生要求的输出值， <strong>如果大部分人都同意这个密封数字，无论这个数字是什么，都会成为那个可信的密封数字。</strong></p><p>但是，如果对于某人，例如#7，那个被宣布的数字无法产生要求的输出值，此时大部分都同意了这个密封数字，无论错误的原因是什么，#7只有一个选择： <strong>放弃他记录的账单，从其他人处获得拷贝，使他可以用该数字正常密封账单。</strong> 否则他将无法在该网络中继续交易。</p><h6 id="防止对密封数字的修改"><a href="#防止对密封数字的修改" class="headerlink" title="防止对密封数字的修改"></a>防止对密封数字的修改</h6><p>想象现在已经加密好了5份历史账单，而非1份。如果我回溯到第二页纸，改动交易记录企图作弊，会怎么样？</p><p>在我企图花这笔钱的时候，密封数字+账单内容的hash值会让任何人察觉到交易记录的矛盾。那假如我更新一步、在修改完交易记录之后重新计算出了新的密封数字、让其他人无法察觉到我做了修改呢？</p><p>为了防止这个问题的发生，即有人回溯到历史区块修改了其中内容和密封数字，其实除了初始区块，正确的密封数字是这样计算出来的：</p><p>事实上，在计算密封数字时，除了需要加上该区块的转账记录，还需要加上 <strong>前一个区块的sha256输出值。</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYWEpd.png" alt="lYWEpd.png"></p><p>此时可以保证每一个区块都依赖于它的上一个区块，如果有人想要修改一个区块历史记录，那个他将必须改变该区块之后的所有区块的内容以保证链条的一致。但与此同时，在网络中每个人的努力下，新的区块也在不断的增加，作弊者一个人的速度永远无法赶上所有人的速度，导致此次作弊他将无法成功。</p><p>将会发生的事情是，从他可以尝试作弊的那一刻开始，他将要在这个网络中创造出另一条区块链，那它创造的区块链无法赶上可信的区块链，所以在区块链网络中：<strong>最长的链就是可信的链，每一笔交易只允许发生在最长的链上</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYfra8.png" alt="lYfra8.png"></p><p><strong>如果，不是一个人在作弊，而是大部分的人一起作弊呢？</strong></p><p>这种情况下，区块链将会被攻陷，协议将会落空流于表面。</p><p>这种行为被称为 <strong>51%攻击</strong>.</p><h6 id="奖励机制"><a href="#奖励机制" class="headerlink" title="奖励机制"></a>奖励机制</h6><p>我们都知道会有人算出密封数字并公布它，为什么每个人还要耗费资源来进行计算呢？为什么不坐视不理，等着抱大腿呢？</p><p>问题的答案就是激励人们加入到区块链这幅图景的地方：第一个计算出密封数字的人将得到免费的金钱作为对他的努力的奖励。</p><p>这就是比特币变为现实的方式。他是在区块链上被用来交易的第一种货币。当足够的人持有比特币，比特币会升值，升值会使更多人想要得到比特币，这使比特币进一步升值：如此循环往复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“只让人们在比特币带来的交易中获取比特币，或许是有意义的。</span><br><span class="line"></span><br><span class="line">一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009*</span><br></pre></td></tr></table></figure><p>待更新…</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348" target="_blank" rel="noopener">https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/21/M5LtMt.png&quot; alt=&quot;M5LtMt.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h3&gt;&lt;p&gt;2008年11月1日， &lt;strong&gt;中本聪&lt;/strong&gt;（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“&lt;strong&gt;比特币&lt;/strong&gt;”的电子货币及其算法，其中实现比特币的底层技术：&lt;strong&gt;chain of blocks&lt;/strong&gt; 在最早的比特币白皮书中文翻译版中，将 &lt;strong&gt;chain of blocks&lt;/strong&gt; 翻译成了 &lt;strong&gt;区块链&lt;/strong&gt;，这是区块链这一中文词的第一次出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="拓展知识" scheme="http://blog.cairui99.cn/categories/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="区块链" scheme="http://blog.cairui99.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySql-使用explain分析sql</title>
    <link href="http://blog.cairui99.cn/2019/11/14/MySql-%E4%BD%BF%E7%94%A8explain%E5%88%86%E6%9E%90sql/"/>
    <id>http://blog.cairui99.cn/2019/11/14/MySql-使用explain分析sql/</id>
    <published>2019-11-14T05:54:05.000Z</published>
    <updated>2019-11-14T07:22:04.283Z</updated>
    
    <content type="html"><![CDATA[<p>在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。</p><p>Expliain语法：explain + sql语句</p><a id="more"></a><p>Expliain执行后包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+</span><br></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序：</p><ul><li>id相同：执行顺序由上至下执行</li><li>id不同，按id由大到小执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>表示select的类型，包含以下几种：</p><table><thead><tr><th align="center">select_type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">简单SELECT(不使用UNION或子查询等)</td></tr><tr><td align="center">PRIMARY</td><td align="center">最外层的 select 查询(使用到主键作为查询条件)</td></tr><tr><td align="center">UNION</td><td align="center">UNION中的第二个或后面的SELECT语句</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">UNION中的第二个或后面的SELECT语句，取决于外面的查询</td></tr><tr><td align="center">UNION RESULT</td><td align="center">UNION的结果</td></tr><tr><td align="center">SUBQUERY</td><td align="center">子查询中的第一个SELECT,不依赖于外部查询的结果集</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">子查询中的第一个select查询,依赖于外部查询的结果集</td></tr><tr><td align="center">DERIVED</td><td align="center">导出表的SELECT(FROM子句的子查询)</td></tr></tbody></table><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示该条查询的表名</p><p>如果查询是使用了别名，显示的是别名</p><p>如果不涉及数据库表，显示NULL</p><p>如果显示结果别<derived n>这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N</derived></p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。</p><p>常用的几个type： <strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</strong> 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。</p><table><thead><tr><th align="center">type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</td></tr><tr><td align="center">const</td><td align="center">使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</td></tr><tr><td align="center">eq_ref</td><td align="center">出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</td></tr><tr><td align="center">ref</td><td align="center">不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</td></tr><tr><td align="center">fulltext</td><td align="center">全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</td></tr><tr><td align="center">ref_or_null</td><td align="center">与ref方法类似，只是增加了null值的比较。实际用的不多</td></tr><tr><td align="center">unique_subquery</td><td align="center">用于where中的in形式子查询，子查询返回不重复值唯一值</td></tr><tr><td align="center">index_subquery</td><td align="center">用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</td></tr><tr><td align="center">range</td><td align="center">索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</td></tr><tr><td align="center">index_merge</td><td align="center">表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</td></tr><tr><td align="center">index</td><td align="center">索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user</td></tr><tr><td align="center">all</td><td align="center">这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</td></tr></tbody></table><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>显出可能使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询中实际使用到的索引</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示使用哪个列或常数与key一起从表中选择行。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>显示MySQL认为它执行查询时必须检查的行数</p><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。&lt;/p&gt;
&lt;p&gt;Expliain语法：explain + sql语句&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://blog.cairui99.cn/categories/Mysql/"/>
    
    
      <category term="sql优化" scheme="http://blog.cairui99.cn/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>判断k是否在矩阵中</title>
    <link href="http://blog.cairui99.cn/2019/11/12/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%ADk%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%AD/"/>
    <id>http://blog.cairui99.cn/2019/11/12/算法题-判断k是否在矩阵中/</id>
    <published>2019-11-12T08:23:01.000Z</published>
    <updated>2019-11-28T02:33:14.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：</p><p><img src="https://s2.ax1x.com/2019/11/12/M3ZfoQ.png" alt="M3ZfoQ.png"></p><p>要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点</li><li>假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素</li><li>跟据该特性，判断指针所在位置的元素和整数k的关系：<ul><li>等于k：返回true</li><li>大于k：指针向左移动，如果移动后超过了矩阵边界返回false</li><li>小于k：指针向下移动，如果移动后超过了矩阵边界返回false</li></ul></li><li>重复执行上述步骤，直至函数return</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的.</span></span><br><span class="line"><span class="comment"> * 实现一个函数,判断K是否在matrix中</span></span><br><span class="line"><span class="comment"> * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMatrixNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] &gt; num) &#123;</span><br><span class="line">                index[<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index[<span class="number">0</span>] &gt;= matrix.length || index[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/12/M3ZfoQ.png&quot; alt=&quot;M3ZfoQ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转正方形矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/07/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/07/算法题-旋转正方形矩阵/</id>
    <published>2019-11-07T07:43:14.000Z</published>
    <updated>2019-11-28T02:33:50.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><a id="more"></a><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。&lt;/p&gt;
&lt;p&gt;要求：额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
