<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>欧皇降临</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2020-02-10T03:03:05.916Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssr服务器搭建</title>
    <link href="http://blog.cairui99.cn/2020/01/03/ssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.cairui99.cn/2020/01/03/ssr服务器搭建/</id>
    <published>2020-01-03T07:28:52.000Z</published>
    <updated>2020-02-10T03:03:05.916Z</updated>
    
    <content type="html"><![CDATA[<p>搭建代理服务器前首先要有一台自己的机器，我是在这里办的 <a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a> ，优点是可以随时注销、随时办理，按小时收费。</p><p>有了自己的服务器后，登陆进去，依次输入下面几条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>运行成功后，会提示你设置你代理的密码、端口、协议等信息：</p><ul><li>如提示（Please enter password for ShadowsocksR）：设置密码，自己设定</li><li>如提示（Please enter a port for ShadowsocksR [1-65535]）：设置服务器端口，如不设定会随机生成</li><li>如提示（Please select stream cipher for ShadowsocksR）：设置加密方式，建议 <strong>chacha20</strong></li><li>如提示（Please select protocol for ShadowsocksR）：设置协议，默认为 <strong>origin</strong></li><li>如提示（Please select obfs for ShadowsocksR）：选择混淆方式，建议选择 <strong>http_simple</strong></li><li>至此所有配置已经设置完成，等待几分钟，配置成功会显示出所有配置信息，建议截图保存，以免遗忘</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搭建代理服务器前首先要有一台自己的机器，我是在这里办的 &lt;a href=&quot;https://my.vultr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.vultr.com/&lt;/a&gt; ，优点是可以随时注销、随时办理，按小时收
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>两条单链表相交的问题</title>
    <link href="http://blog.cairui99.cn/2019/12/16/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%A4%E6%9D%A1%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/16/算法题-两条单链表相交的问题/</id>
    <published>2019-12-16T06:06:14.000Z</published>
    <updated>2019-12-16T06:50:19.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先判断两条单链表是否成环，如果有环则获取到入环节点，然后分情况讨论：</p><ol><li>两条非环单链表：遍历两条链表获取链表的长度，将较长的那条的头节点向后移动两条链表头部的差值，然后两条单链表从头节点同时向后移动：<ul><li>如果产生交点则两条链表相交，返回该节点</li><li>抵达尾部时都没有产生交点则不相交，返回null</li></ul></li><li>一条单链表成环，一条单链表非环：必无交点</li><li>两条成环单链表：<ul><li>入环节点相同，必相交：将入环节点视为终点，此时两条链表可以视为非环单链表，寻找两条单链表的交点时则可以使用两条非环单链表的判断方法找到交点</li><li>入环节点不同，需要判断是否相交：选择其中一条链表的入环节点开始遍历，如果遍历过程中遇到了另一条链表的入环节点，则两条链表相交；如果遍历一整圈都没有相遇则两条链表无交点</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个单链表的头节点,判断是否相交,如果相交返回相交的节点,不相交返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-12-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">isIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode isCyclization1 = isCyclization(head1);</span><br><span class="line">        ListNode isCyclization2 = isCyclization(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCyclization1 == <span class="keyword">null</span> &amp;&amp; isCyclization2 == <span class="keyword">null</span>) &#123; <span class="comment">//两条非环单链表</span></span><br><span class="line">            <span class="keyword">return</span> getIntersect(head1, head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCyclization1 != <span class="keyword">null</span> &amp;&amp; isCyclization2 != <span class="keyword">null</span>) &#123; <span class="comment">//两条成环单链表</span></span><br><span class="line">            <span class="keyword">if</span> (isCyclization1 == isCyclization2) &#123; <span class="comment">//入环节点相同,必相交</span></span><br><span class="line">                ListNode tempNode = isCyclization1.next;</span><br><span class="line">                isCyclization1.next = <span class="keyword">null</span>;</span><br><span class="line">                ListNode resultNode = getIntersect(head1, head2);</span><br><span class="line">                isCyclization1.next = tempNode;</span><br><span class="line">                <span class="keyword">return</span> resultNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//入环节点不同需要判断是否相交</span></span><br><span class="line">                ListNode node = isCyclization1.next;</span><br><span class="line">                <span class="keyword">while</span> (node != isCyclization1) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == isCyclization2) &#123; <span class="comment">//在环中遇到了另一个链表的入环节点,说明两条链表相交</span></span><br><span class="line">                        <span class="keyword">return</span> isCyclization1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表是否成环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入环节点,不成环则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">isCyclization</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用快慢指针判断是否成环</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回入环节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两条非环单链表的交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1Length = getNodeLength(head1);</span><br><span class="line">        <span class="keyword">int</span> node2Length = getNodeLength(head2);</span><br><span class="line">        ListNode longerNode = node1Length &gt; node2Length ? head1 : head2;</span><br><span class="line">        ListNode shortNode  = node1Length &gt; node2Length ? head2 : head1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.abs(node1Length - node2Length); i++) &#123;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (shortNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shortNode == longerNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortNode;</span><br><span class="line">            &#125;</span><br><span class="line">            shortNode  = shortNode.next;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取非环单链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用natapp实现内网穿透功能</title>
    <link href="http://blog.cairui99.cn/2019/12/12/linux-%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://blog.cairui99.cn/2019/12/12/linux-使用natapp实现内网穿透功能/</id>
    <published>2019-12-12T06:07:07.000Z</published>
    <updated>2019-12-31T06:55:31.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单</p><a id="more"></a><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>前往官网 <a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a> 注册账号，并登录</p><p><a href="https://imgchr.com/i/Q4tFIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q4tFIS.md.png" alt="Q4tFIS.md.png"></a></p><h4 id="购买隧道"><a href="#购买隧道" class="headerlink" title="购买隧道"></a>购买隧道</h4><ol><li>登陆成功后，进入个人中心选择购买隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4N9SJ.png" alt="Q4N9SJ.png"></p><ol start="2"><li>个人使用选择：免费隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UK4U.png" alt="Q4UK4U.png"></p><ol start="3"><li>隧道协议选择：Web  点击免费购买（注：免费隧道的域名会随机更换，所以不适合长期使用，这里仅用来测试）</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UDvd.png" alt="Q4UDvd.png"></p><h4 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h4><ol><li>进入官网的客户端下载，选择linux</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q40nsJ.png" alt="Q40nsJ.png"></p><ol start="2"><li>下载并解压，解压后获得一个natapp的文件</li></ol><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>至此环境已经部署完成，下面开始运行natapp</p><h4 id="获取authtoken"><a href="#获取authtoken" class="headerlink" title="获取authtoken"></a>获取authtoken</h4><p>点击我的隧道，可以查看隧道的authtoken，用来启动客户端</p><p><img src="https://s2.ax1x.com/2019/12/17/QoEWbd.png" alt="QoEWbd.png"></p><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h4><p>进入natapp所在目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./natapp -authtoken=xxx</span><br></pre></td></tr></table></figure><p>可以看到客户端启动成功，Forwarding下的网址就是你的外网域名</p><p><img src="https://s2.ax1x.com/2019/12/17/Qot8c4.png" alt="Qot8c4.png"></p><h3 id="后台运行natapp"><a href="#后台运行natapp" class="headerlink" title="后台运行natapp"></a>后台运行natapp</h3><p>直接启动natapp有一个缺点，就是当终端窗口关闭或者ctrl+c的时候natapp进程会被终止，这时需要natapp在后台异步执行</p><p>虽然官网给出了后台运行的方案和教程： <strong>nohup + 命令 + &amp;</strong></p><p>但使用这种方式后我们需要的获取到的域名却不知道上哪里找了，虽然能后台运行了，但获取不到域名我运行你干什么。。。</p><p><strong>解决方案：</strong></p><ul><li>在natapp客户端的同级目录下引入一个config.ini的文件，下载地址：<a href="http://download.natapp.cn/assets/downloads/config.ini" target="_blank" rel="noopener">http://download.natapp.cn/assets/downloads/config.ini</a></li><li>打开config.ini，将<strong>loglevel</strong>的值设置为<strong>INFO</strong></li><li>执行命名：<strong>nohup ./natapp -authtoken=xxx &amp;</strong></li><li>此时在目录下会生成一个nohup.out的日志文件，打开即可查看到你的外网域名</li></ul><p><a href="https://imgchr.com/i/lEFJw8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEFJw8.md.png" alt="lEFJw8.md.png"></a></p><p>使用ps命令查看进程状态，发现natapp已经在后台运行了：<br><a href="https://imgchr.com/i/l12RYt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/31/l12RYt.md.png" alt="l12RYt.md.png"></a></p><p>需要注意的是，免费隧道的域名不是永久有效的，natapp可能随时会将你的域名强制更换，这时还需要到日志中查找最新的域名，所以如果想要稳定的服务还是需要购买付费隧道。</p><p>当然域名换的也不会很频繁，临时测试的话免费的就够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux后台运行php常驻进程</title>
    <link href="http://blog.cairui99.cn/2019/12/11/php-linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cphp%E5%B8%B8%E9%A9%BB%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2019/12/11/php-linux后台运行php常驻进程/</id>
    <published>2019-12-11T06:54:11.000Z</published>
    <updated>2019-12-12T05:56:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行</p><a id="more"></a><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><p>加在一个命令的最后，可以把这个命令放在后台执行</p><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使用 <strong>&amp;</strong> 命令使程序在后台执行，当终端关闭时程序会被终止，这时需要使用nohup命令，可以在你退出账户/关闭终端之后继续运行相应的进程。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohub 命令 &gt; /home/user/log/xxx.log &amp;</span><br></pre></td></tr></table></figure><p>在使用nohup命令时，该程序所有的输出默认会被重定向到一个名为nohup.out的文件中，除非指定了输出文件，比如上面的/home/user/log/xxx.log</p><h4 id="查看进程-amp-杀死进程"><a href="#查看进程-amp-杀死进程" class="headerlink" title="查看进程&amp;杀死进程"></a>查看进程&amp;杀死进程</h4><p>使用命令ps查看进程运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep xxx</span><br></pre></td></tr></table></figure><p>xxx代表命令的关键字，如果命令在运行则可以得到进程的pid</p><p>使用命令kill，杀死进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
      <category term="linux命令" scheme="http://blog.cairui99.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="http://blog.cairui99.cn/2019/12/04/%E9%80%BB%E8%BE%91%E9%A2%98-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/04/逻辑题-赛马问题/</id>
    <published>2019-12-04T03:48:08.000Z</published>
    <updated>2019-12-04T07:03:40.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？</p><a id="more"></a><p>下面是我的思路，不能保证是最优解：</p><ul><li>所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234</li><li>把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123</li><li>将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况：<ul><li>前3名全部来自于第1名的小组，前三名直接晋级，只需比 <strong>10场</strong></li><li>前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 <strong>11场</strong></li></ul></li></ul><p> 题目中问最少，所以答案应是 <strong>10场。</strong></p><p> 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="逻辑题" scheme="http://blog.cairui99.cn/tags/%E9%80%BB%E8%BE%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>复制含有随机指针的链表</title>
    <link href="http://blog.cairui99.cn/2019/12/02/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.cairui99.cn/2019/12/02/算法题-复制含有随机指针的链表/</id>
    <published>2019-12-02T07:30:23.000Z</published>
    <updated>2019-12-03T02:21:14.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>复制含有随机指针节点的链表</p><p>Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandNode next;</span><br><span class="line">    <span class="keyword">public</span> RandNode rand;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。</p><p><strong>进阶：</strong> 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。</p><h3 id="HashMap实现"><a href="#HashMap实现" class="headerlink" title="HashMap实现"></a>HashMap实现</h3><p>使用辅助结构HashMap实现：</p><ul><li>创建一个HashMap，key、value都是RandNode类型</li><li>遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中</li><li>遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点</li><li>重新遍历原链表，将map中所有的value的next、rand指针进行连接</li><li>返回复制后链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">hashMapMethod</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;RandNode, RandNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        map.put(node, copy_node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = map.get(node);</span><br><span class="line">        copy_node.next = map.get(node.next);</span><br><span class="line">        copy_node.rand = map.get(node.rand);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用有限变量实现"><a href="#使用有限变量实现" class="headerlink" title="使用有限变量实现"></a>使用有限变量实现</h3><p>借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表：</p><ul><li>遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null)</li><li>此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点</li><li>下面遍历链表，将所有复制节点的rand指针指向正确的位置</li><li>最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用有限的变量实现 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">randPointNode</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点连到对应原节点后面</span></span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        copy_node.next = node.next;</span><br><span class="line">        node.next = copy_node;</span><br><span class="line">        node = copy_node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置复制节点的rand指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        copy_node.rand = node.rand != <span class="keyword">null</span> ? node.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        node = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点分离出来</span></span><br><span class="line">    RandNode result = head.next;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (copy_node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = copy_node.next;</span><br><span class="line">            copy_node.next = copy_node.next.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            copy_node.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;复制含有随机指针节点的链表&lt;/p&gt;
&lt;p&gt;Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>检查是否安装某种php扩展</title>
    <link href="http://blog.cairui99.cn/2019/11/27/php-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%9F%90%E7%A7%8Dphp%E6%89%A9%E5%B1%95/"/>
    <id>http://blog.cairui99.cn/2019/11/27/php-检查是否安装某种php扩展/</id>
    <published>2019-11-27T08:21:22.000Z</published>
    <updated>2019-11-27T08:26:37.687Z</updated>
    
    <content type="html"><![CDATA[<p>1、linux下使用命令：php -m 可列出已安装的php扩展</p><p>2、使用phpInfo()函数，可展示已安装的php扩展</p><p>3、使用如下代码验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$extension= <span class="string">''</span>; <span class="comment">//需要验证的某种扩展</span></span><br><span class="line"><span class="keyword">if</span> (extension_loaded($extension)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'开启了扩展'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'没有开启扩展'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、linux下使用命令：php -m 可列出已安装的php扩展&lt;/p&gt;
&lt;p&gt;2、使用phpInfo()函数，可展示已安装的php扩展&lt;/p&gt;
&lt;p&gt;3、使用如下代码验证：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="操作" scheme="http://blog.cairui99.cn/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>荷兰国旗问题-单向链表版</title>
    <link href="http://blog.cairui99.cn/2019/11/27/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%89%88/"/>
    <id>http://blog.cairui99.cn/2019/11/27/算法题-荷兰国旗问题-单向链表版/</id>
    <published>2019-11-27T05:39:20.000Z</published>
    <updated>2019-11-28T02:32:53.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。</p><p>进阶：左、中、右三个部分内部需要与原链表顺序一致</p><a id="more"></a><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用辅助数组实现：</p><ul><li>创建一个辅助数组，遍历链表将节点放入数组中</li><li>在数组中调整元素的位置，具体操作可见<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">荷兰国旗问题</a></li><li>在数组中调整好顺序后再将值赋给原链表</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用辅助数组</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(indexMid) &lt; num) &#123;</span><br><span class="line">            swap(list,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(indexMid) == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(list,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        node.value = integer;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = list.get(x);</span><br><span class="line">    list.set(x, list.get(y));</span><br><span class="line">    list.set(y, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作：</p><ul><li>遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点</li><li>将三条子链表头尾连接，变为一条完整的链表返回即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进阶版</span></span><br><span class="line"><span class="comment"> * 保证稳定性，同时空间复杂度达到O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlagListNode</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode less_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode less_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                less_head = head;</span><br><span class="line">                less_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                less_tail.next = head;</span><br><span class="line">                less_tail = less_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eq_head = head;</span><br><span class="line">                eq_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eq_tail.next = head;</span><br><span class="line">                eq_tail = eq_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (more_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                more_head = head;</span><br><span class="line">                more_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                more_tail.next = head;</span><br><span class="line">                more_tail = more_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接小于、等于、大于部分</span></span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (less_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = less_head;</span><br><span class="line">        tail = less_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eq_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = eq_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = eq_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = eq_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = more_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = more_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = more_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部至空，防止链表成环</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="keyword">null</span> &amp;&amp; tail.next != <span class="keyword">null</span>) tail.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。&lt;/p&gt;
&lt;p&gt;进阶：左、中、右三个部分内部需要与原链表顺序一致&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>判断链表是否为回文结构</title>
    <link href="http://blog.cairui99.cn/2019/11/25/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/"/>
    <id>http://blog.cairui99.cn/2019/11/25/算法题-判断链表是否为回文结构/</id>
    <published>2019-11-25T03:13:31.000Z</published>
    <updated>2019-11-28T02:33:07.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表的头节点head,请判断该链表是否为回文结构。</p><p>回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构</p><a id="more"></a><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)：</p><ul><li>将链表从头到尾依次入栈</li><li>再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等</li><li>如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈结构</span></span><br><span class="line"><span class="comment"> * 额外空间O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">stackMethod</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)：</p><ul><li>使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点</li><li>将链表的后半部分逆序，同时将中间节点指向null</li><li>此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等</li><li>如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论</li><li>将链表调整为最初的状态(如果需要的话)，然后返回结论</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针+逆序链表</span></span><br><span class="line"><span class="comment"> * 额外空间O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="comment">//链表元素的个数是否为单数</span></span><br><span class="line">    <span class="keyword">boolean</span> isSingular = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//寻找链表的中心点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isSingular = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序链表的后半部分</span></span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSingular) &#123;</span><br><span class="line">        node2 = reverseListNode(slow);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        node2 = reverseListNode(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否是回文结构</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    ListNode tailNode = node2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.value != node2.value) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整链表至最初状态</span></span><br><span class="line">    reverseListNode(tailNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode before = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        node.next = before;</span><br><span class="line">        before = node;</span><br><span class="line">        node = next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个链表的头节点head,请判断该链表是否为回文结构。&lt;/p&gt;
&lt;p&gt;回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="链表" scheme="http://blog.cairui99.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>区块链与比特币</title>
    <link href="http://blog.cairui99.cn/2019/11/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://blog.cairui99.cn/2019/11/20/区块链与比特币/</id>
    <published>2019-11-20T07:17:39.000Z</published>
    <updated>2020-01-14T11:18:40.878Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/11/21/M5LtMt.png" alt="M5LtMt.png"></p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>2008年11月1日， <strong>中本聪</strong>（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“<strong>比特币</strong>”的电子货币及其算法，其中实现比特币的底层技术：<strong>chain of blocks</strong> 在最早的比特币白皮书中文翻译版中，将 <strong>chain of blocks</strong> 翻译成了 <strong>区块链</strong>，这是区块链这一中文词的第一次出现。</p><a id="more"></a><h4 id="想要解决的问题"><a href="#想要解决的问题" class="headerlink" title="想要解决的问题"></a>想要解决的问题</h4><p>我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？</p><p>想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。</p><p>好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。</p><p>你也许会问，我依赖第三方机构有什么问题？</p><p>问题在于，你所拥有的不过是清一色的数字，并且修改权不在你：</p><ul><li>要是中央数据库的数据丢失了呢？</li><li>要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？</li><li>要是，他根本就是有意为之呢？你真的可以完全信任他吗？</li></ul><p><strong>多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。</strong></p><p>现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？</p><p>我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？</span><br></pre></td></tr></table></figure><p>是的， <strong>区块链</strong> 就是这个问题的答案，区块链被很多人定义为 <strong>加密的分布式记账技术</strong>，它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。</p><p>下面就来介绍一下这个分散式账簿是如何实现的。</p><h4 id="区块链是如何工作的？"><a href="#区块链是如何工作的？" class="headerlink" title="区块链是如何工作的？"></a>区块链是如何工作的？</h4><p>使用区块链维护账簿的要求是： <strong>必修有足够的人不想依赖第三方，</strong> 至少要三个。</p><p>一个简单的例子，假设有10个人打算使用区块链来维护彼此之间的账簿：</p><p><img src="https://s2.ax1x.com/2019/12/06/QJuHDf.png" alt="QJuHDf.png"></p><p>这10个人一直拥有着彼此的账号信息，但不知道真实身份。</p><h5 id="一个空的文件夹"><a href="#一个空的文件夹" class="headerlink" title="一个空的文件夹"></a>一个空的文件夹</h5><p>一开始的时候，每个人都拥有一个空的文件夹和一些空的纸张。</p><h5 id="一笔交易发生的时候"><a href="#一笔交易发生的时候" class="headerlink" title="一笔交易发生的时候"></a>一笔交易发生的时候</h5><p>在这个网络中的每个人都纸笔在手，随时准备记录下每时每刻发生的任何交易。</p><p>现在假设2号想要给9号转10块钱，于是2号将这个信息广播给所有人，我想转10元钱给9号，大家都记录下来！</p><p><img src="https://s2.ax1x.com/2019/12/06/QJDmzq.png" alt="QJDmzq.png"></p><p>这时收到通知的人都通过历史的交易记录来确认2号是否有足够的余额转账，如果确认2号有足够的钱，每个人都在自己维护的账簿上记录下这笔交易。</p><p><img src="https://s2.ax1x.com/2019/12/09/QwoRoT.png" alt="QwoRoT.png"></p><p>时间过的很快，在这个网络中随时都在发生着交易，为了保证交易的成立，我们需要每隔一段时间更换新的纸张记录新的交易信息，并将上一份交易记录保存起来。</p><p>我将交易记录保存之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。 <strong>密封过后没人能够对这份大家都认同的交易记录做出更改，直至永远。</strong></p><p>如果可以做到这点，那么大家就都可以信任被密封过的交易记录。</p><p><strong>(在比特币中一般把将用来密封交易记录的东西称之为“矿”或者“工作量证明”)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第三方/中介给予我们信任，其形式是：交易发生后账簿不可更改。</span><br><span class="line"></span><br><span class="line">在区块链这样的分散式、去中心化的系统中，这把唯一的钥匙将提供信任替代。</span><br></pre></td></tr></table></figure><h5 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h5><p>为了让每个人都信任密封过的交易记录无法被更改，那么这一封存手法，就是区块链中交易成立的关键。</p><p>使用到的加密算法： <strong>SHA256加密算法</strong></p><p>sha256简单来说是一种不可逆的加密算法，对于给定的任意长度的输入，sha256都会产生一个256bit长的哈希值，可以先理解为一个hash函数。</p><p><strong>请看下面这个问题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符</span><br><span class="line"></span><br><span class="line">我该从左边输入什么东西进去呢？比如000ab，或者00098，或者000fa</span><br><span class="line"></span><br><span class="line">或者其它情况中的任何一个。</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/01/02/lYZGff.png" alt="lYZGff.png"></p><p>貌似只有这样一个办法，穷尽宇宙中所有的数字，直到我得到了数字经过sha256之后的值为一个三个0开头的一串字符。</p><p>得到输入值是极端困难的，但是，如果其他人想要验证你的答案是否正确，却是非常容易的。</p><h6 id="如何加密账单？"><a href="#如何加密账单？" class="headerlink" title="如何加密账单？"></a>如何加密账单？</h6><p>能不能找到一个数字，让它加上这张账单中的内容以后的加密输出是一个以三个0开头的字符？为了简化问题，假设20893就是账单的内容：</p><p><img src="https://s2.ax1x.com/2020/01/02/lYyjNd.png" alt="lYyjNd.png"></p><p>在花费许多时间和电力后，我们会偶然发现一个数字，比如21191，符合了我们的要求：</p><p><img src="https://s2.ax1x.com/2020/01/02/lY6m3q.png" alt="lY6m3q.png"></p><p>此时，数字21191就可以作为账单20893的封条，但在此之前，我们还需要区块链网络中大部分人的认可：在网络中，每个人都会进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。</p><p><img src="https://s2.ax1x.com/2020/01/02/lYc3sf.png" alt="lYc3sf.png"></p><p>当有人发布了这个数字之后，每个人都立即验证它是否能产生要求的输出值， <strong>如果大部分人都同意这个密封数字，无论这个数字是什么，都会成为那个可信的密封数字。</strong></p><p>但是，如果对于某人，例如#7，那个被宣布的数字无法产生要求的输出值，此时大部分都同意了这个密封数字，无论错误的原因是什么，#7只有一个选择： <strong>放弃他记录的账单，从其他人处获得拷贝，使他可以用该数字正常密封账单。</strong> 否则他将无法在该网络中继续交易。</p><h6 id="防止对密封数字的修改"><a href="#防止对密封数字的修改" class="headerlink" title="防止对密封数字的修改"></a>防止对密封数字的修改</h6><p>想象现在已经加密好了5份历史账单，而非1份。如果我回溯到第二页纸，改动交易记录企图作弊，会怎么样？</p><p>在我企图花这笔钱的时候，密封数字+账单内容的hash值会让任何人察觉到交易记录的矛盾。那假如我更新一步、在修改完交易记录之后重新计算出了新的密封数字、让其他人无法察觉到我做了修改呢？</p><p>为了防止这个问题的发生，即有人回溯到历史区块修改了其中内容和密封数字，其实除了初始区块，正确的密封数字是这样计算出来的：</p><p>事实上，在计算密封数字时，除了需要加上该区块的转账记录，还需要加上 <strong>前一个区块的sha256输出值。</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYWEpd.png" alt="lYWEpd.png"></p><p>此时可以保证每一个区块都依赖于它的上一个区块，如果有人想要修改一个区块历史记录，那个他将必须改变该区块之后的所有区块的内容以保证链条的一致。但与此同时，在网络中每个人的努力下，新的区块也在不断的增加，作弊者一个人的速度永远无法赶上所有人的速度，导致此次作弊他将无法成功。</p><p>将会发生的事情是，从他可以尝试作弊的那一刻开始，他将要在这个网络中创造出另一条区块链，那它创造的区块链无法赶上可信的区块链，所以在区块链网络中：<strong>最长的链就是可信的链，每一笔交易只允许发生在最长的链上</strong></p><p><img src="https://s2.ax1x.com/2020/01/02/lYfra8.png" alt="lYfra8.png"></p><p><strong>如果，不是一个人在作弊，而是大部分的人一起作弊呢？</strong></p><p>这种情况下，区块链将会被攻陷，协议将会落空流于表面。</p><p>这种行为被称为 <strong>51%攻击</strong>.</p><h6 id="奖励机制"><a href="#奖励机制" class="headerlink" title="奖励机制"></a>奖励机制</h6><p>我们都知道会有人算出密封数字并公布它，为什么每个人还要耗费资源来进行计算呢？为什么不坐视不理，等着抱大腿呢？</p><p>问题的答案就是激励人们加入到区块链这幅图景的地方：第一个计算出密封数字的人将得到免费的金钱作为对他的努力的奖励。</p><p>这就是比特币变为现实的方式。他是在区块链上被用来交易的第一种货币。当足够的人持有比特币，比特币会升值，升值会使更多人想要得到比特币，这使比特币进一步升值：如此循环往复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“只让人们在比特币带来的交易中获取比特币，或许是有意义的。</span><br><span class="line"></span><br><span class="line">一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009*</span><br></pre></td></tr></table></figure><p>待更新…</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348" target="_blank" rel="noopener">https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/21/M5LtMt.png&quot; alt=&quot;M5LtMt.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链&quot;&gt;&lt;a href=&quot;#区块链&quot; class=&quot;headerlink&quot; title=&quot;区块链&quot;&gt;&lt;/a&gt;区块链&lt;/h3&gt;&lt;p&gt;2008年11月1日， &lt;strong&gt;中本聪&lt;/strong&gt;（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“&lt;strong&gt;比特币&lt;/strong&gt;”的电子货币及其算法，其中实现比特币的底层技术：&lt;strong&gt;chain of blocks&lt;/strong&gt; 在最早的比特币白皮书中文翻译版中，将 &lt;strong&gt;chain of blocks&lt;/strong&gt; 翻译成了 &lt;strong&gt;区块链&lt;/strong&gt;，这是区块链这一中文词的第一次出现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="拓展知识" scheme="http://blog.cairui99.cn/categories/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="区块链" scheme="http://blog.cairui99.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySql-使用explain分析sql</title>
    <link href="http://blog.cairui99.cn/2019/11/14/MySql-%E4%BD%BF%E7%94%A8explain%E5%88%86%E6%9E%90sql/"/>
    <id>http://blog.cairui99.cn/2019/11/14/MySql-使用explain分析sql/</id>
    <published>2019-11-14T05:54:05.000Z</published>
    <updated>2019-11-14T07:22:04.283Z</updated>
    
    <content type="html"><![CDATA[<p>在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。</p><p>Expliain语法：explain + sql语句</p><a id="more"></a><p>Expliain执行后包含以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+</span><br></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>sql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序：</p><ul><li>id相同：执行顺序由上至下执行</li><li>id不同，按id由大到小执行</li></ul><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>表示select的类型，包含以下几种：</p><table><thead><tr><th align="center">select_type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">简单SELECT(不使用UNION或子查询等)</td></tr><tr><td align="center">PRIMARY</td><td align="center">最外层的 select 查询(使用到主键作为查询条件)</td></tr><tr><td align="center">UNION</td><td align="center">UNION中的第二个或后面的SELECT语句</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">UNION中的第二个或后面的SELECT语句，取决于外面的查询</td></tr><tr><td align="center">UNION RESULT</td><td align="center">UNION的结果</td></tr><tr><td align="center">SUBQUERY</td><td align="center">子查询中的第一个SELECT,不依赖于外部查询的结果集</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">子查询中的第一个select查询,依赖于外部查询的结果集</td></tr><tr><td align="center">DERIVED</td><td align="center">导出表的SELECT(FROM子句的子查询)</td></tr></tbody></table><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>表示该条查询的表名</p><p>如果查询是使用了别名，显示的是别名</p><p>如果不涉及数据库表，显示NULL</p><p>如果显示结果别<derived n>这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N</derived></p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。</p><p>常用的几个type： <strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</strong> 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。</p><table><thead><tr><th align="center">type</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</td></tr><tr><td align="center">const</td><td align="center">使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描</td></tr><tr><td align="center">eq_ref</td><td align="center">出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref</td></tr><tr><td align="center">ref</td><td align="center">不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。</td></tr><tr><td align="center">fulltext</td><td align="center">全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</td></tr><tr><td align="center">ref_or_null</td><td align="center">与ref方法类似，只是增加了null值的比较。实际用的不多</td></tr><tr><td align="center">unique_subquery</td><td align="center">用于where中的in形式子查询，子查询返回不重复值唯一值</td></tr><tr><td align="center">index_subquery</td><td align="center">用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</td></tr><tr><td align="center">range</td><td align="center">索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</td></tr><tr><td align="center">index_merge</td><td align="center">表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</td></tr><tr><td align="center">index</td><td align="center">索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user</td></tr><tr><td align="center">all</td><td align="center">这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</td></tr></tbody></table><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>显出可能使用到的索引</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询中实际使用到的索引</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示使用哪个列或常数与key一起从表中选择行。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>显示MySQL认为它执行查询时必须检查的行数</p><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。&lt;/p&gt;
&lt;p&gt;Expliain语法：explain + sql语句&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://blog.cairui99.cn/categories/Mysql/"/>
    
    
      <category term="sql优化" scheme="http://blog.cairui99.cn/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>判断k是否在矩阵中</title>
    <link href="http://blog.cairui99.cn/2019/11/12/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%88%A4%E6%96%ADk%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E9%98%B5%E4%B8%AD/"/>
    <id>http://blog.cairui99.cn/2019/11/12/算法题-判断k是否在矩阵中/</id>
    <published>2019-11-12T08:23:01.000Z</published>
    <updated>2019-11-28T02:33:14.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：</p><p><img src="https://s2.ax1x.com/2019/11/12/M3ZfoQ.png" alt="M3ZfoQ.png"></p><p>要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点</li><li>假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素</li><li>跟据该特性，判断指针所在位置的元素和整数k的关系：<ul><li>等于k：返回true</li><li>大于k：指针向左移动，如果移动后超过了矩阵边界返回false</li><li>小于k：指针向下移动，如果移动后超过了矩阵边界返回false</li></ul></li><li>重复执行上述步骤，直至函数return</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的.</span></span><br><span class="line"><span class="comment"> * 实现一个函数,判断K是否在matrix中</span></span><br><span class="line"><span class="comment"> * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMatrixNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] &gt; num) &#123;</span><br><span class="line">                index[<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index[<span class="number">0</span>] &gt;= matrix.length || index[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/12/M3ZfoQ.png&quot; alt=&quot;M3ZfoQ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>旋转正方形矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/07/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/07/算法题-旋转正方形矩阵/</id>
    <published>2019-11-07T07:43:14.000Z</published>
    <updated>2019-11-28T02:33:50.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><a id="more"></a><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。&lt;/p&gt;
&lt;p&gt;要求：额外空间复杂度为O(1)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>之字形打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/11/05/%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B9%8B%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/11/05/算法题-之字形打印矩阵/</id>
    <published>2019-11-05T07:43:50.000Z</published>
    <updated>2019-11-28T02:34:13.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：</p><ul><li>1</li><li>2 5</li><li>9 6 3</li><li>4 7 10 13</li><li>14 11 8</li><li>12 15</li><li>16</li></ul><a id="more"></a><p>要求：额外空间复杂度为O(1)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角</li><li>指针A、B每次同时移动一格，移动规则为：<ul><li>指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动</li><li>指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动</li></ul></li><li>在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印)</li><li>最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之字型打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] indexA = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] indexB = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAToB = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            printStraightLine(matrix,indexA,indexB,isAToB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>) &amp;&amp; indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123; <span class="comment">//终点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新A、B坐标</span></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexA[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexA[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexB[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexB[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isAToB = !isAToB;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印点A~B这条线的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStraightLine</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] indexA, <span class="keyword">int</span>[] indexB, <span class="keyword">boolean</span> isAToB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (indexA[<span class="number">0</span>] == indexB[<span class="number">0</span>] &amp;&amp; indexA[<span class="number">1</span>] == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.println(matrix[indexA[<span class="number">0</span>]][indexA[<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能改变数组中的值,用变量代替</span></span><br><span class="line">        <span class="keyword">int</span> x = isAToB ? indexA[<span class="number">0</span>] : indexB[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = isAToB ? indexA[<span class="number">1</span>] : indexB[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isAToB) &#123; <span class="comment">// 从A打印到B</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == indexB[<span class="number">0</span>] &amp;&amp; y == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从B打印到A</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (indexA[<span class="number">0</span>] == x &amp;&amp; indexA[<span class="number">1</span>] == y) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ZigZagPrintMatrix.zigZagPrintMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/11/05/M9pE11.png" alt="M9pE11.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2 5&lt;/li&gt;
&lt;li&gt;9 6 3&lt;/li&gt;
&lt;li&gt;4 7 10 13&lt;/li&gt;
&lt;li&gt;14 11 8&lt;/li&gt;
&lt;li&gt;12 15&lt;/li&gt;
&lt;li&gt;16&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>go语言学习笔记</title>
    <link href="http://blog.cairui99.cn/2019/11/01/go-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.cairui99.cn/2019/11/01/go-go语言学习笔记/</id>
    <published>2019-11-01T06:04:02.000Z</published>
    <updated>2019-12-04T12:22:36.814Z</updated>
    
    <content type="html"><![CDATA[<center>从零开始，持续更新</center><p><img src="https://s2.ax1x.com/2019/11/01/K7h5QA.png" alt="K7h5QA.png"></p><a id="more"></a><p>参考书籍：<strong>《Go程序设计语言》</strong></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><h3 id="前往官网下载源码"><a href="#前往官网下载源码" class="headerlink" title="前往官网下载源码"></a>前往官网下载源码</h3><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">点击此处官网</a>(可能需要翻墙)</p><p>根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的</p><p><a href="https://imgchr.com/i/K7XWYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7XWYn.md.png" alt="K7XWYn.md.png"></a></p><h3 id="解压并安装"><a href="#解压并安装" class="headerlink" title="解压并安装"></a>解压并安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar  -zxvf  go1.13.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.创建workspace</span><br><span class="line">$ mkdir -p workspace/src</span><br><span class="line"></span><br><span class="line">2.配置环境变量</span><br><span class="line">$ vi ~/.bashrc</span><br><span class="line"></span><br><span class="line">将以下配置添加进bashrc中</span><br><span class="line">export GOROOT=$HOME/go</span><br><span class="line">export GOPATH=$HOME/workspace</span><br><span class="line">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH</span><br><span class="line"></span><br><span class="line">使配置生效</span><br><span class="line">$ source ~/.bashrc</span><br><span class="line"></span><br><span class="line">3.验证是否成功</span><br><span class="line">$ go version</span><br></pre></td></tr></table></figure><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>创建一个 HelloWorld.go 文件 <strong>(注意创建在你的GOPATH目录下)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run HelloWorld.go</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build HelloWorld.go</span><br></pre></td></tr></table></figure><p>此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./HelloWorld</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>下面说一下代码：<br>Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。</p><p>每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。</p><p>package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。</p><p>在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。</p><p>Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句</p><p>Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。</p><h3 id="输出命令行参数"><a href="#输出命令行参数" class="headerlink" title="输出命令行参数"></a>输出命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s, sep <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(os.Args); i++ &#123;</span><br><span class="line">s += sep + os.Args[i]</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。</p><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo.go 1 3 -X ?</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1 3 -X ?</span><br></pre></td></tr></table></figure><p>使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串</p><p>循环变量i在for循环的开始处声明，使用 <strong>:=</strong> 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。</p><p>注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且<strong>左大括号不能独立成行</strong>，必须和前置语句在同一行</p><p>for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的for循环</span></span><br><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中三个部分都是可以省略的，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的while循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环 while(true)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限循环这种形式可以通过如break、return等语句进行终止</p><p>还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s, sep := <span class="string">""</span>, <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">s += sep + arg</span><br><span class="line">sep = <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义简洁方便，通常在函数内部使用，不适用于包级别的变量</span></span><br><span class="line">s := <span class="string">""</span></span><br><span class="line"><span class="comment">//使用默认初始化值时的定义方式</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="comment">//很少使用，除非定义多个变量时使用</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">""</span></span><br><span class="line"><span class="comment">//在类型不一致时，强调类型使用</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure><p>在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 <strong>_</strong> 这个变量，<strong>_</strong> 在go语言中表示 <strong>空标识符</strong> ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。</p><p>如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.Join(os.Args[<span class="number">1</span>:], <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果不关心格式或者只是调试程序时，可以直接使用Println：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果和预期很像，只是两边有括号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run echo4.go 1 2 s d ?</span><br><span class="line"></span><br><span class="line">[1 2 s d ?]</span><br></pre></td></tr></table></figure><h3 id="找出重复行"><a href="#找出重复行" class="headerlink" title="找出重复行"></a>找出重复行</h3><h4 id="从控制台输入"><a href="#从控制台输入" class="headerlink" title="从控制台输入"></a>从控制台输入</h4><p>下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>,n,line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup1.go</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">21</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。</p><p>接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。</p><p>在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。</p><p>为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。</p><p>下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。</p><p>例如程序中的 <strong>“%d\t%s\n”</strong>含义为： <strong>%d</strong> 为将一个整数格式化为十进制形式、 <strong>\t</strong> 制表符、 <strong>%s</strong> 把参数输入为字符串、 <strong>\n</strong> 换行符。</p><p>下面给出一些常用的Printf转义字符，Go程序员将其称为verb：</p><table><thead><tr><th align="center">verb</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">十进制整数</td></tr><tr><td align="center">%x, %o, %b</td><td align="center">十六进制、八进制、二进制整数</td></tr><tr><td align="center">%f, %g, %e</td><td align="center">浮点型</td></tr><tr><td align="center">%t</td><td align="center">布尔型</td></tr><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%q</td><td align="center">带引号的字符串(“abc”或者’c’)</td></tr><tr><td align="center">%v</td><td align="center">内置格式的任何值</td></tr><tr><td align="center">%T</td><td align="center">任何值的类型</td></tr><tr><td align="center">%%</td><td align="center">百分号本身</td></tr></tbody></table><h4 id="流式读取文件"><a href="#流式读取文件" class="headerlink" title="流式读取文件"></a>流式读取文件</h4><p>下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">files := os.Args[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(files) == <span class="number">0</span> &#123;</span><br><span class="line">countLines(os.Stdin, counts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">f, err := os.Open(arg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup2: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">countLines(f, counts)</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countLines</span><span class="params">(f *os.File, counts <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">input := bufio.NewScanner(f)</span><br><span class="line"><span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line"><span class="keyword">if</span> input.Text() == <span class="string">"end"</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">counts[input.Text()]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for test：</p><p>首先创建一个测试文件，名为test.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run dup2.go test.txt</span><br><span class="line"></span><br><span class="line">3123</span><br><span class="line">212</span><br></pre></td></tr></table></figure><p>os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。</p><p>可以看出 <strong>在go中函数的声明次序是任意的，包括main函数。</strong></p><p>在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。</p><h4 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h4><p>上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。</p><p>下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">data, err := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"dup3: %v\n"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(<span class="keyword">string</span>(data), <span class="string">"\n"</span>) &#123;</span><br><span class="line">counts[line]++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d\t%s\n"</span>, n, line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行方式与结果同dup2.go</p><p>ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。</p><h3 id="获取URL的内容"><a href="#获取URL的内容" class="headerlink" title="获取URL的内容"></a>获取URL的内容</h3><p>程序fetch通过命令行来读取url，通过net包下面的方法来获取指定url的内容，然后不加解析地输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: %v\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">b, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"fetch: reading %s: %v\n"</span>, url, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s"</span>, b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序使用net/http包的http.Get函数来产生一个HTTP请求，在没有出错的情况下返回结果会保存到resp中，其中resp.Body为一个可读数据流，通过ioutil.ReadAll来读取整个响应结果并存入b，随后关闭Body数据流来避免起源泄露。</p><h3 id="并发获取多个URL的内容"><a href="#并发获取多个URL的内容" class="headerlink" title="并发获取多个URL的内容"></a>并发获取多个URL的内容</h3><p>Go语言的特点之一就是支持并发编程，我们通过下面程序的程序简单了解下go的主要并发机制、goroutine和通道(channel)。<br>下面程序用来从命令行读取很多个URL，并发的获取这些URL的内容，并返回获取每个URL的时间与程序执行的总时间</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetch</span><span class="params">(url <span class="keyword">string</span>, ch <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprint(err) <span class="comment">//发送到通道ch</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">nbytes, err := io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"while reading %s: %v"</span>, url, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">secs := time.Since(start).Seconds()</span><br><span class="line">ch &lt;- fmt.Sprintf(<span class="string">"%.2fs %7d %s"</span>, secs, nbytes, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line"><span class="keyword">go</span> fetch(url, ch) <span class="comment">//启动一个goroutine</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> os.Args[<span class="number">1</span>:] &#123;</span><br><span class="line">fmt.Println(&lt;-ch) <span class="comment">//从通道ch接收</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%.2fs elapsed\n"</span>, time.Since(start).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run fetchall.go http://www.rong360.com http://www.jd.com http://www.weibo.com http://www.baidu.com</span><br><span class="line"></span><br><span class="line">0.03s  156218 http://www.baidu.com</span><br><span class="line">0.14s  106674 http://www.jd.com</span><br><span class="line">0.15s     611 http://www.weibo.com</span><br><span class="line">0.17s  110858 http://www.rong360.com</span><br><span class="line">0.17s  elapsed</span><br></pre></td></tr></table></figure><p>goroutin是一个并发执行的函数，本质是协程。main函数就是在一个goroutine中执行的，在main中可以使用 <strong>go</strong> 关键字来创建额外的goroutine。goroutine之前可以使用channel来进行通信或者说是数据共享。</p><p>go语言中使用 <strong>chan</strong> 关键字来声明channel，在上面的程序中使用了make创建了一个字符串通道ch，接下来在for循环中每次循环都创建一个新的goroutine，可以实现异步的调用fetch()方法来获取URL内容，在fetch中将读取到的信息传入channel中，在main函数的第二个for循环中依次接收。</p><h3 id="搭建一个Web服务器"><a href="#搭建一个Web服务器" class="headerlink" title="搭建一个Web服务器"></a>搭建一个Web服务器</h3><h4 id="输出url路径"><a href="#输出url路径" class="headerlink" title="输出url路径"></a>输出url路径</h4><p>使用Go的库将很容易实现一个Web服务器，用来响应像fetch那样的客户端请求，下面实现一个迷你服务器，它将展示出访问服务器的URL路径部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理回显请求部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"URL.PATH = %q\n"</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run server1.go</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.ax1x.com/2019/11/27/Q9LBGD.png" alt="Q9LBGD.png"></p><p>这个程序只有寥寥几行代码，因为库函数做了大部分工作。main函数中， <strong>http.HandleFunc(“/“, handler)</strong> 代表所有以/开头的URL都将转交给handler这个方法来处理，然后启动服务器开始监听本地4000端口的请求。</p><p>一个请求由一个http.Request类型的结构体表示，其中包含请求的URL(http.Request.URL.Path)，handler函数的操作就是将URL提取出来使用Fprintf输出。</p><h4 id="输出网址的访问数量"><a href="#输出网址的访问数量" class="headerlink" title="输出网址的访问数量"></a>输出网址的访问数量</h4><p>为服务器添加功能很容易，下面的程序实现了当URL为/count时返回到现在为止请求的个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">http.HandleFunc(<span class="string">"/count"</span>, counter)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理程序回显请求的URL的路径部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">count++</span><br><span class="line">mu.Unlock()</span><br><span class="line">fmt.Fprintf(w, <span class="string">"URL.Path = %q\n"</span>, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//counter回显目前为止调用的次数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Count %d\n"</span>, count)</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序后台，服务器在不同的goroutine中运行处理函数，这样它可以同时处理多个请求，需要注意的是，在并发请求的情况下可能导致count的计数的不一致，为了避免该问题，所以使用了mu.lock()和mu.Unlock()两个方法对方法加锁，保证goroutine在同一时间最多只有一个对count变量进行操作，实现了共享变量的并发访问。</p><h4 id="输出消息头和表单数据"><a href="#输出消息头和表单数据" class="headerlink" title="输出消息头和表单数据"></a>输出消息头和表单数据</h4><p>下面是一个更完整的例子，处理函数handler可以报告它接收到的消息头和表单数据，这样可以方便服务器审查和调试请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">"localhost:4000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理回显请求部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"%s %s %s\n"</span>, r.Method, r.URL, r.Proto)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Header[%q] = %q\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Host = %q\n"</span>, r.Host)</span><br><span class="line">fmt.Fprintf(w, <span class="string">"RemoteAddr = %q\n"</span>, r.RemoteAddr)</span><br><span class="line"><span class="keyword">if</span> err := r.ParseForm(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Print(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Form[%q] = %q\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/12/03/QM7800.png" alt="QM7800.png"></p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>Go中对于函数、变量、常量、类型、语句标签和包名的命名全部遵循一个简单的规则：名称的开头是一个字母或者下划线，并区分大小写，后面可以跟任意字符的字母、数字或下划线。</p><p>Go存在一些不能用来命名的关键字，他们只能用在语法允许的地方：</p><p><img src="https://s2.ax1x.com/2019/12/04/QlsVF1.png" alt="QlsVF1.png"></p><p>另外还有一些内置的预声明的常量、类型和函数，这些名称不属于关键字，我们可以将它们用来命名，但不建议这么做，会有冲突的风险：</p><p><img src="https://s2.ax1x.com/2019/12/04/QlsGFI.png" alt="QlsGFI.png"></p><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>Go中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问(类似于其他语言的public)；如果首字母小写，则只能在本包中使用(类似于其他语言的private)</p><p>在定义结构体时，如果结构体是大写的，则该结构体可以被任意包访问，但无法访问结构体中以小写字母开头定义的参数，如果结构体需要通过json转码，需要注意参数不能使用小写，json无法解析小写字母开头的参数。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Go程序由一个或多个以.go为后缀的文件组成，每一个.go文件以package声明开头，表名文件属于哪个包。package声明后面是import声明，然后是包级别的变量、类型、常量、函数的声明，这4种声明不区分顺序，也是Go程序中主要的4种声明类型。</p><p>例如：下面的程序声明了一个常量、一个函数和一对变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出水的沸点</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f = boilingF</span><br><span class="line"><span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"boiling point = %g°F or %g°C\n"</span>, f, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量boilingF是一个包级别的声明，对包中所有源文件可见；变量f和c是属于main函数的局部变量，变量仅在main函数内部可见。</p><p>函数的声明包含一个函数名字，一个参数列表，一个可选的返回值列表（如果无需返回值可省略），以及函数体组成。</p><p>下面的程序封装了温度转换的方法fToC，在其他函数中可以进行多次调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两次华氏-摄氏温度的转换</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> freezingF, boilingF = <span class="number">32.0</span>, <span class="number">212.0</span></span><br><span class="line">fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>,freezingF, fToC(freezingF))</span><br><span class="line">fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>,boilingF,  fToC(boilingF))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fToC</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;从零开始，持续更新&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/01/K7h5QA.png&quot; alt=&quot;K7h5QA.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="http://blog.cairui99.cn/categories/Go/"/>
    
    
      <category term="go语言基础" scheme="http://blog.cairui99.cn/tags/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-最少知识原则</title>
    <link href="http://blog.cairui99.cn/2019/11/01/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E6%B3%95%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/11/01/设计原则-最少知识法则/</id>
    <published>2019-11-01T03:31:11.000Z</published>
    <updated>2019-11-01T06:00:02.589Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>最少知识法则也称为迪米特原则，定义为：<strong>一个对象应该对其他对象有最少的了解。</strong></p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>迪米特法则对实现类的低耦合提出了明确的要求，规则如下：</p><h5 id="1-只和直接的朋友通信"><a href="#1-只和直接的朋友通信" class="headerlink" title="1.只和直接的朋友通信"></a>1.只和直接的朋友通信</h5><p>直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。</p><p>类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。</p><h5 id="2-朋友间也需要有距离"><a href="#2-朋友间也需要有距离" class="headerlink" title="2.朋友间也需要有距离"></a>2.朋友间也需要有距离</h5><p>一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。</p><h5 id="3-是自己的就是自己的"><a href="#3-是自己的就是自己的" class="headerlink" title="3.是自己的就是自己的"></a>3.是自己的就是自己的</h5><p>如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;最少知识法则也称为迪米特原则，定义为：&lt;strong&gt;一个对象应该对其他对象有最少的了解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计原则-接口隔离原则</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.cairui99.cn/2019/10/30/设计原则-接口隔离原则/</id>
    <published>2019-10-30T07:25:09.000Z</published>
    <updated>2019-10-31T12:16:35.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>Clients should not be forced to depend upon interfaces that they don’t use.</strong></p><p><strong>“客户端不应该依赖它不需要的接口”</strong>，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。</p><a id="more"></a><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实现接口时尽量做到以下规范：</p><ul><li>接口要做到高内聚：尽量少的公布public方法，降低变更的风险</li><li>定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法</li><li>有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口</li><li>已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理</li><li>接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Clients should not be forced to depend upon interfaces that they don’t use.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“客户端不应该依赖它不需要的接口”&lt;/strong&gt;，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
      <category term="设计原则" scheme="http://blog.cairui99.cn/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
      <category term="读书笔记" scheme="http://blog.cairui99.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="http://blog.cairui99.cn/2019/10/30/%E7%AE%97%E6%B3%95%E9%A2%98-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>http://blog.cairui99.cn/2019/10/30/算法题-顺时针打印矩阵/</id>
    <published>2019-10-30T06:11:01.000Z</published>
    <updated>2019-11-28T02:33:32.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下：</p><ul><li>在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1)</li><li>完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标</li><li>重复执行上述步骤，直至得到的坐标无法构成矩阵为止</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwisePrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (B[<span class="number">0</span>] &gt;= A[<span class="number">0</span>] &amp;&amp; B[<span class="number">1</span>] &gt;= A[<span class="number">1</span>]) &#123;</span><br><span class="line">            print(matrix,A[<span class="number">0</span>]++,A[<span class="number">1</span>]++,B[<span class="number">0</span>]--,B[<span class="number">1</span>]--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角坐标(a,b)</span></span><br><span class="line"><span class="comment">     * 右下角坐标(c,d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (a, b) -&gt; (a, d)</span></span><br><span class="line">        <span class="keyword">int</span> index = b;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; d) &#123;</span><br><span class="line">            System.out.print(arr[a][index++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (a, d) -&gt; (c, d)</span></span><br><span class="line">        index = a;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; c) &#123;</span><br><span class="line">            System.out.print(arr[index++][d] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, d) -&gt; (c, b)</span></span><br><span class="line">        index = d;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; b) &#123;</span><br><span class="line">            System.out.print(arr[c][index--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, b) -&gt; (a, b)</span></span><br><span class="line">        index = c;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; a) &#123;</span><br><span class="line">            System.out.print(arr[index--][b]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ClockwisePrintMatrix.printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/10/30/Khf43V.png&quot; alt=&quot;Khf43V.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="数组" scheme="http://blog.cairui99.cn/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>栈实现队列&amp;队列实现栈</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-栈实现队列-队列实现栈/</id>
    <published>2019-10-28T07:02:20.000Z</published>
    <updated>2019-11-28T02:34:01.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>要求使用栈实现队列的如下方法：</p><ul><li>offer(入队)</li><li>poll(出队)</li><li>peek(查看栈顶元素)</li></ul><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个栈，push栈和pop栈</li><li>offer()：push栈正常入栈</li><li>poll(): 弹出pop栈的栈顶元素并返回 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li><li>peek(): 返回pop栈的栈顶元素 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; push = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pop  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        push.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!push.isEmpty()) &#123;</span><br><span class="line">            pop.push(push.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列实现栈结构"><a href="#队列实现栈结构" class="headerlink" title="队列实现栈结构"></a>队列实现栈结构</h3><p>要求使用队列实现栈结构的如下方法：</p><ul><li>push(入栈)</li><li>pop(出栈)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个队列，data队列和help队列</li><li>push(): data队列正常入队</li><li>pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回</li><li>peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列实现栈结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBecomeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        data.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> help.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = data.remove();</span><br><span class="line">        help.offer(ret);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈实现队列&quot;&gt;&lt;a href=&quot;#栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;栈实现队列&quot;&gt;&lt;/a&gt;栈实现队列&lt;/h3&gt;&lt;p&gt;要求使用栈实现队列的如下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offer(入队)&lt;/li&gt;
&lt;li&gt;poll(出队)&lt;/li&gt;
&lt;li&gt;peek(查看栈顶元素)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="栈" scheme="http://blog.cairui99.cn/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://blog.cairui99.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Min栈的实现</title>
    <link href="http://blog.cairui99.cn/2019/10/28/%E7%AE%97%E6%B3%95%E9%A2%98-Min%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.cairui99.cn/2019/10/28/算法题-Min栈的实现/</id>
    <published>2019-10-28T06:46:05.000Z</published>
    <updated>2019-11-28T02:34:19.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：</p><ul><li>1．pop、push、peek、getMin操作的时间复杂度都是O(1)。</li><li>2．设计的栈类型可以使用现成的栈结构。</li></ul><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>内部创建两个栈，data栈和min栈</li><li>元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是<strong>(min栈的栈顶存的永远是data栈中的最小值)</strong></li><li>出栈时data栈和min栈一起正常出栈</li><li>getMin()方法只需要返回min栈的栈顶元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span></span><br><span class="line"><span class="comment"> * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。</span></span><br><span class="line"><span class="comment"> *         2．设计的栈类型可以使用现成的栈结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        data.push(num);</span><br><span class="line">        min.push((min.peek() &gt; num) ? num : min.peek());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.pop();</span><br><span class="line">        <span class="keyword">return</span> data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1．pop、push、peek、getMin操作的时间复杂度都是O(1)。&lt;/li&gt;
&lt;li&gt;2．设计的栈类型可以使用现成的栈结构。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="栈" scheme="http://blog.cairui99.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
