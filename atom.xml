<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CaiRui的博客</title>
  
  <subtitle>人类真是毫无长进的生物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cairui99.cn/"/>
  <updated>2020-06-23T12:06:31.091Z</updated>
  <id>http://blog.cairui99.cn/</id>
  
  <author>
    <name>CaiRui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的synchronized</title>
    <link href="http://blog.cairui99.cn/2020/06/22/Java%E4%B8%AD%E7%9A%84synchronized/"/>
    <id>http://blog.cairui99.cn/2020/06/22/Java中的synchronized/</id>
    <published>2020-06-22T02:35:58.000Z</published>
    <updated>2020-06-23T12:06:31.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>synchronized块是Java提供的一种原子性内置锁，也叫监视器锁。</p><a id="more"></a><p>synchronized的作用：</p><ul><li><strong>原子性：</strong> synchronized保证语句块内操作是原子的</li><li><strong>可见性：</strong> synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）</li><li><strong>有序性：</strong> synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）</li></ul><p>synchronized的使用：</p><ul><li>修饰实例方法，对当前实例对象加锁</li><li>修饰静态方法，对当前类的Class对象加锁</li><li>修饰代码块，对synchronized括号内的对象加锁</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>jvm基于进入和退出Monitor对象来实现方法同步和代码块同步</strong></p><ul><li>synchronized是可重入的，所以不会自己把自己锁死</li><li>synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞。</li></ul><h4 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h4><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。</p><p>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</p><p>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p><h4 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h4><p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;    <span class="comment">//这个是同步方法</span></span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;<span class="comment">//这个是同步代码块</span></span><br><span class="line">            System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过反编译后得到：<br><img src="https://img-blog.csdnimg.cn/20190310221443337.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt="NeuTFe.png"></p><p><img src="https://img-blog.csdnimg.cn/20190311182248435.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt="NeuTFe.png"></p><p>可以看到对于同步方法，反编译后得到ACC_SYNCHRONIZED 标志，对于同步代码块反编译后得到了monitorenter和monitorexit指令。</p><h3 id="JVM对synchronized的锁优化"><a href="#JVM对synchronized的锁优化" class="headerlink" title="JVM对synchronized的锁优化"></a>JVM对synchronized的锁优化</h3><p>Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。</p><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：</p><p>锁一共有4种状态 <strong>(锁可以升级但不能降级)</strong>，级别从低到高依次是：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><p>锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。</p><h4 id="理解Java对象头"><a href="#理解Java对象头" class="headerlink" title="理解Java对象头"></a>理解Java对象头</h4><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p><p><img src="https://img-blog.csdnimg.cn/20190310224348833.jpg" alt="NeuTFe.png"></p><p><strong>实例变量：</strong> 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p><p><strong>填充数据：</strong> 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p><p><strong>对象头：</strong> HotSpot虚拟机的对象头分为两部分:</p><ul><li>第一部分用于存储对象自身运行时的数据，如锁信息、哈希码、GC分代年龄等，官方称为Mark Word</li><li>另一部分用于存储指向对象类型数据的指针</li><li>如果是数组对象的话，还会有一个额外的部分存储数组长度</li></ul><table><thead><tr><th>对象头结构</th><th>描述</th></tr></thead><tbody><tr><td>Mark Word</td><td>存储对象的哈希码、GC分代年龄、锁信息等</td></tr><tr><td>Class MetaData Address</td><td>指向对象类型数据的指针</td></tr><tr><td>数组长度</td><td>如果是数组有这部分，否则没有</td></tr></tbody></table><p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间。</p><p><img src="https://img-blog.csdnimg.cn/20190310225911793.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ4MTk2Mw==,size_16,color_FFFFFF,t_70" alt="NeuTFe.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是只有同一个线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在 <strong>对象头Mark Word</strong> 和 <strong>栈帧锁记录</strong> 里存储 <strong>偏向锁的线程ID</strong>，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁：</p><ul><li>如果测试成功，表示线程已经获得了锁</li><li>如果测试失败，再看Mark Word中偏向锁的标识是否设置成1（1表示锁当前状态是偏向锁）：<ul><li>如果没设置为1，则使用CAS竞争锁</li><li>如果设置了，则使用CAS将对象头的偏向锁指向当前线程</li></ul></li></ul><ol><li>a线程获得锁，会在a线程的栈帧里创建lockRecord，在lockRecord里和锁对象的MarkWord里存储线程a的线程id.以后该线程的进入，就不需要cas操作，只需要判断是否是当前线程</li><li>a线程获取锁，不会释放锁，知道出现b线程也要竞争该锁时，a线程才会释放锁</li><li>偏向锁的释放：首先会暂停拥有偏向锁的线程，如果线程不处于活动状态，则将锁对象的MarkWord设置成无锁状态；如果线程处于活跃状态，拥有偏向锁的栈会被执行，栈帧中lockRecord和对象头MarkWord要么重新偏向其他线程，要么恢复到无锁，或者标记对象不适合使用偏向锁（锁升级），最后唤醒被暂停的线程</li><li>关闭偏向锁：通过jvm的参数-XX:UseBiasedLocking=false,则默认会进入轻量级锁。</li></ol><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头MarkWord成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p><p><strong>偏向锁的升级：</strong>  一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，操作系统检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当线程获取偏向锁失败，会尝试使用轻量级锁进行操作。</p><p>轻量级锁只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区，如果轻量级锁获取失败，则表示其他线程抢先获得了锁，那么当前线程的轻量级锁就会升级为重量级锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>轻量级锁升级为重量级锁后，虚拟机为了避免线程在操作系统层面被挂起，虚拟机会尝试使用自旋锁。</p><p>由于当前线程暂时无法获得锁，但有可能在几个cpu周期之后就可以获得锁，因此虚拟机会让当前线程做几个空循环(自旋)，若经过几个循环过后线程获取到了锁，线程就会进入临界区；如果获取不到锁线程就会被系统真正的挂起，自此不会再恢复到轻量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁状态下，所有等待的线程都会进入阻塞状态，线程不会进行自旋，适用于多个线程同时请求进入临界区的情况。</p><h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><p><a href="https://imgchr.com/i/NU2ycD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/23/NU2ycD.png" alt="NU2ycD.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;synchronized块是Java提供的一种原子性内置锁，也叫监视器锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized和Lock的区别</title>
    <link href="http://blog.cairui99.cn/2020/06/21/synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.cairui99.cn/2020/06/21/synchronized和Lock的区别/</id>
    <published>2020-06-21T10:47:23.000Z</published>
    <updated>2020-06-21T11:11:02.291Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized与Lock都是Java中在多线程环境下解决线程安全的重要工具，它们的区别如下：</p><a id="more"></a><h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><ul><li><strong>来源：</strong> lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现</li><li><strong>异常是否释放锁：</strong> synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li><li><strong>是否响应中断：</strong> lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li><li><strong>是否知道获取锁：</strong> Lock可以通过trylock来知道有没有获取锁，而synchronized不能</li><li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li><li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li><li>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Condition定义了等待/通知两种类型的方法</span></span><br><span class="line">Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition=lock.newCondition();</span><br><span class="line">...</span><br><span class="line">condition.await();</span><br><span class="line">...</span><br><span class="line">condition.signal();</span><br><span class="line">condition.signalAll();</span><br></pre></td></tr></table></figure><h3 id="两种锁的底层实现"><a href="#两种锁的底层实现" class="headerlink" title="两种锁的底层实现"></a>两种锁的底层实现</h3><ul><li><strong>synchronized：</strong> 底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</li><li><strong>lock：</strong> 底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;synchronized与Lock都是Java中在多线程环境下解决线程安全的重要工具，它们的区别如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>解决xxx端口被占用问题</title>
    <link href="http://blog.cairui99.cn/2020/06/18/%E8%A7%A3%E5%86%B3xxx%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/06/18/解决xxx端口被占用问题/</id>
    <published>2020-06-18T09:49:18.000Z</published>
    <updated>2020-06-18T09:52:05.512Z</updated>
    
    <content type="html"><![CDATA[<p>通过控制台kill掉占用端口的进程：</p><ul><li>cmd打开控制台，执行命令 <strong>netstat -ano | findstr xxx</strong>(端口号)</li><li>此时可以看到进程的pid，执行命令 <strong>taskkill -pid xxx -f</strong> 终止该进程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过控制台kill掉占用端口的进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cmd打开控制台，执行命令 &lt;strong&gt;netstat -ano | findstr xxx&lt;/strong&gt;(端口号)&lt;/li&gt;
&lt;li&gt;此时可以看到进程的pid，执行命令 &lt;strong&gt;taskkil
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>创建多少个线程合适</title>
    <link href="http://blog.cairui99.cn/2020/06/18/%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82/"/>
    <id>http://blog.cairui99.cn/2020/06/18/创建多少个线程合适/</id>
    <published>2020-06-18T07:44:19.000Z</published>
    <updated>2020-06-22T02:46:06.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h3><p>并发编程很容易出错，为什么还要写并发程序？</p><p><strong>使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度</strong> (充分利用CPU和I/O的利用率)</p><a id="more"></a><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>简单把程序分为两种：CPU密集型程序和I/O密集型程序</p><h4 id="CPU密集型程序"><a href="#CPU密集型程序" class="headerlink" title="CPU密集型程序"></a>CPU密集型程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分</span><br></pre></td></tr></table></figure><p>假如我们要计算 1+2+….100亿 的总和，很明显，这就是一个 CPU 密集型程序</p><p>假设我们创建4个线程来进程分段计算，在单核CPU下：</p><p><img src="https://upload-images.jianshu.io/upload_images/19895418-8a4d3c815c2abdb1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="NeuTFe.png"></p><p>由于是单核 CPU，所有线程都在等待 CPU 时间片。按照理想情况来看，四个线程执行的时间总和与一个线程5独自完成是相等的，实际上我们还忽略了四个线程上下文切换的开销</p><p><strong>所以，单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程</strong></p><p>那么如果在4核CPU下：</p><p><img src="https://upload-images.jianshu.io/upload_images/19895418-7370e52c09df4d86?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="NeuTFe.png"></p><p>每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍。</p><p><strong>所以，如果是多核CPU处理CPU密集型程序，多线程环境完全可以提高程序的效率</strong></p><h4 id="I-O密集型程序"><a href="#I-O密集型程序" class="headerlink" title="I/O密集型程序"></a>I/O密集型程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分</span><br></pre></td></tr></table></figure><p>在进行 I/O 操作时，CPU是空闲状态，所以我们需要使用多线程环境最大化的利用 CPU，不能让其是空闲状态</p><p>在单核CPU下：<br><img src="https://upload-images.jianshu.io/upload_images/19895418-c2955cec5fbacf00?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="NeuTFe.png"></p><p>从上图中可以看出，每个线程都执行了相同长度的 CPU 耗时和 I/O 耗时，实现了最大化利用了CPU</p><h3 id="创建多少个线程合适？"><a href="#创建多少个线程合适？" class="headerlink" title="创建多少个线程合适？"></a>创建多少个线程合适？</h3><h4 id="CPU密集型程序-1"><a href="#CPU密集型程序-1" class="headerlink" title="CPU密集型程序"></a>CPU密集型程序</h4><p>理论上 <strong>线程数量 = CPU核数</strong> 就可以了，实际上数量一般会设置为 <strong>CPU核数 + 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</span><br></pre></td></tr></table></figure><h4 id="I-O密集型程序-1"><a href="#I-O密集型程序-1" class="headerlink" title="I/O密集型程序"></a>I/O密集型程序</h4><p>单核Cpu最佳线程数 = <strong>(1/CPU利用率)</strong> = <strong>1 + (I/O耗时/CPU耗时)</strong></p><p>理论上来说，这样就能达到 CPU 100% 的利用率</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么要使用多线程&quot;&gt;&lt;a href=&quot;#为什么要使用多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用多线程&quot;&gt;&lt;/a&gt;为什么要使用多线程&lt;/h3&gt;&lt;p&gt;并发编程很容易出错，为什么还要写并发程序？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度&lt;/strong&gt; (充分利用CPU和I/O的利用率)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://blog.cairui99.cn/2020/06/16/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.cairui99.cn/2020/06/16/Java内存模型/</id>
    <published>2020-06-16T07:15:55.000Z</published>
    <updated>2020-06-17T11:32:29.492Z</updated>
    
    <content type="html"><![CDATA[<p>Java内存模型(JMM)定义了Java虚拟机(JVM)在计算机内存中的工作方式。 <strong>Java对并发请求采用的是共享内存模型。</strong></p><a id="more"></a><h3 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h3><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。</p><p><a href="https://imgchr.com/i/NEOfKK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/17/NEOfKK.png" alt="NEOfKK.png"></a></p><h4 id="JVM对Java内存模型的实现"><a href="#JVM对Java内存模型的实现" class="headerlink" title="JVM对Java内存模型的实现"></a>JVM对Java内存模型的实现</h4><p>在JVM内部，Java内存模型把内存分成了两部分：<strong>线程栈区和堆区</strong></p><p><a href="https://imgchr.com/i/NEjvNQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/17/NEjvNQ.png" alt="NEjvNQ.png"></a></p><p>JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。所有原始类型(boolean,byte,short,char,int,long,float,double)的局部变量都直接保存在线程栈当中，对于它们的值各个线程之间都是独立的。对于原始类型的局部变量，一个线程可以传递一个副本给另一个线程，当它们之间是无法共享的。</p><p>堆区包含了Java应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如Byte、Integer、Long等等）。不管对象是属于一个成员变量还是方法中的局部变量，它都会被存储在堆区。</p><p>一个局部变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</p><h3 id="Java内存模块存在的问题"><a href="#Java内存模块存在的问题" class="headerlink" title="Java内存模块存在的问题"></a>Java内存模块存在的问题</h3><p>在多线程环境下，只有当至少一个线程修改共享资源时才可能会存在线程安全问题</p><h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h4><p><a href="https://imgchr.com/i/NVFLzF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/17/NVFLzF.png" alt="NVFLzF.png"></a></p><p>如图，线程A从主存中拷贝共享对象obj到它的CPU缓存，把对象obj的count变量改为2。但这个变更对运行在线程B中不可见，因为这个更改还没有flush到主存中</p><p>要解决共享对象可见性这个问题，我们可以使用java volatile关键字或者是加锁</p><h4 id="竞争现象"><a href="#竞争现象" class="headerlink" title="竞争现象"></a>竞争现象</h4><p><a href="https://imgchr.com/i/NVJhyd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/17/NVJhyd.png" alt="NVJhyd.png"></a></p><p>如图，线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。如果这两个加1操作是串行执行的，那么Obj.count变量便会在原始值上加2，最终主存中的Obj.count的值会是3。然而下图中两个加1操作是并行的，不管是线程A还是线程B先flush计算结果到主存，最终主存中的Obj.count只会增加1次变成2，尽管一共有两次加1操作。</p><p>要解决上面的问题我们可以使用java synchronized代码块。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java内存模型(JMM)定义了Java虚拟机(JVM)在计算机内存中的工作方式。 &lt;strong&gt;Java对并发请求采用的是共享内存模型。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>什么是语法糖（syntactic suger）</title>
    <link href="http://blog.cairui99.cn/2020/06/09/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%88syntactic-suger%EF%BC%89/"/>
    <id>http://blog.cairui99.cn/2020/06/09/什么是语法糖（syntactic-suger）/</id>
    <published>2020-06-09T03:44:00.000Z</published>
    <updated>2020-06-09T09:33:59.103Z</updated>
    
    <content type="html"><![CDATA[<p>语法糖（syntactic suger），也叫糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，是指在编程语言中添加某种语法，而这种语法并不会对语言的功能有任何的影响，但是会更方便程序员使用。</p><a id="more"></a><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<strong>在不改变其所在位置的语法结构的前提下，实现了运行时的等价。</strong>可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：代码更简洁流畅，代码更语义自然…写着爽，看着爽，就像吃了糖。效率高。</p><p>for循环就是一个语法糖的效果，实际和while循环没有任何区别，但增加了程序的可读性。</p><p>据说还有一种叫做「语法盐」的东西，主要目的是通过反人类的语法，让你更痛苦的写代码。其实它同样能达到避免代码书写错误的效果，但编程效率应该是降低了，毕竟提高了语法学习门槛，让人咸到忧伤…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语法糖（syntactic suger），也叫糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，是指在编程语言中添加某种语法，而这种语法并不会对语言的功能有任何的影响，但是会更方便程序员使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="知识点整理" scheme="http://blog.cairui99.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的Monitor</title>
    <link href="http://blog.cairui99.cn/2020/06/09/Java%E4%B8%AD%E7%9A%84Monitor/"/>
    <id>http://blog.cairui99.cn/2020/06/09/Java中的Monitor/</id>
    <published>2020-06-09T02:24:15.000Z</published>
    <updated>2020-06-09T08:53:26.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Monitor的概念"><a href="#Monitor的概念" class="headerlink" title="Monitor的概念"></a>Monitor的概念</h3><p>Monitor，译为管程、或监视器。由于操作系统在面对进程/线程间同步的时候，常常使用mutex进行并发控制，需要程序员准确的使用down和up操作，否则很容易引起死锁问题， <strong>Monitor的作用是为了更容易正确的编写并发程序而实现的一种同步机制。</strong></p><a id="more"></a><p>Monitor是属于编程语言范畴，使用Monitor时，需要先了解下语言本身是否支持Monitor原语，例如：C语言不支持Monitor，而Java支持Monitor。</p><p>monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒，这才是monitor与操作系统自带的semaphore 和 mutex 的主要区别，显然monitor是“更高级的原语”。</p><h3 id="Monitor的基本元素"><a href="#Monitor的基本元素" class="headerlink" title="Monitor的基本元素"></a>Monitor的基本元素</h3><p>monitor 机制需要几个元素来配合，分别是：</p><ul><li>临界区</li><li>monitor对象及锁</li><li>条件变量以及定义在 monitor 对象上的 wait，signal 操作</li></ul><p>使用 monitor 机制的目的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的 进程/线程，还需要一个 monitor object 来协助，这个 monitor object 内部会有相应的数据结构，例如列表，来保存被阻塞的线程；</p><p>同时由于 monitor 机制本质上是基于 mutex 这种基本原语的，所以 monitor object 还必须维护一个基于 mutex 的锁。</p><p>此外，为了在适当的时候能够阻塞和唤醒 进程/线程，还需要引入一个条件变量，这个条件变量用来决定什么时候是“适当的时候”。</p><h3 id="Monitor在Java中的实现方式"><a href="#Monitor在Java中的实现方式" class="headerlink" title="Monitor在Java中的实现方式"></a>Monitor在Java中的实现方式</h3><p>在Java中，可以采用synchronized关键字来实现线程的同步，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object ANOTHER_LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ANOTHER_LOCK) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>被synchronized关键字修饰的方法、代码块，就是 monitor 机制的临界区。</p><h4 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h4><p>在monitor机制中，monitor object 充当着维护 mutex以及定义 wait/signal API 来管理线程的阻塞和唤醒的角色。</p><p>Java 语言中的 java.lang.Object 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 monitor object。可以发现在使用synchronized时，synchronzied 需要关联一个对象，而这个对象就是 monitor object。</p><h4 id="java实现monitor"><a href="#java实现monitor" class="headerlink" title="java实现monitor"></a>java实现monitor</h4><p>在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0; //记录个数</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：</p><p><a href="https://imgchr.com/i/t5asv8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/09/t5asv8.png" alt="t5asv8.png"></a></p><p>由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Monitor的概念&quot;&gt;&lt;a href=&quot;#Monitor的概念&quot; class=&quot;headerlink&quot; title=&quot;Monitor的概念&quot;&gt;&lt;/a&gt;Monitor的概念&lt;/h3&gt;&lt;p&gt;Monitor，译为管程、或监视器。由于操作系统在面对进程/线程间同步的时候，常常使用mutex进行并发控制，需要程序员准确的使用down和up操作，否则很容易引起死锁问题， &lt;strong&gt;Monitor的作用是为了更容易正确的编写并发程序而实现的一种同步机制。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>算法题题解整理</title>
    <link href="http://blog.cairui99.cn/2020/06/04/%E7%AE%97%E6%B3%95%E9%A2%98%E9%A2%98%E8%A7%A3%E6%95%B4%E7%90%86/"/>
    <id>http://blog.cairui99.cn/2020/06/04/算法题题解整理/</id>
    <published>2020-06-04T07:53:27.000Z</published>
    <updated>2020-06-04T08:11:41.540Z</updated>
    
    <content type="html"><![CDATA[<p>一些整理出了题解的常见算法题，代码都是自己写的</p><a id="more"></a><h2 id="复制含有随机指针的链表"><a href="#复制含有随机指针的链表" class="headerlink" title="复制含有随机指针的链表"></a>复制含有随机指针的链表</h2><p>Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RandNode next;</span><br><span class="line">    <span class="keyword">public</span> RandNode rand;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。</p><p><strong>进阶：</strong> 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。</p><h3 id="HashMap实现"><a href="#HashMap实现" class="headerlink" title="HashMap实现"></a>HashMap实现</h3><p>使用辅助结构HashMap实现：</p><ul><li>创建一个HashMap，key、value都是RandNode类型</li><li>遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中</li><li>遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点</li><li>重新遍历原链表，将map中所有的value的next、rand指针进行连接</li><li>返回复制后链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashMap实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">hashMapMethod</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;RandNode, RandNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        map.put(node, copy_node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = map.get(node);</span><br><span class="line">        copy_node.next = map.get(node.next);</span><br><span class="line">        copy_node.rand = map.get(node.rand);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用有限变量实现"><a href="#使用有限变量实现" class="headerlink" title="使用有限变量实现"></a>使用有限变量实现</h3><p>借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表：</p><ul><li>遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null)</li><li>此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点</li><li>下面遍历链表，将所有复制节点的rand指针指向正确的位置</li><li>最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用有限的变量实现 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 原链表头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 复制后的链表头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RandNode <span class="title">randPointNode</span><span class="params">(RandNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandNode(head.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点连到对应原节点后面</span></span><br><span class="line">    RandNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = <span class="keyword">new</span> RandNode(node.value);</span><br><span class="line">        copy_node.next = node.next;</span><br><span class="line">        node.next = copy_node;</span><br><span class="line">        node = copy_node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置复制节点的rand指针</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        copy_node.rand = node.rand != <span class="keyword">null</span> ? node.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        node = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将复制的节点分离出来</span></span><br><span class="line">    RandNode result = head.next;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        RandNode copy_node = node.next;</span><br><span class="line">        <span class="keyword">if</span> (copy_node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.next = copy_node.next;</span><br><span class="line">            copy_node.next = copy_node.next.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            copy_node.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更快的获取中位数"><a href="#更快的获取中位数" class="headerlink" title="更快的获取中位数"></a>更快的获取中位数</h2><p>一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。</p><p>此时收集数的操作是 <strong>O(1)</strong>，获取中位数的操作是 <strong>O(n*logn)</strong></p><p>如果接口被频繁调用，排序的代价就太高了，下面利用<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">堆结构</a>的特点来进行优化：</p><ul><li>创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下：<ul><li>假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中</li><li>两个堆中元素数量保持平衡，差值不大于1</li></ul></li><li>如何获取中位数：<ul><li>如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素</li><li>如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值</li></ul></li></ul><p> 此时收集数的操作需要进行一次heapInsert 代价是 <strong>O(logn)</strong>，而获取中位数的操作变为了 <strong>O(1)</strong>，效率得到了很大的提升 <strong>O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cai Rui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianQuick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bigSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smallSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numberInsert</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.automaticCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (number &gt; bigHeap[<span class="number">0</span>]) &#123; <span class="comment">//较大的数进小根堆</span></span><br><span class="line">            smallHeap[smallSize++] = number;</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//较小的数进大根堆</span></span><br><span class="line">            bigHeap[bigSize++] = number;</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//平衡堆中元素数量，差值不等大于1</span></span><br><span class="line">        <span class="keyword">if</span> (bigSize - smallSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,<span class="number">0</span>);</span><br><span class="line">            Heap.heapInsert(smallHeap,smallSize-<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallSize - bigSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,<span class="number">1</span>);</span><br><span class="line">            Heap.heapInsert(bigHeap,bigSize-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bigSize == smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)(bigHeap[<span class="number">0</span>] + smallHeap[<span class="number">0</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bigSize &gt; smallSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> bigHeap[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> smallHeap[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">automaticCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bigHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.bigHeap.length+<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span>[] smallHeap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.smallHeap.length+<span class="number">100</span>];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.bigHeap, <span class="number">0</span>, bigHeap, <span class="number">0</span>, bigSize);</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.smallHeap, <span class="number">0</span>, smallHeap, <span class="number">0</span>, smallSize);</span><br><span class="line">        <span class="keyword">this</span>.bigHeap = bigHeap;</span><br><span class="line">        <span class="keyword">this</span>.smallHeap = smallHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://blog.cairui99.cn/2019/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/">Heap类的相关代码</a></p><h2 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h2><p>给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。</p><h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路 时间复杂度(n) 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badMethod</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; alist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; blist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;num) &#123;</span><br><span class="line">            alist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n==num) &#123;</span><br><span class="line">            blist.add(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clist.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    index = setArray(arr,index,alist);</span><br><span class="line">    index = setArray(arr,index,blist);</span><br><span class="line">    setArray(arr,index,clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, @NotNull List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        arr[index++] = integer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空间复杂度改进为O(1)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlag</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[indexMid] &lt; num) &#123;</span><br><span class="line">            swap(arr,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[indexMid] == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(@NotNull <span class="keyword">int</span>[] arr, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">    arr[x] = arr[y];</span><br><span class="line">    arr[y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用三个指针，交换全部在数组内部进行，三个指针的含义为：</p><ul><li>indexFront : 指针前面的所有数都满足小于num</li><li>indexMid : 指针前面所有的数都满足小于等于num</li><li>indexRear : 指针后面所有的数都满足大于num</li></ul><p>终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置</p><h2 id="荷兰国旗问题-单向链表版"><a href="#荷兰国旗问题-单向链表版" class="headerlink" title="荷兰国旗问题-单向链表版"></a>荷兰国旗问题-单向链表版</h2><p>将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。</p><p>进阶：左、中、右三个部分内部需要与原链表顺序一致</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用辅助数组实现：</p><ul><li>创建一个辅助数组，遍历链表将节点放入数组中</li><li>在数组中调整元素的位置，具体操作可见<a href="https://blog.cairui99.cn/2019/10/11/%E7%AE%97%E6%B3%95%E9%A2%98-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/">荷兰国旗问题</a></li><li>在数组中调整好顺序后再将值赋给原链表</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用辅助数组</span></span><br><span class="line"><span class="comment"> * 空间复杂度O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arrayMethod</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> indexFront = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> indexRear = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (indexMid &lt;= indexRear) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(indexMid) &lt; num) &#123;</span><br><span class="line">            swap(list,indexMid,indexFront);</span><br><span class="line">            indexMid++;</span><br><span class="line">            indexFront++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.get(indexMid) == num) &#123;</span><br><span class="line">            indexMid++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(list,indexMid,indexRear);</span><br><span class="line">            indexRear--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        node.value = integer;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = list.get(x);</span><br><span class="line">    list.set(x, list.get(y));</span><br><span class="line">    list.set(y, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作：</p><ul><li>遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点</li><li>将三条子链表头尾连接，变为一条完整的链表返回即可</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进阶版</span></span><br><span class="line"><span class="comment"> * 保证稳定性，同时空间复杂度达到O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dutchFlagListNode</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode less_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode less_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode eq_tail = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode more_tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                less_head = head;</span><br><span class="line">                less_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                less_tail.next = head;</span><br><span class="line">                less_tail = less_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eq_head = head;</span><br><span class="line">                eq_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eq_tail.next = head;</span><br><span class="line">                eq_tail = eq_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (more_head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                more_head = head;</span><br><span class="line">                more_tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                more_tail.next = head;</span><br><span class="line">                more_tail = more_tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接小于、等于、大于部分</span></span><br><span class="line">    head = <span class="keyword">null</span>;</span><br><span class="line">    ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (less_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = less_head;</span><br><span class="line">        tail = less_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eq_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = eq_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = eq_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = eq_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (more_head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail.next = more_head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = more_head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = more_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尾部至空，防止链表成环</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="keyword">null</span> &amp;&amp; tail.next != <span class="keyword">null</span>) tail.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两条单链表相交的问题"><a href="#两条单链表相交的问题" class="headerlink" title="两条单链表相交的问题"></a>两条单链表相交的问题</h2><p>给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先判断两条单链表是否成环，如果有环则获取到入环节点，然后分情况讨论：</p><ol><li>两条非环单链表：遍历两条链表获取链表的长度，将较长的那条的头节点向后移动两条链表头部的差值，然后两条单链表从头节点同时向后移动：<ul><li>如果产生交点则两条链表相交，返回该节点</li><li>抵达尾部时都没有产生交点则不相交，返回null</li></ul></li><li>一条单链表成环，一条单链表非环：必无交点</li><li>两条成环单链表：<ul><li>入环节点相同，必相交：将入环节点视为终点，此时两条链表可以视为非环单链表，寻找两条单链表的交点时则可以使用两条非环单链表的判断方法找到交点</li><li>入环节点不同，需要判断是否相交：选择其中一条链表的入环节点开始遍历，如果遍历过程中遇到了另一条链表的入环节点，则两条链表相交；如果遍历一整圈都没有相遇则两条链表无交点</li></ul></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个单链表的头节点,判断是否相交,如果相交返回相交的节点,不相交返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-12-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntersectNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">isIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode isCyclization1 = isCyclization(head1);</span><br><span class="line">        ListNode isCyclization2 = isCyclization(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCyclization1 == <span class="keyword">null</span> &amp;&amp; isCyclization2 == <span class="keyword">null</span>) &#123; <span class="comment">//两条非环单链表</span></span><br><span class="line">            <span class="keyword">return</span> getIntersect(head1, head2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCyclization1 != <span class="keyword">null</span> &amp;&amp; isCyclization2 != <span class="keyword">null</span>) &#123; <span class="comment">//两条成环单链表</span></span><br><span class="line">            <span class="keyword">if</span> (isCyclization1 == isCyclization2) &#123; <span class="comment">//入环节点相同,必相交</span></span><br><span class="line">                ListNode tempNode = isCyclization1.next;</span><br><span class="line">                isCyclization1.next = <span class="keyword">null</span>;</span><br><span class="line">                ListNode resultNode = getIntersect(head1, head2);</span><br><span class="line">                isCyclization1.next = tempNode;</span><br><span class="line">                <span class="keyword">return</span> resultNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//入环节点不同需要判断是否相交</span></span><br><span class="line">                ListNode node = isCyclization1.next;</span><br><span class="line">                <span class="keyword">while</span> (node != isCyclization1) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == isCyclization2) &#123; <span class="comment">//在环中遇到了另一个链表的入环节点,说明两条链表相交</span></span><br><span class="line">                        <span class="keyword">return</span> isCyclization1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单链表是否成环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 入环节点,不成环则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">isCyclization</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用快慢指针判断是否成环</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回入环节点</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两条非环单链表的交点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node1Length = getNodeLength(head1);</span><br><span class="line">        <span class="keyword">int</span> node2Length = getNodeLength(head2);</span><br><span class="line">        ListNode longerNode = node1Length &gt; node2Length ? head1 : head2;</span><br><span class="line">        ListNode shortNode  = node1Length &gt; node2Length ? head2 : head1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.abs(node1Length - node2Length); i++) &#123;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (shortNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shortNode == longerNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> shortNode;</span><br><span class="line">            &#125;</span><br><span class="line">            shortNode  = shortNode.next;</span><br><span class="line">            longerNode = longerNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取非环单链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否为回文结构"><a href="#判断链表是否为回文结构" class="headerlink" title="判断链表是否为回文结构"></a>判断链表是否为回文结构</h2><p>给定一个链表的头节点head,请判断该链表是否为回文结构。</p><p>回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)：</p><ul><li>将链表从头到尾依次入栈</li><li>再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等</li><li>如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈结构</span></span><br><span class="line"><span class="comment"> * 额外空间O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">stackMethod</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)：</p><ul><li>使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点</li><li>将链表的后半部分逆序，同时将中间节点指向null</li><li>此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等</li><li>如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论</li><li>将链表调整为最初的状态(如果需要的话)，然后返回结论</li></ul><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快慢指针+逆序链表</span></span><br><span class="line"><span class="comment"> * 额外空间O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="comment">//链表元素的个数是否为单数</span></span><br><span class="line">    <span class="keyword">boolean</span> isSingular = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//寻找链表的中心点</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            isSingular = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序链表的后半部分</span></span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSingular) &#123;</span><br><span class="line">        node2 = reverseListNode(slow);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node2 = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        node2 = reverseListNode(node2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否是回文结构</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">    ListNode tailNode = node2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node1.value != node2.value) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整链表至最初状态</span></span><br><span class="line">    reverseListNode(tailNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反转后的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverseListNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode before = <span class="keyword">null</span>;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        node.next = before;</span><br><span class="line">        before = node;</span><br><span class="line">        node = next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断k是否在矩阵中"><a href="#判断k是否在矩阵中" class="headerlink" title="判断k是否在矩阵中"></a>判断k是否在矩阵中</h2><p>给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵：</p><p><img src="https://s2.ax1x.com/2019/11/12/M3ZfoQ.png" alt="M3ZfoQ.png"></p><p>要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点</li><li>假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素</li><li>跟据该特性，判断指针所在位置的元素和整数k的关系：<ul><li>等于k：返回true</li><li>大于k：指针向左移动，如果移动后超过了矩阵边界返回false</li><li>小于k：指针向下移动，如果移动后超过了矩阵边界返回false</li></ul></li><li>重复执行上述步骤，直至函数return</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的.</span></span><br><span class="line"><span class="comment"> * 实现一个函数,判断K是否在matrix中</span></span><br><span class="line"><span class="comment"> * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMatrixNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] index = &#123;<span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[index[<span class="number">0</span>]][index[<span class="number">1</span>]] &gt; num) &#123;</span><br><span class="line">                index[<span class="number">1</span>]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index[<span class="number">0</span>] &gt;= matrix.length || index[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h2><p>使用数组实现队列结构，实现方法：</p><ul><li>add(向队尾添加元素)</li><li>poll(返回队首元素，并移除)</li><li>peek(返回队首元素)</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针start、end和一个变量size，初始值都为0<ul><li>start表示队首元素的位置</li><li>end表示下一个元素入队时要添加的位置</li><li>size表示队列大小</li><li><strong>start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组</strong></li></ul></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBecomeQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个元素到队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列已满"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = num;</span><br><span class="line">        end = (end == arr.length - <span class="number">1</span>) ? <span class="number">0</span> : ++end;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素，并移除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> result = arr[start];</span><br><span class="line">        start = start == arr.length - <span class="number">1</span> ? <span class="number">0</span> : ++start;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//预计输出：1 1 2 3 3</span></span><br><span class="line">        ArrayBecomeQueue queue = <span class="keyword">new</span> ArrayBecomeQueue(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line">        queue.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        queue.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        queue.add(<span class="number">5</span>);</span><br><span class="line">        queue.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(queue.peek());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下：</p><ul><li>在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1)</li><li>完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标</li><li>重复执行上述步骤，直至得到的坐标无法构成矩阵为止</li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺时针打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwisePrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;matrix.length - <span class="number">1</span>, matrix[<span class="number">0</span>].length -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (B[<span class="number">0</span>] &gt;= A[<span class="number">0</span>] &amp;&amp; B[<span class="number">1</span>] &gt;= A[<span class="number">1</span>]) &#123;</span><br><span class="line">            print(matrix,A[<span class="number">0</span>]++,A[<span class="number">1</span>]++,B[<span class="number">0</span>]--,B[<span class="number">1</span>]--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左上角坐标(a,b)</span></span><br><span class="line"><span class="comment">     * 右下角坐标(c,d)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// (a, b) -&gt; (a, d)</span></span><br><span class="line">        <span class="keyword">int</span> index = b;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; d) &#123;</span><br><span class="line">            System.out.print(arr[a][index++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (a, d) -&gt; (c, d)</span></span><br><span class="line">        index = a;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; c) &#123;</span><br><span class="line">            System.out.print(arr[index++][d] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, d) -&gt; (c, b)</span></span><br><span class="line">        index = d;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; b) &#123;</span><br><span class="line">            System.out.print(arr[c][index--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (c, b) -&gt; (a, b)</span></span><br><span class="line">        index = c;</span><br><span class="line">        <span class="keyword">while</span> (index &gt; a) &#123;</span><br><span class="line">            System.out.print(arr[index--][b]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ClockwisePrintMatrix.printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相邻两数最大差值"><a href="#相邻两数最大差值" class="headerlink" title="相邻两数最大差值"></a>相邻两数最大差值</h2><p>给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)</p><p>举个例子：</p><ul><li>给定数组：{4,5,1,2}</li><li>排好序后的数组是：{1,2,4,5}</li><li>相邻两数的差值分别为：1,2,1</li><li>需要返回最大差值，所以最终结果就是2</li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先把数组排序，再遍历数组求出所有差值，返回最大的那一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">        <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">            result = border;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用</strong></p><h3 id="标准解法"><a href="#标准解法" class="headerlink" title="标准解法"></a>标准解法</h3><p>这里利用了桶的概念，但没有进行桶排序</p><p>思路：</p><ul><li>假设数组中有N个数，创建N+1个桶</li><li>遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶</li><li>然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中   (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：<strong>1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5</strong>)</li></ul><p>这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 <strong>产生最大差值的两个相邻数绝对不会来自于相同桶</strong></p><p>有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了</p><p>所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 <strong>相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BorderCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBorderCount</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤非法数据</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶</span></span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录桶是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span>[] existNumber = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值和最大值相等：返回0</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr);</span><br><span class="line">        <span class="keyword">int</span> minNum = criticalMap.get(<span class="string">"Min"</span>);</span><br><span class="line">        <span class="keyword">int</span> maxNum = criticalMap.get(<span class="string">"Max"</span>);</span><br><span class="line">        <span class="keyword">if</span> (minNum == maxNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小值放在第一个桶，最大值放在最后一个桶</span></span><br><span class="line">        min[<span class="number">0</span>] = minNum;</span><br><span class="line">        max[<span class="number">0</span>] = minNum;</span><br><span class="line">        existNumber[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        min[min.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        max[max.length-<span class="number">1</span>] = maxNum;</span><br><span class="line">        existNumber[existNumber.length-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个桶中存放的数值范围</span></span><br><span class="line">        <span class="keyword">double</span> scope = (<span class="keyword">double</span>) (min[min.length-<span class="number">1</span>] - min[<span class="number">0</span>])/min.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == min[<span class="number">0</span>] || num == max[max.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该元素应该存放的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.ceil((num - min[<span class="number">0</span>]) / scope)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!existNumber[index]) &#123;</span><br><span class="line">                min[index] = num;</span><br><span class="line">                max[index] = num;</span><br><span class="line">                existNumber[index] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; max[index]) &#123;</span><br><span class="line">                    max[index] = num;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min[index]) &#123;</span><br><span class="line">                    min[index] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录非空桶的坐标</span></span><br><span class="line">        List&lt;Integer&gt; existIndex = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existNumber.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existNumber[i]) &#123;</span><br><span class="line">                existIndex.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算最大差值</span></span><br><span class="line">        <span class="keyword">int</span> maxBorderCount = max[<span class="number">0</span>] - min[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; existIndex.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = min[existIndex.get(i+<span class="number">1</span>)] - max[existIndex.get(i)];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; maxBorderCount) &#123;</span><br><span class="line">                maxBorderCount = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxBorderCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值和最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; <span class="title">getMaxAndMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            max = Math.max(max,num);</span><br><span class="line">            min = Math.min(min,num);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(<span class="string">"Max"</span>,max);</span><br><span class="line">        result.put(<span class="string">"Min"</span>,min);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力解法 O(n*logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> result = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> border = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            <span class="keyword">if</span> (border &gt; result) &#123;</span><br><span class="line">                result = border;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; testCount;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = ArrayUtil.getArray(<span class="number">10</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">int</span>[] arr1 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span>[] arr2 = ArrayUtil.copyArray(arr);</span><br><span class="line">            <span class="keyword">int</span> border1 = BorderCount.getBorderCount(arr1);</span><br><span class="line">            <span class="keyword">int</span> border2 = BorderCount.testMethod(arr2);</span><br><span class="line">            <span class="keyword">if</span> (border1 != border2) &#123;</span><br><span class="line">                is_success = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_success) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Success"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Fail"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h2><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p><p>现在给出一个数组请求出数组的小和。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>数组：[1,3,4,2,5]</p><p>1左边比1小的数，没有；</p><p>3左边比3小的数，1；</p><p>4左边比4小的数，1、3；</p><p>2左边比2小的数，1；</p><p>5左边比5小的数，1、3、4、2；</p><p>所以小和为1+1+3+1+1+3+4+2=16</p><h3 id="常见思路-1"><a href="#常见思路-1" class="headerlink" title="常见思路"></a>常见思路</h3><p>常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见思路,O(n2)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">badMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[j]) smallSum += arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进</p><h3 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h3><p>在<a href="https://blog.cairui99.cn/2019/09/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>的基础上进行改进，在merge左右两个有序数组时候，<strong>如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和</strong>，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用分治思想,O(n*logn)的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSmallSum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left - (left-right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> getSmallSum(arr,left,mid) + getSmallSum(arr,mid+<span class="number">1</span>,right) + merge(arr,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smallSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] merge_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span> index_merge = left;</span><br><span class="line">    <span class="keyword">int</span> index_left = left;</span><br><span class="line">    <span class="keyword">int</span> index_right = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外排</span></span><br><span class="line">    <span class="keyword">while</span> (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123;</span><br><span class="line">        <span class="comment">//左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数)</span></span><br><span class="line">        smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+<span class="number">1</span>) * arr[index_left] : <span class="number">0</span>;</span><br><span class="line">        merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = index_left&lt;=mid ? index_left : index_right;</span><br><span class="line">    <span class="keyword">int</span> end = index_left&lt;=mid ? mid : arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line">        merge_arr[index_merge++] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将排好序的结果赋给原数组</span></span><br><span class="line">    System.arraycopy(merge_arr, left, arr, left, right + <span class="number">1</span> - left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> smallSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时算法的时间复杂度就提升到了O(n*logn)的级别</p><h2 id="旋转正方形矩阵"><a href="#旋转正方形矩阵" class="headerlink" title="旋转正方形矩阵"></a>旋转正方形矩阵</h2><p>给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</p><p>要求：额外空间复杂度为O(1)。</p><p>举例：</p><p><img src="https://s2.ax1x.com/2019/11/07/Mk3zT0.png" alt="Mk3zT0.png"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>大体思路做到由外到内一圈一圈旋转，具体步骤如下：</p><ul><li>取左上角与右上角的坐标A、B，由A、B来确定完整的一圈</li><li>要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转</li><li>旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程</li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 旋转正方形矩阵</span></span><br><span class="line"><span class="comment"> *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。</span></span><br><span class="line"><span class="comment"> *【要求】 额外空间复杂度为O(1)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockwiseRotateMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是正方形矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length != matrix[<span class="number">0</span>].length || matrix.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> B = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A &lt; B) &#123;</span><br><span class="line">            clockwise(matrix, A, B);</span><br><span class="line">            A++;</span><br><span class="line">            B--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 旋转一个外圈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A 左上角坐标(A, A)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B 右下角坐标(B, B)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] leftOn    = &#123;A, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightOn   = &#123;A, B&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] leftDown  = &#123;B, A&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rightDown = &#123;B, B&#125;;</span><br><span class="line">        <span class="keyword">while</span> (leftOn[<span class="number">1</span>] &lt; B) &#123;</span><br><span class="line">            swap(matrix, leftOn, rightOn, rightDown, leftDown);</span><br><span class="line">            leftOn[<span class="number">1</span>]++;</span><br><span class="line">            rightOn[<span class="number">0</span>]++;</span><br><span class="line">            leftDown[<span class="number">0</span>]--;</span><br><span class="line">            rightDown[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempA = matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempB = matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempC = matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">int</span> tempD = matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]];</span><br><span class="line">        matrix[A[<span class="number">0</span>]][A[<span class="number">1</span>]] = tempD;</span><br><span class="line">        matrix[B[<span class="number">0</span>]][B[<span class="number">1</span>]] = tempA;</span><br><span class="line">        matrix[C[<span class="number">0</span>]][C[<span class="number">1</span>]] = tempB;</span><br><span class="line">        matrix[D[<span class="number">0</span>]][D[<span class="number">1</span>]] = tempC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Code.ClockwiseRotateMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(ints[j] + <span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clockwiseRotateMatrixTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//        int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;;</span></span><br><span class="line">        System.out.println(<span class="string">"原矩阵："</span>);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">        System.out.println(<span class="string">"旋转后矩阵："</span>);</span><br><span class="line">        ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix);</span><br><span class="line">        printMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CodeTest.clockwiseRotateMatrixTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原矩阵：</span><br><span class="line">1  2  3  </span><br><span class="line">4  5  6  </span><br><span class="line">7  8  9  </span><br><span class="line">旋转后矩阵：</span><br><span class="line">7  4  1  </span><br><span class="line">8  5  2  </span><br><span class="line">9  6  3</span><br></pre></td></tr></table></figure><h2 id="栈实现队列-amp-队列实现栈"><a href="#栈实现队列-amp-队列实现栈" class="headerlink" title="栈实现队列&amp;队列实现栈"></a>栈实现队列&amp;队列实现栈</h2><h3 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a>栈实现队列</h3><p>要求使用栈实现队列的如下方法：</p><ul><li>offer(入队)</li><li>poll(出队)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个栈，push栈和pop栈</li><li>offer()：push栈正常入栈</li><li>poll(): 弹出pop栈的栈顶元素并返回 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li><li>peek(): 返回pop栈的栈顶元素 <strong>(当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中)</strong></li></ul><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackBecomeQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; push = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; pop  = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        push.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pop.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (push.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.pushData();</span><br><span class="line">        <span class="keyword">return</span> pop.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!push.isEmpty()) &#123;</span><br><span class="line">            pop.push(push.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列实现栈结构"><a href="#队列实现栈结构" class="headerlink" title="队列实现栈结构"></a>队列实现栈结构</h3><p>要求使用队列实现栈结构的如下方法：</p><ul><li>push(入栈)</li><li>pop(出栈)</li><li>peek(查看栈顶元素)</li></ul><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ul><li>内部创建两个队列，data队列和help队列</li><li>push(): data队列正常入队</li><li>pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回</li><li>peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回</li></ul><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列实现栈结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueBecomeStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; data = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        size++;</span><br><span class="line">        data.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栈顶元素出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> help.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"栈为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            help.offer(data.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = data.remove();</span><br><span class="line">        help.offer(ret);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = data;</span><br><span class="line">        data = help;</span><br><span class="line">        help = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="之字形打印矩阵"><a href="#之字形打印矩阵" class="headerlink" title="之字形打印矩阵"></a>之字形打印矩阵</h2><p>输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵</p><p><img src="https://s2.ax1x.com/2019/10/30/Khf43V.png" alt="Khf43V.png"></p><p>打印结果为：</p><ul><li>1</li><li>2 5</li><li>9 6 3</li><li>4 7 10 13</li><li>14 11 8</li><li>12 15</li><li>16</li></ul><p>要求：额外空间复杂度为O(1)</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><ul><li>创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角</li><li>指针A、B每次同时移动一格，移动规则为：<ul><li>指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动</li><li>指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动</li></ul></li><li>在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印)</li><li>最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束</li></ul><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 之字型打印矩阵</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-11-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZigZagPrintMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zigZagPrintMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt;= <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] indexA = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] indexB = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isAToB = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            printStraightLine(matrix,indexA,indexB,isAToB);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>) &amp;&amp; indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123; <span class="comment">//终点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新A、B坐标</span></span><br><span class="line">            <span class="keyword">if</span> (indexA[<span class="number">1</span>] == (matrix[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexA[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexA[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indexB[<span class="number">0</span>] == (matrix.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                indexB[<span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                indexB[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            isAToB = !isAToB;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印点A~B这条线的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printStraightLine</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span>[] indexA, <span class="keyword">int</span>[] indexB, <span class="keyword">boolean</span> isAToB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (indexA[<span class="number">0</span>] == indexB[<span class="number">0</span>] &amp;&amp; indexA[<span class="number">1</span>] == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">            System.out.println(matrix[indexA[<span class="number">0</span>]][indexA[<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能改变数组中的值,用变量代替</span></span><br><span class="line">        <span class="keyword">int</span> x = isAToB ? indexA[<span class="number">0</span>] : indexB[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = isAToB ? indexA[<span class="number">1</span>] : indexB[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (isAToB) &#123; <span class="comment">// 从A打印到B</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (x == indexB[<span class="number">0</span>] &amp;&amp; y == indexB[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从B打印到A</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.print(matrix[x][y]+<span class="string">"  "</span>);</span><br><span class="line">                <span class="keyword">if</span> (indexA[<span class="number">0</span>] == x &amp;&amp; indexA[<span class="number">1</span>] == y) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;, &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;, &#123; <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span> &#125; &#125;;</span><br><span class="line">        ZigZagPrintMatrix.zigZagPrintMatrix(matrix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.ax1x.com/2019/11/05/M9pE11.png" alt="M9pE11.png"></p><h2 id="Min栈的实现"><a href="#Min栈的实现" class="headerlink" title="Min栈的实现"></a>Min栈的实现</h2><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求：</p><ul><li>1．pop、push、peek、getMin操作的时间复杂度都是O(1)。</li><li>2．设计的栈类型可以使用现成的栈结构。</li></ul><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul><li>内部创建两个栈，data栈和min栈</li><li>元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是<strong>(min栈的栈顶存的永远是data栈中的最小值)</strong></li><li>出栈时data栈和min栈一起正常出栈</li><li>getMin()方法只需要返回min栈的栈顶元素</li></ul><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</span></span><br><span class="line"><span class="comment"> * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。</span></span><br><span class="line"><span class="comment"> *         2．设计的栈类型可以使用现成的栈结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CaiRui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019-10-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        data.push(num);</span><br><span class="line">        min.push((min.peek() &gt; num) ? num : min.peek());</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        min.pop();</span><br><span class="line">        <span class="keyword">return</span> data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些整理出了题解的常见算法题，代码都是自己写的&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法题" scheme="http://blog.cairui99.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程</title>
    <link href="http://blog.cairui99.cn/2020/06/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2020/06/01/Java并发编程/</id>
    <published>2020-06-01T02:39:50.000Z</published>
    <updated>2020-06-08T09:12:46.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是并发编程"><a href="#什么是并发编程" class="headerlink" title="什么是并发编程"></a>什么是并发编程</h3><a id="more"></a><p>并发是指同一个时间段内多个任务同时在执行，此时线程的数量一般是大于CPU核数的，当一个线程占用CPU运行时，其他任务就会被挂起，当占用CPU的线程时间片用完后，会保留当前线程执行的上下文，并把CPU让给其他线程使用。（其中上下文切换是有额外开销的）</p><p>如果是在双CPU配置下，两个线程同时运行，这种情况称为并行运行，而不会并发。</p><h3 id="Java中的线程安全问题"><a href="#Java中的线程安全问题" class="headerlink" title="Java中的线程安全问题"></a>Java中的线程安全问题</h3><p>产生线程安全问题的核心是多个线程间存在 <strong>共享资源：</strong> 共享资源是可以被多个线程所持有或者多个线程可以去访问的资源。</p><p>那么线程间存在共享资源的情况下，何时才会产生线程安全的问题呢？ 如果多个线程都只是读取共享资源，是不会产生线程安全问题的。  <strong>只有当至少一个线程修改共享资源时才会存在线程安全问题，</strong> 例如线程A在操作修改共享资源时，线程B读取到的值是没有同步的，此时线程A的修改结果还没有更新到主内存中，产生了线程安全问题。</p><h3 id="Java中共享变量的内存可见性问题"><a href="#Java中共享变量的内存可见性问题" class="headerlink" title="Java中共享变量的内存可见性问题"></a>Java中共享变量的内存可见性问题</h3><p>首先看看在多线程下的Java内存模型</p><p><img src="https://s1.ax1x.com/2020/06/01/tGHgzR.jpg" alt="tGHgzR.jpg"></p><p>Java内存模型规定，所有的变量都存放在主内存中，当线程使用变量时，会把主内存的变量复制到自己的工作空间或者叫工作内存中，当线程进行读写操作时操作的是自己工作内存中的变量，如果是写操作会在操作后将值更新到主内存的共享变量中。</p><h3 id="Java中的synchronized关键字"><a href="#Java中的synchronized关键字" class="headerlink" title="Java中的synchronized关键字"></a>Java中的synchronized关键字</h3><h4 id="synchronized介绍"><a href="#synchronized介绍" class="headerlink" title="synchronized介绍"></a>synchronized介绍</h4><p>synchronized块是Java提供的一种原子性内置锁，也叫监视器锁。</p><p>线程执行到synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者调用了wait系列方法时释放内置锁。</p><p>synchronized会阻塞和唤醒线程，线程需要进行上下文切换，是比较消耗性能的。</p><h4 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="headerlink" title="synchronized的内存语义"></a>synchronized的内存语义</h4><p>前面说了线程安全问题主要是共享变量在线程的工作内存的可见性问题导致的，下面说一下synchronized的内存语义：</p><ul><li>进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，也就是说在synchronized内使用的变量将不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。</li></ul><p>除了解决共享变量内存的可见性问题外，synchronized还经常被用来实现原子性操作。</p><h3 id="Java中的Lock锁"><a href="#Java中的Lock锁" class="headerlink" title="Java中的Lock锁"></a>Java中的Lock锁</h3><p>使用Java中的Lock，可以得到和synchronized相同的效果。</p><p>Lock是Java1.5后在java.util.concurrent.locks包下提供的一种实现同步的方法，那么显然的，synchronized一定是有什么做不到的或者缺陷，才导致了Lock的诞生。</p><h4 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h4><p>缺点如下：</p><ul><li>当一个代码块被synchronized修饰的时候，一个线程获取到了锁，并且执行代码块，那么其他的线程需要等待正在使用的线程释放掉这个锁，那么释放锁的方法只有两种，一种是代码执行完毕自动释放，一种是发生异常以后jvm会让线程去释放锁。那么如果这个正在执行的线程遇到什么问题，比如等待IO或者调用sleep方法等等被阻塞了，无法释放锁，而这时候其他线程只能一直等待，将会特别影响效率。</li><li>当一个文件，同时被多个线程操作时，读操作和写操作会发生冲突，写操作和写操作会发生冲突，而读操作和读操作并不会冲突，但是如果我们用synchronized的话，会导致一个线程在读的时候，其他线程想要读的话只能等待</li><li>在使用synchronized时，我们无法得知线程是否成功获取到锁</li></ul><p>Lock的出现则是为了解决如下问题。</p><h4 id="Lock锁概述"><a href="#Lock锁概述" class="headerlink" title="Lock锁概述"></a>Lock锁概述</h4><p>Lock锁，使用时手动获取锁和释放锁，比synchronized更加灵活；可中断的获取锁；超时获取锁。</p><p>Lock是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。</p><p>Lock 锁的基本用法， l.lock()方法进行上锁， l.unlock()方法进行解锁，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock(); <span class="comment">// 上锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock锁的Api"><a href="#Lock锁的Api" class="headerlink" title="Lock锁的Api"></a>Lock锁的Api</h4><p>Api如下：</p><ul><li><strong>void lock():</strong> 获得锁</li><li><strong>void lockInterruptibly​()：</strong> 获得锁，可中断。举个例子，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li><li><strong>boolean tryLock​()：</strong> 锁在空闲的才能获取锁（未获得锁不会等待）。举个例子：当两个线程同时通过lock.trylock()想获取某个锁时，假若此时线程A获取到了锁，而线程B不会等待，直接放弃获取锁。</li><li><strong>boolean tryLock​(long time, TimeUnit unit)：</strong> 如果锁定可用，则此方法立即返回值true。如果锁不可用，则当前线程将被禁用以进行线程调度，并且在发生以下三种情况之一之前处于休眠状态：<ul><li>当前线程获取锁</li><li>其他一些线程中断当前线程</li><li>等待时间过去了，返回false</li></ul></li><li><strong>void unlock()：</strong> 释放锁</li></ul><p>只看api就可以看出，lock锁相对于synchronized来说使用是非常灵活的。</p><h3 id="Java中的volatile关键字"><a href="#Java中的volatile关键字" class="headerlink" title="Java中的volatile关键字"></a>Java中的volatile关键字</h3><p>前面介绍了使用锁的方式来解决共享变量内存可见性问题，但是锁太笨重，会带来线程上下文切换的开销。因此对于内存可见性问题，Java还提供了一种弱形式的同步，就是 <strong>volatile</strong> 关键字。</p><p>volatile关键字关键字的作用是，可以让被volatile修饰的共享变量的更新对其他线程马上可见。当一个变量被volatile修饰时，线程在修改变量值时不会把值更新在私有内存中，而是更新到主内存里；当其他线程读取共享变量时，也是直接从主内存中读取共享变量的值。</p><p>volatile的内存语义就是：当线程每次写入时都会刷新主内存中的值，线程每次读取都会先去同步主内存中的值。</p><p>volatile虽然提供了可见性保证，但并不保证操作的原子性；一般在以下情况下考虑使用volatile关键字：</p><ul><li>修改变量时是直接修改的，而不是获取-计算-修改的这种过程的，因为volatile不能保证原子性</li><li>读写变量时没有加锁的，加锁就已经保证了内存可见性，此时就不需要将变量声明为volatile了</li></ul><h3 id="Java中的原子性操作"><a href="#Java中的原子性操作" class="headerlink" title="Java中的原子性操作"></a>Java中的原子性操作</h3><p>原子性操作指在执行一系列操作时，这些操作要么全部执行，要么全部不执行，不允许存在只执行其中一部分的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是并发编程&quot;&gt;&lt;a href=&quot;#什么是并发编程&quot; class=&quot;headerlink&quot; title=&quot;什么是并发编程&quot;&gt;&lt;/a&gt;什么是并发编程&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java注解/</id>
    <published>2020-05-18T09:33:13.000Z</published>
    <updated>2020-05-19T05:42:03.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><p>Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。</p><a id="more"></a><p>注解不同与注释，注解的内容会被嵌入到字节码中，我们可以通过反射来获取到注解内容。</p><h2 id="Java内置注解"><a href="#Java内置注解" class="headerlink" title="Java内置注解"></a>Java内置注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p><strong>作用在代码里的注解：</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p><strong>作用再其他注解上的注解（元注解）：</strong></p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p><strong>Java7之后新增的注解：</strong></p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><h3 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h3><p><a href="https://imgchr.com/i/Yhn4Vf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/18/Yhn4Vf.jpg" alt="Yhn4Vf.jpg"></a></p><p>可以看到，Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p><p>Annotation 的每一个实现类，都 <strong>和 1 个 RetentionPolicy 关联</strong> 并且 <strong>和 1~n 个 ElementType 关联</strong></p><h3 id="Annotation组成部分"><a href="#Annotation组成部分" class="headerlink" title="Annotation组成部分"></a>Annotation组成部分</h3><p>组成Annotation的三个类分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line"></span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line"></span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Annotation是个接口，实现类需要实现自该接口。</strong></p><p><strong>ElementType是Enum 枚举类型，它用来指定 Annotation 的类型：</strong> 当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p><p> <strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同：</strong></p><ul><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ul><h3 id="Annotation通用定义"><a href="#Annotation通用定义" class="headerlink" title="Annotation通用定义"></a>Annotation通用定义</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们自定义了一个注解，定义成功后，我们可以在代码中通过@MyAnnotation1来使用它。</p><p>其中@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的：</p><ul><li><strong>@interface</strong> ：使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。<strong>定义 Annotation 时，@interface 是必须的。</strong></li><li><strong>@Documented</strong> : 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</li><li><strong>@Target (ElementType.TYPE)</strong> : 用来指定 Annotation 的类型属性。@Target(ElementType.TYPE)意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。<strong>(定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方)</strong></li><li><strong>@Retention(RetentionPolicy.RUNTIME)</strong>: 指定 Annotation 的策略属性。@Retention(RetentionPolicy.RUNTIME) 的意思就是指编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<strong>(定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS)</strong></li></ul><p>总结：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型（ElementType），@Retention 用来指定 Annotation 的策略（RetentionPolicy）。</p><h3 id="java常用的Annotation"><a href="#java常用的Annotation" class="headerlink" title="java常用的Annotation"></a>java常用的Annotation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>继承性是指：我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了<br>MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p><h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><p>可以让编译器忽略掉某些警告，例如在方法中添加 <strong>@SuppressWarnings(value={“deprecation”})</strong> 后，在方法中使用了某些不赞成的类或方法时将不在给予警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure><h3 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用"></a>Annotation的作用</h3><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p><p>在编程中经常会使用到的 Annotation 作用有：</p><h4 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h4><p>例如，@SuppressWarnings , @Deprecated 和 @Override 都具有编译检查作用。</p><p>灵活使用注解可以让编译器发现或忽略特定的错误。</p><h4 id="在反射中使用Annotation"><a href="#在反射中使用Annotation" class="headerlink" title="在反射中使用Annotation"></a>在反射中使用Annotation</h4><p>可以通过 Method.getAnnotation(Class);来获取注解信息并使用。</p><h4 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h4><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>可以通过反射来获取到我们自定义的注解，来实现某些功能。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>参考自博客: <a href="https://www.cnblogs.com/skywang12345/p/3344137.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3344137.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java注解&quot;&gt;&lt;a href=&quot;#Java注解&quot; class=&quot;headerlink&quot; title=&quot;Java注解&quot;&gt;&lt;/a&gt;Java注解&lt;/h2&gt;&lt;p&gt;Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="注解" scheme="http://blog.cairui99.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java线程基础</title>
    <link href="http://blog.cairui99.cn/2020/05/18/Java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.cairui99.cn/2020/05/18/Java线程基础/</id>
    <published>2020-05-18T05:57:48.000Z</published>
    <updated>2020-06-02T11:10:25.718Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍：<strong>Java并发编程之美</strong></p><a id="more"></a><h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><p>讨论线程前必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。</p><p>进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p><p>操作系统在分配资源是是把资源分配给进程的，但是CPU资源比较特殊，它是分配给线程的，因为真正要占用CPU资源的是线程，所以也说 <strong>线程是CPU分配的基本单位</strong></p><p>在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是JVM进程中的一个线程，main函数线程也称为 <strong>主线程</strong></p><p><img src="https://s1.ax1x.com/2020/05/17/YRVXZQ.png" alt="YRVXZQ.png"></p><p>可以看到图中一个进程中有多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域。</p><p>程序计数器是用来记录线程当前要执行的指令地址，那为什么要记录呢?前面说了线程是占用CPU执行的基本单位，而CPU一般是使用时间片轮转的方式让线程轮询占用的，所以当前占有CPU资源的线程CPU时间片用完后就要让出CPU资源，等到下次轮到自己时再继续执行，所以此时就需要程序计数器记录该线程让出CPU时的执行地址，等到下次可以继续执行。</p><p>另外每个线程都有自己的栈资源，用于存储该线程的局部变量，这些都是该线程私有的，其他线程访问不了，除此之外还有用来存放线程的调用栈帧。</p><p>堆是进程中最大的一块内存，是所有线程共享的，里面主要存放使用new操作创建的对象实例。</p><p>方法区则用来存放JVM加载的类信息、常量、静态变量等信息，也是线程共享的。</p><h3 id="线程创建与运行"><a href="#线程创建与运行" class="headerlink" title="线程创建与运行"></a>线程创建与运行</h3><p>线程的创建有三种方式：</p><ul><li>继承Thread类，重写run方法</li><li>实现Runnable接口的run方法</li><li>实现Callable接口的call()方法</li></ul><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是创建线程时线程并没有启动，只有调用start方法时线程才会启动 <strong>（调用start方法后线程会处于就绪状态，需要等待获取cpu资源后才会真正处于运行状态）</strong> ，当run方法执行完毕，线程会处于终止状态。</p><p>使用继承的好处：在run()方法中直接使用this就可以直接获取当前线程；缺点是java不支持多继承，继承Thread类后无法继承其他类。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RunableTask task = <span class="keyword">new</span> RunableTask();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个线程共用了一个task代码逻辑，如果需要可以给RunableTask添加参数进行任务区分，同时RunableTask也可以继承其他类。</p><p>但还是有一个问题，就是任务没有返回值，下面给出实现Callable接口的方式</p><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="comment">//异步获取返回值</span></span><br><span class="line">    String result = futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set<br>方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线<br>程里面被声明为 final 变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类，<br>那么子类不能再继承其他类，而 Runable 则没有这个限制 。前两种方式都没办法拿到任务<br>的返回结果，但是 Futuretask 方式可以。</p><h3 id="线程的通知与等待"><a href="#线程的通知与等待" class="headerlink" title="线程的通知与等待"></a>线程的通知与等待</h3><p>线程的通知与等待相关的函数使用的是Object类中自带的方法，java中所有的类都可以使用。</p><h4 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h4><p>当一个线程调用一个共享变量的wait()方法时，该调用线程会被 <strong>阻塞挂起</strong>，同时释放掉该共享变量的监视器锁，唤醒被wait()方法挂起的线程的方法是：</p><ul><li>其他线程调用了该共享变量的notify()或notifyAll()方法</li><li>其他线程调用了该线程的interrupt()方法，该线程会抛出InterruptedException异常返回</li></ul><p>如果当前线程在调用共享变量的wait()时没有获取到该共享变量的监视器锁，此时会抛出IllegalMonitorStateException异常，一般使用synchronized关键字来拿到对象的监视器锁。</p><p>需要注意的是，使用wait()方法只会让线程释放掉该共享变量的锁，并不会释放线程持有的其他锁，下面是个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"threadA get resourceA lock"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadA get resourceB lock"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"threadA release resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"threadB get resourceA lock"</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"threadB get resourceB lock"</span>);</span><br><span class="line">                            System.out.println(<span class="string">"threadB release resourceA lock"</span>);</span><br><span class="line">                            resourceA.wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待两个线程执行结束</span></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main over"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadA get resourceA lock</span><br><span class="line">threadA get resourceB lock</span><br><span class="line">threadA release resourceA lock</span><br><span class="line">threadB get resourceA lock</span><br></pre></td></tr></table></figure><p>线程A在调用resourceA的wait()方法后释放了它锁持有的resourceA的监视器锁，但没有释放掉它所持有的其他共享变量的锁。</p><h4 id="wait-long-timeout-函数"><a href="#wait-long-timeout-函数" class="headerlink" title="wait(long timeout)函数"></a>wait(long timeout)函数</h4><p>如果线程在timeout的规定时间内没有被其他线程通过notify()或notifyAll()方法唤醒，那么该线程也会因为超时而被唤醒。</p><h4 id="notify-函数"><a href="#notify-函数" class="headerlink" title="notify()函数"></a>notify()函数</h4><p>当一个线程调用共享变量的notify()方法后，会随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。</p><p>被唤醒的线程不一定会继续执行，它必须先获取到共享对象的锁，但该线程可能需要和其他线程共同竞争这把锁。</p><p>同wait()方法，notify()方法也需要在获取到共享变量的监视器锁后，才可以调用，否则会抛异常。</p><h4 id="notifyAll-函数"><a href="#notifyAll-函数" class="headerlink" title="notifyAll()函数"></a>notifyAll()函数</h4><p>唤醒所有在该共享变量上调用wait系列方法被挂起的线程。</p><h3 id="等待线程执行终止的join方法"><a href="#等待线程执行终止的join方法" class="headerlink" title="等待线程执行终止的join方法"></a>等待线程执行终止的join方法</h3><p>join()方法是由Thread类提供的无参、无返回值的方法。</p><p>如果程序需要等待某个或多个线程执行完毕程序再继续往下执行的情况，此时可以用到join()方法来实现。</p><p>比如在main方法中，也是就使用主线程调用线程A的join方法，主线程就会被阻塞，等待线程A执行完毕后，主线程才会继续执行，</p><p>此时如果调用主线程在阻塞过程中调用了interrupt()方法，会抛出InterruptedException异常。</p><h3 id="让线程睡眠的sleep方法"><a href="#让线程睡眠的sleep方法" class="headerlink" title="让线程睡眠的sleep方法"></a>让线程睡眠的sleep方法</h3><p>sleep()是Thread类中的静态方法，调用的线程会让出指定时间的执行权，也就是这期间不参与CPU的调度，<strong>但该线程持有的监视器锁还是持有不让出的，</strong> sleep的执行时间过后，线程就会变为就绪状态，等待CPU的调度然后继续执行。</p><p>线程在sleep期间</p><h3 id="让出CPU执行权的yield方法"><a href="#让出CPU执行权的yield方法" class="headerlink" title="让出CPU执行权的yield方法"></a>让出CPU执行权的yield方法</h3><p>yield()方法是Thread类中的静态方法，相当于告诉线程调度器自己占有的时间片还没有使用完但是自己不想再使用了，暗示线程调度器现在可以进行下一轮的线程调度了。</p><p>当一个线程调用yield方法时，当前线程就会让出CPU使用权，然后变为就绪状态，线程调度器会从就绪队列中获取一个优先级最高的线程来给与CPU的执行权，当前这个优先级最高的线程也可能是刚刚调用yield方法的这个线程。</p><p>总结sleep和yield的区别，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，这期间线程调度器不会去调度该线程；而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到该线程执行。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>java中线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理：</p><ul><li><strong>void interrupt()方法：</strong> 中断线程，例如线程A在运行时，线程B可以调用线程A的interrupt()方法将线程A的中断标志置为true并立即返回，如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起时，线程A会抛出InterruptedException异常返回</li><li><strong>boolean isInterrupted()方法：</strong> 检测当前线程是否被中断</li><li><strong>boolean interrupted()方法：</strong> 检测当前线程是否被中断，与 isInterrupted()不同的是，如果发现线程被中断则清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。</li></ul><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>在多线程环境下，线程个数一般都大于CPU个数，而每个CPU同一时刻只能被一个线程使用，为了让用户感觉到所有线程是同时运行的，CPU资源的分配采用了时间片轮转的策略，也就是为每一个线程分配一个时间片，当前线程时间片用完后，线程会变为就绪状态并让出CPU让其他线程占用，这就是 <strong>上下文切换</strong></p><p>线程上下文切换时机有：</p><ul><li>当前线程的CPU时间片使用完，并处于就绪状态</li><li>当前线程被其他线程中断</li></ul><p>程序计数器会记录当前线程运行到哪里了，待下次执行时可以恢复执行现场。</p><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><strong>死锁必须具备的四个条件：</strong></p><ul><li>互斥条件：表示该资源同时只能由一个线程占用</li><li>请求并保持条件：指一个线程已经持有了至少一个资源，但又同时再请求新的资源，而新资源已被其他线程占有，当前线程就会被阻塞，并且不会释放自己持有的资源</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占</li><li>环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链</li></ul><p>下面是一个死锁的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceA"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main is finish"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get ResourceB</span><br></pre></td></tr></table></figure><p>可以看到程序并没有结束，而是两个线程都在互相请求对方持有的资源，永远的等待下去，构成了死锁状态</p><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h4><p>避免线程死锁只需破坏掉至少一个死锁的必要条件即可，目前只有请求并保持和环路等待条件是可以破坏的。</p><p>造成死锁的原因与申请资源的顺序有很大关系，使用资源申请的有序性原则就可以有效的避免死锁。</p><p>在上面死锁的例子中，只需要将线程B的代码进行如下修改，即可避免死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get ResourceA"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"waiting get ResourceB"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get ResourceB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0,5,main]get ResourceA</span><br><span class="line">Thread[Thread-0,5,main]waiting get resourceB</span><br><span class="line">Thread[Thread-0,5,main]get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceA</span><br><span class="line">Thread[Thread-1,5,main]waiting get ResourceB</span><br><span class="line">Thread[Thread-1,5,main]get ResourceB</span><br><span class="line">main is finish</span><br></pre></td></tr></table></figure><h3 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h3><p>Java中的线程分为两类，分别为 <strong>守护线程</strong> 和 <strong>用户线程</strong> ,在JVM启动时调用main函数所在的线程就是一个用户线程，同时JVM还会启动好多守护线程，例如垃圾回收线程。</p><p>守护线程与用户线程的区别是：</p><ul><li>当最后一个非守护线程结束时，JVM就会正常退出，也就是说守护线程是否结束并不影响JVM的退出。</li></ul><p>在Java中使用下面的方式创建守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread daemonThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    daemonThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    daemonThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程环境下访问同一个共享资源很容易出现并发问题，为了保证线程安全需要对共享变量进行同步。</p><p>同步的措施一般是加锁，但也可以使用ThreadLoacal的方式，使每个线程变量进行访问的时候访问的是自己线程的变量。</p><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有一个这个变量的本地副本，当操作变量时实际操作的是自己本地内存里的变量，从而避免了线程安全的问题。</p><h4 id="ThreadLocal使用示例"><a href="#ThreadLocal使用示例" class="headerlink" title="ThreadLocal使用示例"></a>ThreadLocal使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">        <span class="comment">//localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadOne local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadOne"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadOne remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                localVariable.set(<span class="string">"threadTwo local variable"</span>);</span><br><span class="line">                print(<span class="string">"threadTwo"</span>);</span><br><span class="line">                System.out.println(<span class="string">"threadTwo remove after"</span> + <span class="string">":"</span> + localVariable.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadTwo remove after:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadOne remove after:threadOne local variable</span><br></pre></td></tr></table></figure><p>去掉print方法中的注释后，输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">threadTwo:threadTwo local variable</span><br><span class="line">threadOne:threadOne local variable</span><br><span class="line">threadTwo remove after:null</span><br><span class="line">threadOne remove after:null</span><br></pre></td></tr></table></figure><p>没写完，待更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考书籍：&lt;strong&gt;Java并发编程之美&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="并发编程" scheme="http://blog.cairui99.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://blog.cairui99.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机</title>
    <link href="http://blog.cairui99.cn/2020/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://blog.cairui99.cn/2020/05/03/Java虚拟机/</id>
    <published>2020-05-03T13:39:38.000Z</published>
    <updated>2020-05-10T13:16:24.801Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍：<strong>深入理解java虚拟机（第三版）</strong></p><a id="more"></a><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java虚拟机简单来说就是Java的代码编译好之后，是跑在一台虚拟的机器（VM）上的，这台虚拟的机器负责分配内存和维护调用堆栈。</p><p>为什么要做成虚拟的机器这要从Java的一次编译到处执行来说。事实上一次编译到处执行是不可能的，因为每个机器不一样，所以传统上我们必须针对每一种机器编译代码，才能在这个机器上运行。而Java通过引入虚拟机（VM）的概念，让编译后的代码直接跑在一台虚拟的机器上，无论最终的目标平台是什么，都在上面构建出一个虚拟的一致的虚拟机出来，就可以达到一次编译到处执行的效果了。</p><h2 id="JVM内存模型与内存溢出异常"><a href="#JVM内存模型与内存溢出异常" class="headerlink" title="JVM内存模型与内存溢出异常"></a>JVM内存模型与内存溢出异常</h2><p>与C、C++不同，Java程序不再需要为每一个new操作去写配对的delete/free代码，在java中由JVM来帮忙管理、分配内存。</p><p>虽然jvm来管理内存带来了便利，不过一旦出现内存泄漏和溢出方面的问题，如果不了解java虚拟机是怎么使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>为了更好的理解java虚拟机的内存模型，我们把java虚拟机所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。</p><p>java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图：</p><p><img src="https://s1.ax1x.com/2020/05/03/Ypykhd.jpg" alt="Ypykhd.jpg"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>一块较小的内存空间，是<strong>线程私有</strong>的，可以看作是 <strong>当前线程所执行的字节码的行号指示器</strong></p><p>行号指示器就是在程序执行时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>与程序计数器一样，java虚拟机栈也是 <strong>线程私有的</strong> ，它的生命周期与线程相同。</p><p>虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个 <strong>栈帧</strong> ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。通常我们说的”栈”，一般是指java虚拟机栈中的 <strong>局部变量表</strong> 部分。</p><p><img src="https://s1.ax1x.com/2020/05/05/YF73ZT.png" alt="YF73ZT.png"></p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，例如递归函数没有被正常终止时；</p><p>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）</p><h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><p>栈帧（Stack Frame）是用于支持虚拟机进行 <strong>方法调用</strong> 和 <strong>方法执行</strong> 的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。</p><p>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。</p><p>在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p><img src="https://s1.ax1x.com/2020/05/05/YFqeiD.png" alt="YFqeiD.png"></p><p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为 <strong>当前栈帧</strong> ，与这个栈帧相关联的方法称为 <strong>当前方法</strong> 。</p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放 <strong>方法参数</strong> 和方法内部定义的 <strong>局部变量</strong> 。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。</p><p>局部变量表存放了编译期可知的各种基本数据类型，对象引用(reference类型) 和 returnAddress类型（它指向了一条字节码指令的地址）</p><p><strong>这里的变量仅指方法中的局部变量，成员变量是各个线程共享的，保存在堆中。</strong></p><h5 id="reference（对象实例的引用"><a href="#reference（对象实例的引用" class="headerlink" title="reference（对象实例的引用)"></a>reference（对象实例的引用)</h5><p>类似于一个超链接，如图：</p><p><img src="https://s1.ax1x.com/2020/05/05/YkMUV1.png" alt="YkMUV1.png"></p><h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><p>也就是方法被调用的位置，在方法退出时将返回值传递给上层的方法调用者。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈所发挥得作用是相同的。区别是java虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是 <strong>为虚拟机使用到本地（Native）方法服务</strong> 。</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>java堆是虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域。用来 <strong>存放对象实例。</strong></p><p>java堆也是垃圾收集器管理的内存区域，所以java堆中经常出现新生代、老年代、永久代等名词。</p><p>根据虚拟机的规范，java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视作为连续的，类似于磁盘存储。</p><p>java堆是可以实现扩展的，通过参数-Xmx和-Xms设定，如果堆中还没有完成内存分配并且无法扩展时，java虚拟机会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和堆一样，方法区是一块所有线程共享的内存区域。</p><p>方法去用来保存<strong>类的信息</strong>。比如类的字段、方法、常量池等。方法区的大小决定系统可以保存多少个类。如果系统</p><p>定义太多的类，导致方法区溢出。虚拟机同样会抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分，用于存放编译期生成的字面量与符号引用。</p><p>字面量相当于java语言中常量的概念；</p><p>符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考书籍：&lt;strong&gt;深入理解java虚拟机（第三版）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.cairui99.cn/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://blog.cairui99.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitHub_Page自定义域名失效问题</title>
    <link href="http://blog.cairui99.cn/2020/04/28/GitHub-Page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/28/GitHub-Page自定义域名失效问题/</id>
    <published>2020-04-28T14:37:19.000Z</published>
    <updated>2020-04-28T14:40:12.566Z</updated>
    
    <content type="html"><![CDATA[<p>使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置</p><p>解决方法： <strong>在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更新域名了</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置&lt;/p&gt;
&lt;p&gt;解决方法： &lt;strong&gt;在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode 每日一题</title>
    <link href="http://blog.cairui99.cn/2020/04/26/LeetCode-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2020/04/26/LeetCode-每日一题/</id>
    <published>2020-04-26T13:46:10.000Z</published>
    <updated>2020-06-11T10:46:07.400Z</updated>
    
    <content type="html"><![CDATA[<p>每天有空的话就做一道题，记录一下</p><a id="more"></a><h3 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并K个排序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> is_end = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!is_end) &#123;</span><br><span class="line">            is_end = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">                ListNode listNode = lists[i];</span><br><span class="line">                <span class="keyword">if</span> (listNode != <span class="keyword">null</span> &amp;&amp; listNode.val &lt; min) &#123;</span><br><span class="line">                    is_end = <span class="keyword">false</span>;</span><br><span class="line">                    min = listNode.val;</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!is_end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    head = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="keyword">new</span> ListNode(lists[index].val);</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125;</span><br><span class="line">                lists[index] = lists[index].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 搜索旋转排序数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (front &lt;= back) &#123;</span><br><span class="line">            mid = (front + back) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> scope = <span class="keyword">this</span>.getScope(nums, mid, front, back, target);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">1</span>) &#123;</span><br><span class="line">                back = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == <span class="number">2</span>) &#123;</span><br><span class="line">                front = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缩小target的范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int -1=&gt;不存在，0=&gt;中间，1=&gt;左边, 2=&gt;右边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getScope</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> front, <span class="keyword">int</span> back, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[front];</span><br><span class="line">        <span class="keyword">int</span> right = nums[back];</span><br><span class="line">        <span class="keyword">int</span> middle = nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (middle == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123; <span class="comment">//数组没有被旋转过</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; target &amp;&amp; middle &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &lt; target &amp;&amp; right &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (middle &gt; target &amp;&amp; middle &lt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (middle &lt; target &amp;&amp; middle &gt; right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中数字出现的次数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            k ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得k中最低位的1</span></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((k &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="comment">//分组</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; mask) == <span class="number">0</span>) &#123;</span><br><span class="line">                answer[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                answer[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（工作忙，鸽了两天。。。心态崩了）</strong></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序链表</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/merge-two-sorted-lists/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> caiui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1.val;</span><br><span class="line">            <span class="keyword">int</span> val2 = l2.val;</span><br><span class="line">            min = Math.min(val1, val2);</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(min);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = val1 &gt;= val2 ? l1 : l1.next;</span><br><span class="line">            l2 = val1 &lt;  val2 ? l2 : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.next = <span class="keyword">new</span> ListNode(next.val);</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nowLength = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(strs[j]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    nowLength++;</span><br><span class="line">                    map.put(strs[j], strs[j]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nowLength &gt; maxLength) &#123;</span><br><span class="line">                maxLength = nowLength;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strs.length - i - <span class="number">1</span>) &lt;= maxLength) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大子序和</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            now = (num + now &lt; <span class="number">0</span>) ? num : num + now;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; max) &#123;</span><br><span class="line">                max = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃游戏 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/jump-game-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> new_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = (index + nums[index]); i &gt; index; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= (nums.length - <span class="number">1</span>)) &#123;</span><br><span class="line">                    new_index = nums.length;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] - count) &gt; max) &#123;</span><br><span class="line">                    max = nums[i] - count;</span><br><span class="line">                    new_index = i;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            jump++;</span><br><span class="line">            index = new_index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证二叉搜索树</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/validate-binary-search-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution98</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = node.val;</span><br><span class="line">        <span class="keyword">if</span> (lower != <span class="keyword">null</span> &amp;&amp; val &lt;= lower) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (upper != <span class="keyword">null</span> &amp;&amp; val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!helper(node.right, val, upper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(node.left, lower, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最低票价"><a href="#最低票价" class="headerlink" title="最低票价"></a>最低票价</h3><p>待优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最低票价</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/minimum-cost-for-tickets/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution983</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getWeekCount(<span class="keyword">int</span>[] days, <span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] weekCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> week = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next_day = days[index] + <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> day = days[index++];</span><br><span class="line">            <span class="keyword">if</span> (day &lt;= next_day) &#123;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next_day = next_day + <span class="number">7</span>;</span><br><span class="line">                week++;</span><br><span class="line">                <span class="keyword">if</span> (week == <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                weekCount[week]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weekCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">int</span>[] costs, <span class="keyword">int</span>[] weekCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weekCount.length; i++) &#123;</span><br><span class="line">            money += Math.min(weekCount[i] * costs[<span class="number">0</span>], costs[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextMonthIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next_Month_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> next_Month = days[index] + <span class="number">29</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; days.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (days[i] &gt; next_Month) &#123;</span><br><span class="line">                next_Month_index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next_Month_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; days.length) &#123;</span><br><span class="line">            <span class="comment">//一个月内每周都有多少天</span></span><br><span class="line">            <span class="keyword">int</span>[] weekCount = <span class="keyword">this</span>.getWeekCount(days, index);</span><br><span class="line">            money += Math.min(<span class="keyword">this</span>.getMoney(costs, weekCount), costs[<span class="number">2</span>]);</span><br><span class="line">            index = <span class="keyword">this</span>.getNextMonthIndex(index, days);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pow(x, n)</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/powx-n/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution50</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> pow = x;</span><br><span class="line">        <span class="keyword">long</span> multiple = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (multiple != Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple * <span class="number">2</span> &lt;= Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                pow = pow * pow;</span><br><span class="line">                multiple = multiple * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">double</span> temp = pow;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((multiple + (multiple - count)) &gt; Math.abs((<span class="keyword">long</span>)n)) &#123;</span><br><span class="line">                    temp = temp / x;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                pow = pow * temp;</span><br><span class="line">                multiple += (multiple - count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (multiple == <span class="number">0</span>) &#123;</span><br><span class="line">                pow = Double.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pow = <span class="number">1</span> / pow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataStructure.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution102</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isContinue = <span class="keyword">false</span>;</span><br><span class="line">                List&lt;TreeNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (nodeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    nodeList.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode treeNode : nodeList) &#123;</span><br><span class="line">                    integerList.add(treeNode.val);</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.left);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newNodeList.add(treeNode.right);</span><br><span class="line">                        isContinue = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                answer.add(integerList);</span><br><span class="line">                nodeList = newNodeList;</span><br><span class="line">                <span class="keyword">if</span> (!isContinue) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/single-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            num = num ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a>课程表 II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程表 II</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/course-schedule-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = list.get(prerequisite[<span class="number">0</span>]);</span><br><span class="line">            temp.add(prerequisite[<span class="number">1</span>]);</span><br><span class="line">            list.set(prerequisite[<span class="number">0</span>], temp);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.get(i).size() == <span class="number">0</span> &amp;&amp; map.get(i) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map.put(i, i);</span><br><span class="line">                    answer[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> isStudy = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = list.get(i);</span><br><span class="line">                <span class="keyword">int</span> begin = temp.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = temp.get(j);</span><br><span class="line">                    <span class="keyword">if</span> (map.get(num) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isStudy = <span class="keyword">true</span>;</span><br><span class="line">                        temp.remove(j);</span><br><span class="line">                        list.set(i, temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isStudy) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乘积最大子数组</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/maximum-product-subarray/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> negativeCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[index++];</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    isZero = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    negativeCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negativeCount % <span class="number">2</span> == <span class="number">0</span> || temp.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">this</span>.getProduct(temp);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                ArrayList&lt;Integer&gt; temp2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//第一个负数的位置</span></span><br><span class="line">                <span class="keyword">int</span> negativeIndex = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp.get(i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        negativeIndex = (negativeIndex == -<span class="number">1</span>) ? i : negativeIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (count == negativeCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp1.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = negativeIndex + <span class="number">1</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                    temp2.add(temp.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                negative = Math.max(<span class="keyword">this</span>.getProduct(temp1), <span class="keyword">this</span>.getProduct(temp2));</span><br><span class="line">            &#125;</span><br><span class="line">            answer = Math.max(negative, answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (answer &lt; <span class="number">0</span> &amp;&amp; isZero) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getProduct</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            answer = answer * integer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证回文字符串-Ⅱ"><a href="#验证回文字符串-Ⅱ" class="headerlink" title="验证回文字符串 Ⅱ"></a>验证回文字符串 Ⅱ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证回文字符串 Ⅱ</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/valid-palindrome-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution680</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back  = strs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front] != strs[back]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(strs, front + <span class="number">1</span>, back)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(strs, front, back - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span>[] strs, <span class="keyword">int</span> front, <span class="keyword">int</span> back)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[front++] != strs[back--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找两个正序数组的中位数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isOdd = (nums1.length + nums2.length) % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (nums1.length + nums2.length) / <span class="number">2</span>;</span><br><span class="line">        midIndex = isOdd ? midIndex : midIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; nums1.length &amp;&amp; index2 &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">double</span> num = (nums1[index1] &lt;= nums2[index2]) ? nums1[index1++] : nums2[index2++];</span><br><span class="line">            <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() != <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() != <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] nums = index1 &lt; nums1.length ? nums1 : nums2;</span><br><span class="line">            <span class="keyword">int</span> index = index1 &lt; nums1.length ? index1 : index2;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == midIndex || count == midIndex + <span class="number">1</span>) &#123;</span><br><span class="line">                    list.add((<span class="keyword">double</span>) nums[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> ((isOdd &amp;&amp; list.size() == <span class="number">1</span>) || (!isOdd &amp;&amp; list.size() == <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  list.size() == <span class="number">1</span> ? list.get(<span class="number">0</span>) : (list.get(<span class="number">0</span>) + list.get(<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU缓存机制</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/lru-cache/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; keyList   = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; valueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.valueList.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isExist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.get(i) == key) &#123;</span><br><span class="line">                isExist = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(i, value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isExist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyList.size() &lt; <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">                <span class="keyword">this</span>.keyList.add(key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.add(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> minCount = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.keyList.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = countMap.get(keyList.get(i));</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; minCount) &#123;</span><br><span class="line">                        minCount = count;</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.keyList.set(index, key);</span><br><span class="line">                <span class="keyword">this</span>.valueList.set(index, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.countMap.put(key, <span class="keyword">this</span>.count++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找重复数</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/find-the-duplicate-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-05-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution287</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == i &amp;&amp; ++count == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拥有最多糖果的孩子"><a href="#拥有最多糖果的孩子" class="headerlink" title="拥有最多糖果的孩子"></a>拥有最多糖果的孩子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拥有最多糖果的孩子</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1431</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; answerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; candy) &#123;</span><br><span class="line">                max = candy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies) &#123;</span><br><span class="line">            answerList.add(candy + extraCandies &gt;= max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求1+2+…+n</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/qiu-12n-lcof/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution64</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新21点"><a href="#新21点" class="headerlink" title="新21点"></a>新21点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新21点</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/new-21-game/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution837</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] probabilityFront = <span class="keyword">new</span> <span class="keyword">double</span>[K + W -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> basisProbability = <span class="number">1</span> / (<span class="keyword">double</span>)W;</span><br><span class="line">        <span class="keyword">double</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算抽到 1 ~ (K + W) 的概率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= (K + W - <span class="number">1</span>); num++) &#123;</span><br><span class="line">            <span class="keyword">double</span> probability = (num &lt;= W) &amp;&amp; (K &gt; <span class="number">0</span>) ? basisProbability : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> begin = (num &gt; (K - <span class="number">1</span>)) ? (K - <span class="number">1</span>) : (num - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num2 = begin; num2 &gt;= <span class="number">1</span>; num2--) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num - num2) &gt; W) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                probability += probabilityFront[num2 - <span class="number">1</span>] * basisProbability;</span><br><span class="line">            &#125;</span><br><span class="line">            probabilityFront[num - <span class="number">1</span>] = probability;</span><br><span class="line">            <span class="comment">// 记录超过N的概率</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; N) &#123;</span><br><span class="line">                answer += probability;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 除自身以外数组的乘积</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/product-of-array-except-self/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution238</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 左边数的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] left   = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            left[i] = (i == <span class="number">0</span>) ? <span class="number">1</span> : (left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右边数的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] right  = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right[i] = (i == (nums.length - <span class="number">1</span>)) ? <span class="number">1</span> : right[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 答案等于左边的乘积乘上右边的乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            answer[i] = left[i] * right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（今天开始每日一题如果出现频率太低就不做了，选一个高频题来做）</p><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charp = p.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.checkIsMatch(chars, charp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIsMatch</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">char</span>[] charp, <span class="keyword">int</span> indexS, <span class="keyword">int</span> indexP)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (indexS &lt; chars.length &amp;&amp; indexP &lt; charp.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((indexP + <span class="number">1</span> &lt; charp.length) &amp;&amp; charp[indexP + <span class="number">1</span>] == <span class="string">'*'</span>) &#123; <span class="comment">//带*的情况</span></span><br><span class="line">                <span class="keyword">char</span> str = charp[indexP];</span><br><span class="line">                <span class="keyword">int</span> tempIndex = indexS;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt;= (chars.length - indexS); count++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; (chars[tempIndex++] != str) &amp;&amp; str != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.checkIsMatch(chars, charp, tempIndex, indexP + <span class="number">2</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不带*，只需判断字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> ((chars[indexS] != charp[indexP]) &amp;&amp; charp[indexP] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                indexS++;</span><br><span class="line">                indexP++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉charp中的*</span></span><br><span class="line">        <span class="keyword">while</span> (indexP &lt; charp.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexP + <span class="number">1</span> &lt; charp.length &amp;&amp; charp[indexP + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                indexP += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> indexS &gt;= chars.length &amp;&amp; indexP &gt;= charp.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三数之和</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution15</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(List&lt;Integer&gt; list, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">3</span>; p++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == i || p == j) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (map.get(list.get(i) + <span class="string">" "</span> + list.get(j) + <span class="string">" "</span> + list.get(p)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((nums[i] + nums[left] + nums[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((nums[i] + nums[left] + nums[right]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.isExist(list, map)) &#123; <span class="comment">//去重</span></span><br><span class="line">                        answer.add(list);</span><br><span class="line">                        map.put(list.get(<span class="number">0</span>) + <span class="string">" "</span> + list.get(<span class="number">1</span>) + <span class="string">" "</span> + list.get(<span class="number">2</span>), <span class="string">""</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解数独</span></span><br><span class="line"><span class="comment"> * https://leetcode-cn.com/problems/sudoku-solver/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cairui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-06-11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.solve(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt; <span class="number">10</span>; num++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.check(board, i, j, (<span class="keyword">char</span>) (num + <span class="string">'0'</span>))) &#123;</span><br><span class="line">                        board[i][j] = (<span class="keyword">char</span>) (num + <span class="string">'0'</span>);</span><br><span class="line">                        <span class="keyword">this</span>.solve(board, i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123; <span class="comment">//没有匹配到合适的数字，需要回溯</span></span><br><span class="line">                    board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//num是否满足插入需求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//行、列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x][i] == num || board[i][y] == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3*3正方形区域</span></span><br><span class="line">        <span class="keyword">int</span> indexI = (x / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> indexJ = (y / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = indexI; i &lt; indexI + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j =indexJ; j &lt; indexJ + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == num) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每天有空的话就做一道题，记录一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.cairui99.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux-ping通ip但ping不通域名</title>
    <link href="http://blog.cairui99.cn/2020/02/27/Linux-ping%E9%80%9Aip%E4%BD%86ping%E4%B8%8D%E9%80%9A%E5%9F%9F%E5%90%8D/"/>
    <id>http://blog.cairui99.cn/2020/02/27/Linux-ping通ip但ping不通域名/</id>
    <published>2020-02-27T06:51:10.000Z</published>
    <updated>2020-02-27T06:53:38.384Z</updated>
    
    <content type="html"><![CDATA[<p>原因：机器的域名解析有问题</p><p>解决方法：修改DNS配置</p><ul><li>sudo vi /etc/resolv.conf</li><li>添加  nameserver 8.8.8.8</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原因：机器的域名解析有问题&lt;/p&gt;
&lt;p&gt;解决方法：修改DNS配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sudo vi /etc/resolv.conf&lt;/li&gt;
&lt;li&gt;添加  nameserver 8.8.8.8&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr服务器搭建</title>
    <link href="http://blog.cairui99.cn/2020/01/03/ssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.cairui99.cn/2020/01/03/ssr服务器搭建/</id>
    <published>2020-01-03T07:28:52.000Z</published>
    <updated>2020-02-27T06:50:01.709Z</updated>
    
    <content type="html"><![CDATA[<p>搭建代理服务器前首先要有一台自己的机器，我是在这里办的 <a href="https://my.vultr.com/" target="_blank" rel="noopener">https://my.vultr.com/</a> ，优点是可以随时注销、随时办理，按小时收费。</p><a id="more"></a><p>有了自己的服务器后，登陆进去，依次输入下面几条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>运行成功后，会提示你设置你代理的密码、端口、协议等信息：</p><ul><li>如提示（Please enter password for ShadowsocksR）：设置密码，自己设定</li><li>如提示（Please enter a port for ShadowsocksR [1-65535]）：设置服务器端口，如不设定会随机生成</li><li>如提示（Please select stream cipher for ShadowsocksR）：设置加密方式，建议 <strong>chacha20</strong></li><li>如提示（Please select protocol for ShadowsocksR）：设置协议，默认为 <strong>origin</strong></li><li>如提示（Please select obfs for ShadowsocksR）：选择混淆方式，建议选择 <strong>http_simple</strong></li><li>至此所有配置已经设置完成，等待几分钟，配置成功会显示出所有配置信息，建议截图保存，以免遗忘</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建代理服务器前首先要有一台自己的机器，我是在这里办的 &lt;a href=&quot;https://my.vultr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.vultr.com/&lt;/a&gt; ，优点是可以随时注销、随时办理，按小时收费。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用natapp实现内网穿透功能</title>
    <link href="http://blog.cairui99.cn/2019/12/12/linux-%E4%BD%BF%E7%94%A8natapp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://blog.cairui99.cn/2019/12/12/linux-使用natapp实现内网穿透功能/</id>
    <published>2019-12-12T06:07:07.000Z</published>
    <updated>2019-12-31T06:55:31.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单</p><a id="more"></a><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><h4 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h4><p>前往官网 <a href="https://natapp.cn/" target="_blank" rel="noopener">https://natapp.cn/</a> 注册账号，并登录</p><p><a href="https://imgchr.com/i/Q4tFIS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q4tFIS.md.png" alt="Q4tFIS.md.png"></a></p><h4 id="购买隧道"><a href="#购买隧道" class="headerlink" title="购买隧道"></a>购买隧道</h4><ol><li>登陆成功后，进入个人中心选择购买隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4N9SJ.png" alt="Q4N9SJ.png"></p><ol start="2"><li>个人使用选择：免费隧道</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UK4U.png" alt="Q4UK4U.png"></p><ol start="3"><li>隧道协议选择：Web  点击免费购买（注：免费隧道的域名会随机更换，所以不适合长期使用，这里仅用来测试）</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q4UDvd.png" alt="Q4UDvd.png"></p><h4 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h4><ol><li>进入官网的客户端下载，选择linux</li></ol><p><img src="https://s2.ax1x.com/2019/12/16/Q40nsJ.png" alt="Q40nsJ.png"></p><ol start="2"><li>下载并解压，解压后获得一个natapp的文件</li></ol><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>至此环境已经部署完成，下面开始运行natapp</p><h4 id="获取authtoken"><a href="#获取authtoken" class="headerlink" title="获取authtoken"></a>获取authtoken</h4><p>点击我的隧道，可以查看隧道的authtoken，用来启动客户端</p><p><img src="https://s2.ax1x.com/2019/12/17/QoEWbd.png" alt="QoEWbd.png"></p><h4 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h4><p>进入natapp所在目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./natapp -authtoken=xxx</span><br></pre></td></tr></table></figure><p>可以看到客户端启动成功，Forwarding下的网址就是你的外网域名</p><p><img src="https://s2.ax1x.com/2019/12/17/Qot8c4.png" alt="Qot8c4.png"></p><h3 id="后台运行natapp"><a href="#后台运行natapp" class="headerlink" title="后台运行natapp"></a>后台运行natapp</h3><p>直接启动natapp有一个缺点，就是当终端窗口关闭或者ctrl+c的时候natapp进程会被终止，这时需要natapp在后台异步执行</p><p>虽然官网给出了后台运行的方案和教程： <strong>nohup + 命令 + &amp;</strong></p><p>但使用这种方式后我们需要的获取到的域名却不知道上哪里找了，虽然能后台运行了，但获取不到域名我运行你干什么。。。</p><p><strong>解决方案：</strong></p><ul><li>在natapp客户端的同级目录下引入一个config.ini的文件，下载地址：<a href="http://download.natapp.cn/assets/downloads/config.ini" target="_blank" rel="noopener">http://download.natapp.cn/assets/downloads/config.ini</a></li><li>打开config.ini，将<strong>loglevel</strong>的值设置为<strong>INFO</strong></li><li>执行命名：<strong>nohup ./natapp -authtoken=xxx &amp;</strong></li><li>此时在目录下会生成一个nohup.out的日志文件，打开即可查看到你的外网域名</li></ul><p><a href="https://imgchr.com/i/lEFJw8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEFJw8.md.png" alt="lEFJw8.md.png"></a></p><p>使用ps命令查看进程状态，发现natapp已经在后台运行了：<br><a href="https://imgchr.com/i/l12RYt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/31/l12RYt.md.png" alt="l12RYt.md.png"></a></p><p>需要注意的是，免费隧道的域名不是永久有效的，natapp可能随时会将你的域名强制更换，这时还需要到日志中查找最新的域名，所以如果想要稳定的服务还是需要购买付费隧道。</p><p>当然域名换的也不会很频繁，临时测试的话免费的就够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>linux后台运行php常驻进程</title>
    <link href="http://blog.cairui99.cn/2019/12/11/php-linux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8Cphp%E5%B8%B8%E9%A9%BB%E8%BF%9B%E7%A8%8B/"/>
    <id>http://blog.cairui99.cn/2019/12/11/php-linux后台运行php常驻进程/</id>
    <published>2019-12-11T06:54:11.000Z</published>
    <updated>2019-12-12T05:56:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行</p><a id="more"></a><h4 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h4><p>加在一个命令的最后，可以把这个命令放在后台执行</p><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使用 <strong>&amp;</strong> 命令使程序在后台执行，当终端关闭时程序会被终止，这时需要使用nohup命令，可以在你退出账户/关闭终端之后继续运行相应的进程。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohub 命令 &gt; /home/user/log/xxx.log &amp;</span><br></pre></td></tr></table></figure><p>在使用nohup命令时，该程序所有的输出默认会被重定向到一个名为nohup.out的文件中，除非指定了输出文件，比如上面的/home/user/log/xxx.log</p><h4 id="查看进程-amp-杀死进程"><a href="#查看进程-amp-杀死进程" class="headerlink" title="查看进程&amp;杀死进程"></a>查看进程&amp;杀死进程</h4><p>使用命令ps查看进程运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep xxx</span><br></pre></td></tr></table></figure><p>xxx代表命令的关键字，如果命令在运行则可以得到进程的pid</p><p>使用命令kill，杀死进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill pid</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://blog.cairui99.cn/categories/linux/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
      <category term="linux命令" scheme="http://blog.cairui99.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="http://blog.cairui99.cn/2019/12/04/%E9%80%BB%E8%BE%91%E9%A2%98-%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.cairui99.cn/2019/12/04/逻辑题-赛马问题/</id>
    <published>2019-12-04T03:48:08.000Z</published>
    <updated>2019-12-04T07:03:40.372Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><p>64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？</p><a id="more"></a><p>下面是我的思路，不能保证是最优解：</p><ul><li>所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234</li><li>把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123</li><li>将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况：<ul><li>前3名全部来自于第1名的小组，前三名直接晋级，只需比 <strong>10场</strong></li><li>前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 <strong>11场</strong></li></ul></li></ul><p> 题目中问最少，所以答案应是 <strong>10场。</strong></p><p> 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="逻辑题" scheme="http://blog.cairui99.cn/tags/%E9%80%BB%E8%BE%91%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>检查是否安装某种php扩展</title>
    <link href="http://blog.cairui99.cn/2019/11/27/php-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%9F%90%E7%A7%8Dphp%E6%89%A9%E5%B1%95/"/>
    <id>http://blog.cairui99.cn/2019/11/27/php-检查是否安装某种php扩展/</id>
    <published>2019-11-27T08:21:22.000Z</published>
    <updated>2019-11-27T08:26:37.687Z</updated>
    
    <content type="html"><![CDATA[<p>1、linux下使用命令：php -m 可列出已安装的php扩展</p><p>2、使用phpInfo()函数，可展示已安装的php扩展</p><p>3、使用如下代码验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$extension= <span class="string">''</span>; <span class="comment">//需要验证的某种扩展</span></span><br><span class="line"><span class="keyword">if</span> (extension_loaded($extension)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'开启了扩展'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'没有开启扩展'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、linux下使用命令：php -m 可列出已安装的php扩展&lt;/p&gt;
&lt;p&gt;2、使用phpInfo()函数，可展示已安装的php扩展&lt;/p&gt;
&lt;p&gt;3、使用如下代码验证：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="操作" scheme="http://blog.cairui99.cn/categories/%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="php" scheme="http://blog.cairui99.cn/tags/php/"/>
    
  </entry>
  
</feed>
