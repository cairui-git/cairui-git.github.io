{"meta":{"title":"CaiRui的博客","subtitle":"坚持是一种品格","description":null,"author":"CaiRui","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-04T11:29:31.000Z","updated":"2019-09-06T07:18:57.504Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"待更新"},{"title":"categories","date":"2019-09-04T11:34:44.000Z","updated":"2019-09-06T07:19:01.112Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T11:26:46.000Z","updated":"2019-09-06T07:19:03.047Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序算法-冒泡排序","slug":"排序算法-冒泡排序","date":"2019-09-17T03:45:02.000Z","updated":"2019-09-17T07:09:34.998Z","comments":true,"path":"2019/09/17/排序算法-冒泡排序/","link":"","permalink":"http://yoursite.com/2019/09/17/排序算法-冒泡排序/","excerpt":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止","text":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止 思路 比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数 重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数 针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; //冒泡排序 public static int[] bubbleSort(int[] arr)&#123; for(int i=0;i&lt;=arr.length;i++)&#123; boolean is_change = false; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr, j, j+1); is_change = true; &#125; &#125; //如果一次完整的遍历中,没有触发过交换，则数组已经有序 if(!is_change)&#123; break; &#125; &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 我们写一个测试函数，在后续的排序算法中也复用该函数 12345678910111213141516171819202122232425262728293031323334public class SortTest &#123; /** * 获取一个随机数组 * @param length 数组长度 * @param min 最小值 * @param max 最大值 */ private static int[] getArray(int length,int min,int max)&#123; int[] arr = new int[length]; for(int i=0;i&lt;length;i++)&#123; arr[i] = (int)(min+Math.random()*(max-min+1)); &#125; return arr; &#125; //输出数组 private static void printArray(int[] arr)&#123; for(int num : arr)&#123; System.out.print(num+\" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[] arr = SortTest.getArray(10, 1, 20); System.out.print(\"随机产生的数组 : \"); SortTest.printArray(arr); System.out.println(); System.out.print(\"冒泡排序后的数组 : \"); SortTest.printArray(BubbleSort.bubbleSort(arr)); &#125;&#125; 输出结果： 123随机产生的数组 : 7 1 5 16 12 2 6 11 7 6冒泡排序后的数组 : 1 2 5 6 6 7 7 11 12 16 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1)","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"Redis常用数据结构&应用场景","slug":"Redis常用数据结构-应用场景","date":"2019-09-12T08:25:12.000Z","updated":"2019-09-16T06:21:21.765Z","comments":true,"path":"2019/09/12/Redis常用数据结构-应用场景/","link":"","permalink":"http://yoursite.com/2019/09/12/Redis常用数据结构-应用场景/","excerpt":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。","text":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。 应用场景String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。 Hash常用命令 hget($key,$field) 返回hash表中指定字段的值 hset($key,$field,$value) 设置hash中指定字段的值 hgetall($key) 返回指定key下，哈希表中所有字段和值 实现Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。 应用场景当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。 List常用命令 lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部 rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部 lpop($key) 移除指定列表的第一个元素 rpop($key) 移除指定列表的最后一个元素 lrange($key,$start,$stop) 获取指定列表指定范围内的元素 blpop($key,$timeOut) 移除指定列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 实现Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。 应用场景最新消息排行; 消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。 SetSet集合的特点是在插入元素时Redis会提供去重的功能 常用命令 sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，已经存在与集合中的元素将被忽略 spop($key) 移除集合中的一个随机元素 srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略 smembers($key) 获取指定集合中的所有元素 sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集 sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集 实现set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重 应用场景用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。 SortSet有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点 常用方法 zadd zrange zrem zcard 实现sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。 应用场景可以用于需要不重复、有序的场景中。例如各种排行榜 延迟队列 (如何实现延迟队列后续详细介绍)","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://yoursite.com/categories/知识点整理/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"php中字符串与0比较问题","slug":"php中字符串与0比较问题","date":"2019-09-06T03:29:27.000Z","updated":"2019-09-06T05:49:52.518Z","comments":true,"path":"2019/09/06/php中字符串与0比较问题/","link":"","permalink":"http://yoursite.com/2019/09/06/php中字符串与0比较问题/","excerpt":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。","text":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = \"CaiRui\";if($str==0)&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = \"CaiRui\";if($str===0)&#123; echo \"===0成立\";&#125;else&#123; echo \"===0不成立\";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = \"CaiRui\";if($str==\"0\")&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。","categories":[{"name":"问题整理","slug":"问题整理","permalink":"http://yoursite.com/categories/问题整理/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"单一职责原则","slug":"单一职责原则","date":"2019-09-04T12:18:10.000Z","updated":"2019-09-06T03:27:17.774Z","comments":true,"path":"2019/09/04/单一职责原则/","link":"","permalink":"http://yoursite.com/2019/09/04/单一职责原则/","excerpt":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法）","text":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://yoursite.com/categories/知识点整理/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"设计思想","slug":"设计思想","permalink":"http://yoursite.com/tags/设计思想/"}]},{"title":"设计模式开篇","slug":"设计模式开篇","date":"2019-09-02T10:23:46.000Z","updated":"2019-09-12T09:49:57.553Z","comments":true,"path":"2019/09/02/设计模式开篇/","link":"","permalink":"http://yoursite.com/2019/09/02/设计模式开篇/","excerpt":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？","text":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是，设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring、Yii这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望在不久的将来，通过对设计模式的理解和工作经验的积累，自己可以站在一个更高的层次来审视、赏析程序代码。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"First Write","slug":"First Write","date":"2019-08-28T06:02:35.984Z","updated":"2019-09-03T03:12:34.111Z","comments":true,"path":"2019/08/28/First Write/","link":"","permalink":"http://yoursite.com/2019/08/28/First Write/","excerpt":"","text":"2019年，终于毕业了，结束了学生生涯 这次搭建了自己的网站，我会花时间来慢慢丰富这个博客 记录自己的成长.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}