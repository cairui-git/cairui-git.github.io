{"meta":{"title":"CaiRui的博客","subtitle":"人类真是毫无长进的生物","description":null,"author":"CaiRui","url":"http://blog.cairui99.cn","root":"/"},"pages":[{"title":"about","date":"2019-09-04T11:29:31.000Z","updated":"2020-05-18T08:28:04.361Z","comments":false,"path":"about/index.html","permalink":"http://blog.cairui99.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-04T11:34:44.000Z","updated":"2019-09-06T07:19:01.112Z","comments":false,"path":"categories/index.html","permalink":"http://blog.cairui99.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T11:26:46.000Z","updated":"2019-09-06T07:19:03.047Z","comments":false,"path":"tags/index.html","permalink":"http://blog.cairui99.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发编程","slug":"Java并发编程","date":"2020-06-01T02:39:50.000Z","updated":"2020-06-02T11:04:24.139Z","comments":true,"path":"2020/06/01/Java并发编程/","link":"","permalink":"http://blog.cairui99.cn/2020/06/01/Java并发编程/","excerpt":"什么是并发编程","text":"什么是并发编程 并发是指同一个时间段内多个任务同时在执行，此时线程的数量一般是大于CPU核数的，当一个线程占用CPU运行时，其他任务就会被挂起，当占用CPU的线程时间片用完后，会保留当前线程执行的上下文，并把CPU让给其他线程使用。（其中上下文切换是有额外开销的） 如果是在双CPU配置下，两个线程同时运行，这种情况称为并行运行，而不会并发。 Java中的线程安全问题产生线程安全问题的核心是多个线程间存在 共享资源： 共享资源是可以被多个线程所持有或者多个线程可以去访问的资源。 那么线程间存在共享资源的情况下，何时才会产生线程安全的问题呢？ 如果多个线程都只是读取共享资源，是不会产生线程安全问题的。 只有当至少一个线程修改共享资源时才会存在线程安全问题， 例如线程A在操作修改共享资源时，线程B读取到的值是没有同步的，此时线程A的修改结果还没有更新到主内存中，产生了线程安全问题。 Java中共享变量的内存可见性问题首先看看在多线程下的Java内存模型 Java内存模型规定，所有的变量都存放在主内存中，当线程使用变量时，会把主内存的变量复制到自己的工作空间或者叫工作内存中，当线程进行读写操作时操作的是自己工作内存中的变量，如果是写操作会在操作后将值更新到主内存的共享变量中。 Java中的synchronized关键字synchronized介绍synchronized块是Java提供的一种原子性内置锁，也叫监视器锁。 线程执行到synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者调用了wait系列方法时释放内置锁。 synchronized会阻塞和唤醒线程，线程需要进行上下文切换，是比较消耗性能的。 synchronized的内存语义前面说了线程安全问题主要是共享变量在线程的工作内存的可见性问题导致的，下面说一下synchronized的内存语义： 进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，也就是说在synchronized内使用的变量将不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。 除了解决共享变量内存的可见性问题外，synchronized还经常被用来实现原子性操作。 Java中的Lock锁使用Java中的Lock，可以得到和synchronized相同的效果。 Lock是Java1.5后在java.util.concurrent.locks包下提供的一种实现同步的方法，那么显然的，synchronized一定是有什么做不到的或者缺陷，才导致了Lock的诞生。 synchronized的缺点缺点如下： 当一个代码块被synchronized修饰的时候，一个线程获取到了锁，并且执行代码块，那么其他的线程需要等待正在使用的线程释放掉这个锁，那么释放锁的方法只有两种，一种是代码执行完毕自动释放，一种是发生异常以后jvm会让线程去释放锁。那么如果这个正在执行的线程遇到什么问题，比如等待IO或者调用sleep方法等等被阻塞了，无法释放锁，而这时候其他线程只能一直等待，将会特别影响效率。 当一个文件，同时被多个线程操作时，读操作和写操作会发生冲突，写操作和写操作会发生冲突，而读操作和读操作并不会冲突，但是如果我们用synchronized的话，会导致一个线程在读的时候，其他线程想要读的话只能等待 在使用synchronized时，我们无法得知线程是否成功获取到锁 Lock的出现则是为了解决如下问题。 Lock锁概述Lock锁，使用时手动获取锁和释放锁，比synchronized更加灵活；可中断的获取锁；超时获取锁。 Lock是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）。 Lock 锁的基本用法， l.lock()方法进行上锁， l.unlock()方法进行解锁，如下所示： 1234567Lock l = ...;l.lock(); // 上锁try &#123; // access the resource protected by this lock&#125; finally &#123; l.unlock(); // 解锁&#125; Lock锁的ApiApi如下： void lock(): 获得锁 void lockInterruptibly​()： 获得锁，可中断。举个例子，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。 boolean tryLock​()： 锁在空闲的才能获取锁（未获得锁不会等待）。举个例子：当两个线程同时通过lock.trylock()想获取某个锁时，假若此时线程A获取到了锁，而线程B不会等待，直接放弃获取锁。 boolean tryLock​(long time, TimeUnit unit)： 如果锁定可用，则此方法立即返回值true。如果锁不可用，则当前线程将被禁用以进行线程调度，并且在发生以下三种情况之一之前处于休眠状态： 当前线程获取锁 其他一些线程中断当前线程 等待时间过去了，返回false void unlock()： 释放锁 只看api就可以看出，lock锁相对于synchronized来说使用是非常灵活的。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.cairui99.cn/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://blog.cairui99.cn/tags/并发编程/"}]},{"title":"Java注解","slug":"Java注解","date":"2020-05-18T09:33:13.000Z","updated":"2020-05-19T05:42:03.799Z","comments":true,"path":"2020/05/18/Java注解/","link":"","permalink":"http://blog.cairui99.cn/2020/05/18/Java注解/","excerpt":"Java注解Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。","text":"Java注解Java的注解是JDK5.0引入的一种注释机制，java注解是一种类型，类似于class、interface。 注解不同与注释，注解的内容会被嵌入到字节码中，我们可以通过反射来获取到注解内容。 Java内置注解Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 作用在代码里的注解： @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 作用再其他注解上的注解（元注解）： @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) Java7之后新增的注解： @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 AnnotationAnnotation架构 可以看到，Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。 Annotation 的每一个实现类，都 和 1 个 RetentionPolicy 关联 并且 和 1~n 个 ElementType 关联 Annotation组成部分组成Annotation的三个类分别为： 12345678910111213package java.lang.annotation;public interface Annotation &#123; boolean equals(Object obj); int hashCode(); String toString(); Class&lt;? extends Annotation&gt; annotationType();&#125; 123456789101112131415161718192021package java.lang.annotation;public enum ElementType &#123; TYPE, /* 类、接口（包括注释类型）或枚举声明 */ FIELD, /* 字段声明（包括枚举常量） */ METHOD, /* 方法声明 */ PARAMETER, /* 参数声明 */ CONSTRUCTOR, /* 构造方法声明 */ LOCAL_VARIABLE, /* 局部变量声明 */ ANNOTATION_TYPE, /* 注释类型声明 */ PACKAGE /* 包声明 */&#125; 1234567891011package java.lang.annotation;public enum RetentionPolicy &#123; SOURCE, /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */ CLASS, /* 编译器将Annotation存储于类对应的.class文件中。默认行为 */ RUNTIME /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */&#125; Annotation是个接口，实现类需要实现自该接口。 ElementType是Enum 枚举类型，它用来指定 Annotation 的类型： 当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。 RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同： 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。 Annotation通用定义 123456@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 &#123;&#125; 上面我们自定义了一个注解，定义成功后，我们可以在代码中通过@MyAnnotation1来使用它。 其中@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的： @interface ：使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。定义 Annotation 时，@interface 是必须的。 @Documented : 类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。 @Target (ElementType.TYPE) : 用来指定 Annotation 的类型属性。@Target(ElementType.TYPE)意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。(定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方) @Retention(RetentionPolicy.RUNTIME): 指定 Annotation 的策略属性。@Retention(RetentionPolicy.RUNTIME) 的意思就是指编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。(定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS) 总结：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型（ElementType），@Retention 用来指定 Annotation 的策略（RetentionPolicy）。 java常用的Annotation1234567@Deprecated -- @Deprecated 所标注内容，不再被建议使用。@Override -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented -- @Documented 所标注内容，可以出现在javadoc中。@Inherited -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。@Target -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。 @Inherited继承性是指：我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。 @SuppressWarnings可以让编译器忽略掉某些警告，例如在方法中添加 @SuppressWarnings(value={“deprecation”}) 后，在方法中使用了某些不赞成的类或方法时将不在给予警告。 1234567deprecation -- 使用了不赞成使用的类或方法时的警告unchecked -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。fallthrough -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。path -- 在类路径、源文件路径等中有不存在的路径时的警告。serial -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。finally -- 任何 finally 子句不能正常完成时的警告。all -- 关于以上所有情况的警告。 Annotation的作用Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。 在编程中经常会使用到的 Annotation 作用有： 编译检查例如，@SuppressWarnings , @Deprecated 和 @Override 都具有编译检查作用。 灵活使用注解可以让编译器发现或忽略特定的错误。 在反射中使用Annotation可以通过 Method.getAnnotation(Class);来获取注解信息并使用。 根据Annotation生成帮助文档通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。 自定义注解可以通过反射来获取到我们自定义的注解，来实现某些功能。 参考参考自博客: https://www.cnblogs.com/skywang12345/p/3344137.html","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.cairui99.cn/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://blog.cairui99.cn/tags/注解/"}]},{"title":"Java线程基础","slug":"Java线程基础","date":"2020-05-18T05:57:48.000Z","updated":"2020-06-02T11:10:25.718Z","comments":true,"path":"2020/05/18/Java线程基础/","link":"","permalink":"http://blog.cairui99.cn/2020/05/18/Java线程基础/","excerpt":"参考书籍：Java并发编程之美","text":"参考书籍：Java并发编程之美 进程、线程讨论线程前必要先说下什么是进程，因为线程是进程中的一个实体，线程本身是不会独立存在的。 进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。 操作系统在分配资源是是把资源分配给进程的，但是CPU资源比较特殊，它是分配给线程的，因为真正要占用CPU资源的是线程，所以也说 线程是CPU分配的基本单位 在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是JVM进程中的一个线程，main函数线程也称为 主线程 可以看到图中一个进程中有多个线程，多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域。 程序计数器是用来记录线程当前要执行的指令地址，那为什么要记录呢?前面说了线程是占用CPU执行的基本单位，而CPU一般是使用时间片轮转的方式让线程轮询占用的，所以当前占有CPU资源的线程CPU时间片用完后就要让出CPU资源，等到下次轮到自己时再继续执行，所以此时就需要程序计数器记录该线程让出CPU时的执行地址，等到下次可以继续执行。 另外每个线程都有自己的栈资源，用于存储该线程的局部变量，这些都是该线程私有的，其他线程访问不了，除此之外还有用来存放线程的调用栈帧。 堆是进程中最大的一块内存，是所有线程共享的，里面主要存放使用new操作创建的对象实例。 方法区则用来存放JVM加载的类信息、常量、静态变量等信息，也是线程共享的。 线程创建与运行线程的创建有三种方式： 继承Thread类，重写run方法 实现Runnable接口的run方法 实现Callable接口的call()方法 继承Thread类1234567891011121314151617public class TheadTest &#123; public static class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"I am a child thread\"); &#125; &#125; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); &#125;&#125; 需要注意的是创建线程时线程并没有启动，只有调用start方法时线程才会启动 （调用start方法后线程会处于就绪状态，需要等待获取cpu资源后才会真正处于运行状态） ，当run方法执行完毕，线程会处于终止状态。 使用继承的好处：在run()方法中直接使用this就可以直接获取当前线程；缺点是java不支持多继承，继承Thread类后无法继承其他类。 实现Runnable接口1234567891011121314public static class RunableTask implements Runnable &#123; @Override public void run() &#123; System.out.println(\"I am a child thread\"); &#125;&#125;public static void main(String[] args) &#123; RunableTask task = new RunableTask(); new Thread(task).start(); new Thread(task).start();&#125; 可以看到两个线程共用了一个task代码逻辑，如果需要可以给RunableTask添加参数进行任务区分，同时RunableTask也可以继承其他类。 但还是有一个问题，就是任务没有返回值，下面给出实现Callable接口的方式 实现Callable接口12345678910111213141516public static class CallerTask implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; return \"hello\"; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new CallerTask()); new Thread(futureTask).start(); //异步获取返回值 String result = futureTask.get(); System.out.println(result);&#125; 总结使用继承方式的好处是方便传参，你可以在子类里面添加成员变 ，通过 set方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线程里面被声明为 final 变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类，那么子类不能再继承其他类，而 Runable 则没有这个限制 。前两种方式都没办法拿到任务的返回结果，但是 Futuretask 方式可以。 线程的通知与等待线程的通知与等待相关的函数使用的是Object类中自带的方法，java中所有的类都可以使用。 wait()函数当一个线程调用一个共享变量的wait()方法时，该调用线程会被 阻塞挂起，同时释放掉该共享变量的监视器锁，唤醒被wait()方法挂起的线程的方法是： 其他线程调用了该共享变量的notify()或notifyAll()方法 其他线程调用了该线程的interrupt()方法，该线程会抛出InterruptedException异常返回 如果当前线程在调用共享变量的wait()时没有获取到该共享变量的监视器锁，此时会抛出IllegalMonitorStateException异常，一般使用synchronized关键字来拿到对象的监视器锁。 需要注意的是，使用wait()方法只会让线程释放掉该共享变量的锁，并不会释放线程持有的其他锁，下面是个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class WaitTest &#123; private static final Object resourceA = new Object(); private static final Object resourceB = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (resourceA) &#123; System.out.println(\"threadA get resourceA lock\"); synchronized (resourceB) &#123; System.out.println(\"threadA get resourceB lock\"); System.out.println(\"threadA release resourceA lock\"); try &#123; resourceA.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); synchronized (resourceA) &#123; System.out.println(\"threadB get resourceA lock\"); synchronized (resourceB) &#123; System.out.println(\"threadB get resourceB lock\"); System.out.println(\"threadB release resourceA lock\"); resourceA.wait(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); threadA.start(); threadB.start(); //等待两个线程执行结束 threadA.join(); threadB.join(); System.out.println(\"main over\"); &#125;&#125; 输出： 1234threadA get resourceA lockthreadA get resourceB lockthreadA release resourceA lockthreadB get resourceA lock 线程A在调用resourceA的wait()方法后释放了它锁持有的resourceA的监视器锁，但没有释放掉它所持有的其他共享变量的锁。 wait(long timeout)函数如果线程在timeout的规定时间内没有被其他线程通过notify()或notifyAll()方法唤醒，那么该线程也会因为超时而被唤醒。 notify()函数当一个线程调用共享变量的notify()方法后，会随机唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。 被唤醒的线程不一定会继续执行，它必须先获取到共享对象的锁，但该线程可能需要和其他线程共同竞争这把锁。 同wait()方法，notify()方法也需要在获取到共享变量的监视器锁后，才可以调用，否则会抛异常。 notifyAll()函数唤醒所有在该共享变量上调用wait系列方法被挂起的线程。 等待线程执行终止的join方法join()方法是由Thread类提供的无参、无返回值的方法。 如果程序需要等待某个或多个线程执行完毕程序再继续往下执行的情况，此时可以用到join()方法来实现。 比如在main方法中，也是就使用主线程调用线程A的join方法，主线程就会被阻塞，等待线程A执行完毕后，主线程才会继续执行， 此时如果调用主线程在阻塞过程中调用了interrupt()方法，会抛出InterruptedException异常。 让线程睡眠的sleep方法sleep()是Thread类中的静态方法，调用的线程会让出指定时间的执行权，也就是这期间不参与CPU的调度，但该线程持有的监视器锁还是持有不让出的， sleep的执行时间过后，线程就会变为就绪状态，等待CPU的调度然后继续执行。 线程在sleep期间 让出CPU执行权的yield方法yield()方法是Thread类中的静态方法，相当于告诉线程调度器自己占有的时间片还没有使用完但是自己不想再使用了，暗示线程调度器现在可以进行下一轮的线程调度了。 当一个线程调用yield方法时，当前线程就会让出CPU使用权，然后变为就绪状态，线程调度器会从就绪队列中获取一个优先级最高的线程来给与CPU的执行权，当前这个优先级最高的线程也可能是刚刚调用yield方法的这个线程。 总结sleep和yield的区别，当线程调用sleep方法时调用线程会被阻塞挂起指定的时间，这期间线程调度器不会去调度该线程；而调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到该线程执行。 线程中断java中线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理： void interrupt()方法： 中断线程，例如线程A在运行时，线程B可以调用线程A的interrupt()方法将线程A的中断标志置为true并立即返回，如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起时，线程A会抛出InterruptedException异常返回 boolean isInterrupted()方法： 检测当前线程是否被中断 boolean interrupted()方法： 检测当前线程是否被中断，与 isInterrupted()不同的是，如果发现线程被中断则清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。 线程的上下文切换在多线程环境下，线程个数一般都大于CPU个数，而每个CPU同一时刻只能被一个线程使用，为了让用户感觉到所有线程是同时运行的，CPU资源的分配采用了时间片轮转的策略，也就是为每一个线程分配一个时间片，当前线程时间片用完后，线程会变为就绪状态并让出CPU让其他线程占用，这就是 上下文切换 线程上下文切换时机有： 当前线程的CPU时间片使用完，并处于就绪状态 当前线程被其他线程中断 程序计数器会记录当前线程运行到哪里了，待下次执行时可以恢复执行现场。 线程死锁什么是线程死锁死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。 死锁必须具备的四个条件： 互斥条件：表示该资源同时只能由一个线程占用 请求并保持条件：指一个线程已经持有了至少一个资源，但又同时再请求新的资源，而新资源已被其他线程占有，当前线程就会被阻塞，并且不会释放自己持有的资源 不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其他线程抢占 环路等待条件：指在发生死锁时，必然存在一个线程—资源的环形链 下面是一个死锁的demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DeadLock &#123; //创建资源 private static final Object resourceA = new Object(); private static final Object resourceB = new Object(); public static void main(String[] args) throws InterruptedException &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (resourceA) &#123; System.out.println(Thread.currentThread() + \"get ResourceA\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + \"waiting get ResourceB\"); synchronized (resourceB) &#123; System.out.println(Thread.currentThread() + \"get ResourceB\"); &#125; &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (resourceB) &#123; System.out.println(Thread.currentThread() + \"get ResourceB\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + \"waiting get ResourceA\"); synchronized (resourceA) &#123; System.out.println(Thread.currentThread() + \"get ResourceA\"); &#125; &#125; &#125; &#125;); threadA.start(); threadB.start(); threadA.join(); threadB.join(); System.out.println(\"main is finish\"); &#125;&#125; 输出： 1234Thread[Thread-1,5,main]get ResourceBThread[Thread-0,5,main]get ResourceAThread[Thread-1,5,main]waiting get ResourceAThread[Thread-0,5,main]waiting get ResourceB 可以看到程序并没有结束，而是两个线程都在互相请求对方持有的资源，永远的等待下去，构成了死锁状态 如何避免线程死锁避免线程死锁只需破坏掉至少一个死锁的必要条件即可，目前只有请求并保持和环路等待条件是可以破坏的。 造成死锁的原因与申请资源的顺序有很大关系，使用资源申请的有序性原则就可以有效的避免死锁。 在上面死锁的例子中，只需要将线程B的代码进行如下修改，即可避免死锁： 1234567891011121314151617Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (resourceA) &#123; System.out.println(Thread.currentThread() + \"get ResourceA\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread() + \"waiting get ResourceB\"); synchronized (resourceB) &#123; System.out.println(Thread.currentThread() + \"get ResourceB\"); &#125; &#125; &#125;&#125;); 输出： 1234567Thread[Thread-0,5,main]get ResourceAThread[Thread-0,5,main]waiting get resourceBThread[Thread-0,5,main]get ResourceBThread[Thread-1,5,main]get ResourceAThread[Thread-1,5,main]waiting get ResourceBThread[Thread-1,5,main]get ResourceBmain is finish 守护线程与用户线程Java中的线程分为两类，分别为 守护线程 和 用户线程 ,在JVM启动时调用main函数所在的线程就是一个用户线程，同时JVM还会启动好多守护线程，例如垃圾回收线程。 守护线程与用户线程的区别是： 当最后一个非守护线程结束时，JVM就会正常退出，也就是说守护线程是否结束并不影响JVM的退出。 在Java中使用下面的方式创建守护线程： 123456789101112public static void main(String[] args) &#123; Thread daemonThread = new Thread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;); //设置为守护线程 daemonThread.setDaemon(true); daemonThread.start();&#125; ThreadLocal多线程环境下访问同一个共享资源很容易出现并发问题，为了保证线程安全需要对共享变量进行同步。 同步的措施一般是加锁，但也可以使用ThreadLoacal的方式，使每个线程变量进行访问的时候访问的是自己线程的变量。 ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有一个这个变量的本地副本，当操作变量时实际操作的是自己本地内存里的变量，从而避免了线程安全的问题。 ThreadLocal使用示例123456789101112131415161718192021222324252627282930313233public class ThreadLocalTest &#123; public static ThreadLocal&lt;String&gt; localVariable = new ThreadLocal&lt;&gt;(); public static void print(String str) &#123; System.out.println(str + \":\" + localVariable.get()); //localVariable.remove(); &#125; public static void main(String[] args) &#123; Thread threadOne = new Thread(new Runnable() &#123; @Override public void run() &#123; localVariable.set(\"threadOne local variable\"); print(\"threadOne\"); System.out.println(\"threadOne remove after\" + \":\" + localVariable.get()); &#125; &#125;); Thread threadTwo = new Thread(new Runnable() &#123; @Override public void run() &#123; localVariable.set(\"threadTwo local variable\"); print(\"threadTwo\"); System.out.println(\"threadTwo remove after\" + \":\" + localVariable.get()); &#125; &#125;); threadOne.start(); threadTwo.start(); &#125;&#125; 输出： 1234threadTwo:threadTwo local variablethreadTwo remove after:threadTwo local variablethreadOne:threadOne local variablethreadOne remove after:threadOne local variable 去掉print方法中的注释后，输出为： 1234threadTwo:threadTwo local variablethreadOne:threadOne local variablethreadTwo remove after:nullthreadOne remove after:null 没写完，待更新。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.cairui99.cn/categories/Java/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://blog.cairui99.cn/tags/并发编程/"},{"name":"线程","slug":"线程","permalink":"http://blog.cairui99.cn/tags/线程/"}]},{"title":"Java虚拟机","slug":"Java虚拟机","date":"2020-05-03T13:39:38.000Z","updated":"2020-05-10T13:16:24.801Z","comments":true,"path":"2020/05/03/Java虚拟机/","link":"","permalink":"http://blog.cairui99.cn/2020/05/03/Java虚拟机/","excerpt":"参考书籍：深入理解java虚拟机（第三版）","text":"参考书籍：深入理解java虚拟机（第三版） JVMJava虚拟机简单来说就是Java的代码编译好之后，是跑在一台虚拟的机器（VM）上的，这台虚拟的机器负责分配内存和维护调用堆栈。 为什么要做成虚拟的机器这要从Java的一次编译到处执行来说。事实上一次编译到处执行是不可能的，因为每个机器不一样，所以传统上我们必须针对每一种机器编译代码，才能在这个机器上运行。而Java通过引入虚拟机（VM）的概念，让编译后的代码直接跑在一台虚拟的机器上，无论最终的目标平台是什么，都在上面构建出一个虚拟的一致的虚拟机出来，就可以达到一次编译到处执行的效果了。 JVM内存模型与内存溢出异常与C、C++不同，Java程序不再需要为每一个new操作去写配对的delete/free代码，在java中由JVM来帮忙管理、分配内存。 虽然jvm来管理内存带来了便利，不过一旦出现内存泄漏和溢出方面的问题，如果不了解java虚拟机是怎么使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。 运行时数据区为了更好的理解java虚拟机的内存模型，我们把java虚拟机所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，以及创建和销毁的时间。 java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图： 程序计数器一块较小的内存空间，是线程私有的，可以看作是 当前线程所执行的字节码的行号指示器 行号指示器就是在程序执行时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。 虚拟机栈与程序计数器一样，java虚拟机栈也是 线程私有的 ，它的生命周期与线程相同。 虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个 栈帧 ，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。通常我们说的”栈”，一般是指java虚拟机栈中的 局部变量表 部分。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，例如递归函数没有被正常终止时； 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈） 栈帧栈帧（Stack Frame）是用于支持虚拟机进行 方法调用 和 方法执行 的数据结构。它是虚拟机运行时数据区中的java虚拟机栈的栈元素。 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。 在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 在活动线程中，只有位于栈顶的栈帧才是有效的，称为 当前栈帧 ，与这个栈帧相关联的方法称为 当前方法 。 局部变量表局部变量表（Local Variable Table）是一组变量值存储空间，用于存放 方法参数 和方法内部定义的 局部变量 。并且在Java编译为Class文件时，就已经确定了该方法所需要分配的局部变量表的最大容量。 局部变量表存放了编译期可知的各种基本数据类型，对象引用(reference类型) 和 returnAddress类型（它指向了一条字节码指令的地址） 这里的变量仅指方法中的局部变量，成员变量是各个线程共享的，保存在堆中。 reference（对象实例的引用)类似于一个超链接，如图： 方法出口也就是方法被调用的位置，在方法退出时将返回值传递给上层的方法调用者。 本地方法栈本地方法栈与虚拟机栈所发挥得作用是相同的。区别是java虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是 为虚拟机使用到本地（Native）方法服务 。 java堆java堆是虚拟机所管理的内存中最大的一块。是被所有线程共享的一块内存区域。用来 存放对象实例。 java堆也是垃圾收集器管理的内存区域，所以java堆中经常出现新生代、老年代、永久代等名词。 根据虚拟机的规范，java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视作为连续的，类似于磁盘存储。 java堆是可以实现扩展的，通过参数-Xmx和-Xms设定，如果堆中还没有完成内存分配并且无法扩展时，java虚拟机会抛出OutOfMemoryError异常。 方法区方法区和堆一样，方法区是一块所有线程共享的内存区域。 方法去用来保存类的信息。比如类的字段、方法、常量池等。方法区的大小决定系统可以保存多少个类。如果系统 定义太多的类，导致方法区溢出。虚拟机同样会抛出OutOfMemoryError异常。 运行时常量池运行时常量池是方法区的一部分，用于存放编译期生成的字面量与符号引用。 字面量相当于java语言中常量的概念； 符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名 字段名称和描述符 方法名称和描述符","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.cairui99.cn/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://blog.cairui99.cn/tags/JVM/"}]},{"title":"GitHub_Page自定义域名失效问题","slug":"GitHub-Page自定义域名失效问题","date":"2020-04-28T14:37:19.000Z","updated":"2020-04-28T14:40:12.566Z","comments":true,"path":"2020/04/28/GitHub-Page自定义域名失效问题/","link":"","permalink":"http://blog.cairui99.cn/2020/04/28/GitHub-Page自定义域名失效问题/","excerpt":"","text":"使用GitHubPage部署项目时，在每次推送之后自定义的域名都会失效，项目的网址会变会github默认的网址，需要重新手动设置 解决方法： 在项目根目录中添加一个名为CNAME的文件，文件内容就是你的自定义域名，这样每次推送代码之后都不用去更新域名了","categories":[],"tags":[]},{"title":"LeetCode 每日一题","slug":"LeetCode-每日一题","date":"2020-04-26T13:46:10.000Z","updated":"2020-06-02T05:28:18.115Z","comments":true,"path":"2020/04/26/LeetCode-每日一题/","link":"","permalink":"http://blog.cairui99.cn/2020/04/26/LeetCode-每日一题/","excerpt":"LeetCode活动：每日一题，看能坚持多久","text":"LeetCode活动：每日一题，看能坚持多久 合并K个排序链表123456789101112131415161718192021222324252627282930313233343536373839/** * 合并K个排序链表 * https://leetcode-cn.com/problems/merge-k-sorted-lists/ * @author cairui * @date 2020-04-26 */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head = null; ListNode node = null; boolean is_end = false; while (!is_end) &#123; is_end = true; int index = 0; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; lists.length; i++) &#123; ListNode listNode = lists[i]; if (listNode != null &amp;&amp; listNode.val &lt; min) &#123; is_end = false; min = listNode.val; index = i; &#125; &#125; if (!is_end) &#123; if (head == null) &#123; head = new ListNode(lists[index].val); node = head; &#125; else &#123; node.next = new ListNode(lists[index].val); node = node.next; &#125; lists[index] = lists[index].next; &#125; &#125; return head; &#125;&#125; 搜索旋转排序数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 搜索旋转排序数组 * https://leetcode-cn.com/problems/search-in-rotated-sorted-array/ * @author cairui * @date 2020-04-27 */public class Solution &#123; public int search(int[] nums, int target) &#123; int front = 0; int back = nums.length - 1; int mid; while (front &lt;= back) &#123; mid = (front + back) / 2; int scope = this.getScope(nums, mid, front, back, target); if (scope == 0) &#123; return mid; &#125; else if (scope == 1) &#123; back = mid - 1; &#125; else if (scope == 2) &#123; front = mid + 1; &#125; else &#123; break; &#125; &#125; return -1; &#125; /** * 缩小target的范围 * @return int -1=&gt;不存在，0=&gt;中间，1=&gt;左边, 2=&gt;右边 */ private int getScope(int[] nums, int mid, int front, int back, int target) &#123; int left = nums[front]; int right = nums[back]; int middle = nums[mid]; if (middle == target) &#123; return 0; &#125; else if (left == target) &#123; return 1; &#125; else if (right == target) &#123; return 2; &#125; else if (left &lt; right) &#123; //数组没有被旋转过 if (left &lt; target &amp;&amp; middle &gt; target) &#123; return 1; &#125; else if (middle &lt; target &amp;&amp; right &gt; target) &#123; return 2; &#125; else &#123; return -1; &#125; &#125; else if (left &gt; target) &#123; if (right &lt; target) &#123; return -1; &#125; else if (middle &gt; target &amp;&amp; middle &lt; right) &#123; return 1; &#125; else &#123; return 2; &#125; &#125; else &#123; if (middle &lt; target &amp;&amp; middle &gt; right) &#123; return 2; &#125; else &#123; return 1; &#125; &#125; &#125;&#125; 数组中数字出现的次数12345678910111213141516171819202122232425262728293031/** * 数组中数字出现的次数 * https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/ * @author cairui * @date 2020-04-28 */public class Solution &#123; public int[] singleNumbers(int[] nums) &#123; int k = 0; for(int num: nums) &#123; k ^= num; &#125; //获得k中最低位的1 int mask = 1; while((k &amp; mask) == 0) &#123; mask &lt;&lt;= 1; &#125; int[] answer = new int[2]; for(int num: nums) &#123; //分组 if((num &amp; mask) == 0) &#123; answer[0] ^= num; &#125; else &#123; answer[1] ^= num; &#125; &#125; return answer; &#125;&#125; （工作忙，鸽了两天。。。心态崩了） 合并两个有序链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 合并两个有序链表 * https://leetcode-cn.com/problems/merge-two-sorted-lists/ * @author caiui * @date 2020-05-01 */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = null; ListNode node = null; ListNode next = null; int min = 0; while (l1 != null &amp;&amp; l2 != null) &#123; int val1 = l1.val; int val2 = l2.val; min = Math.min(val1, val2); if (head == null) &#123; head = new ListNode(min); node = head; &#125; else &#123; node.next = new ListNode(min); node = node.next; &#125; l1 = val1 &gt;= val2 ? l1 : l1.next; l2 = val1 &lt; val2 ? l2 : l2.next; &#125; if (l1 != null) &#123; next = l1; &#125; else if (l2 != null) &#123; next = l2; &#125; while (next != null) &#123; if (head == null) &#123; head = new ListNode(next.val); node = head; &#125; else &#123; node.next = new ListNode(next.val); node = node.next; &#125; next = next.next; &#125; return head; &#125;&#125; 无重复字符的最长子串1234567891011121314151617181920212223242526272829import java.util.HashMap;public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; char[] strs = s.toCharArray(); int maxLength = 0; for (int i = 0; i &lt; strs.length; i++) &#123; int nowLength = 0; HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for (int j = i; j &lt; strs.length; j++) &#123; if (map.get(strs[j]) == null) &#123; nowLength++; map.put(strs[j], strs[j]); continue; &#125; break; &#125; if (nowLength &gt; maxLength) &#123; maxLength = nowLength; &#125; if ((strs.length - i - 1) &lt;= maxLength) &#123; break; &#125; &#125; return maxLength; &#125;&#125; 最大子序和123456789101112131415161718192021222324/** * 最大子序和 * https://leetcode-cn.com/problems/maximum-subarray/ * @author cairui * @date 2020-05-03 */public class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = Integer.MIN_VALUE; int now = 0; for (int num : nums) &#123; now = (num + now &lt; 0) ? num : num + now; if (now &gt; max) &#123; max = now; &#125; if (now &lt; 0) &#123; now = 0; &#125; &#125; return max; &#125;&#125; 跳跃游戏 II123456789101112131415161718192021222324252627282930313233/** * 跳跃游戏 II * https://leetcode-cn.com/problems/jump-game-ii/ * @author cairui * @date 2020-05-04 */public class Solution &#123; public int jump(int[] nums) &#123; int jump = 0; int index = 0; while (index &lt; (nums.length - 1)) &#123; int max = 0; int count = 0; int new_index = 0; for (int i = (index + nums[index]); i &gt; index; i--) &#123; if (i &gt;= (nums.length - 1)) &#123; new_index = nums.length; break; &#125; if ((nums[i] - count) &gt; max) &#123; max = nums[i] - count; new_index = i; &#125; count++; &#125; jump++; index = new_index; &#125; return jump; &#125;&#125; 验证二叉搜索树123456789101112131415161718192021222324252627282930/** * 验证二叉搜索树 * https://leetcode-cn.com/problems/validate-binary-search-tree/ * @author cairui * @date 2020-05-05 */public class Solution98 &#123; private boolean helper(TreeNode node, Integer lower, Integer upper) &#123; if (node == null) &#123; return true; &#125; int val = node.val; if (lower != null &amp;&amp; val &lt;= lower) &#123; return false; &#125; if (upper != null &amp;&amp; val &gt;= upper) &#123; return false; &#125; if (!helper(node.right, val, upper)) &#123; return false; &#125; return helper(node.left, lower, val); &#125; public boolean isValidBST(TreeNode root) &#123; return helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE); &#125;&#125; 最低票价待优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 最低票价 * https://leetcode-cn.com/problems/minimum-cost-for-tickets/ * @author cairui * @date 2020-05-06 */public class Solution983 &#123; private int[] getWeekCount(int[] days, int index) &#123; int[] weekCount = new int[4]; int week = 0; int next_day = days[index] + 6; while (index &lt; days.length) &#123; int day = days[index++]; if (day &lt;= next_day) &#123; weekCount[week]++; &#125; else &#123; next_day = next_day + 7; week++; if (week == 4) &#123; break; &#125; weekCount[week]++; &#125; &#125; return weekCount; &#125; private int getMoney(int[] costs, int[] weekCount) &#123; int money = 0; for (int i = 0; i &lt; weekCount.length; i++) &#123; money += Math.min(weekCount[i] * costs[0], costs[1]); &#125; return money; &#125; private int getNextMonthIndex(int index, int[] days) &#123; int next_Month_index = -1; int next_Month = days[index] + 29; for (int i = index; i &lt; days.length; i++) &#123; if (days[i] &gt; next_Month) &#123; next_Month_index = i; break; &#125; &#125; return next_Month_index; &#125; public int mincostTickets(int[] days, int[] costs) &#123; int money = 0; int index = 0; while (index &lt; days.length) &#123; //一个月内每周都有多少天 int[] weekCount = this.getWeekCount(days, index); money += Math.min(this.getMoney(costs, weekCount), costs[2]); index = this.getNextMonthIndex(index, days); if (index == -1) &#123; break; &#125; &#125; return money; &#125;&#125; Pow(x, n)123456789101112131415161718192021222324252627282930313233343536373839/** * Pow(x, n) * https://leetcode-cn.com/problems/powx-n/ * @author cairui * @date 2020-05-11 */public class Solution50 &#123; public double myPow(double x, int n) &#123; if (n == 0 || x == 1) &#123; return 1; &#125; double pow = x; long multiple = 1; while (multiple != Math.abs((long)n)) &#123; if (multiple * 2 &lt;= Math.abs((long)n)) &#123; pow = pow * pow; multiple = multiple * 2; &#125; else &#123; double temp = pow; int count = 0; while ((multiple + (multiple - count)) &gt; Math.abs((long)n)) &#123; temp = temp / x; count++; &#125; pow = pow * temp; multiple += (multiple - count); &#125; if (multiple == 0) &#123; pow = Double.MAX_VALUE; &#125; &#125; if (n &lt; 0) &#123; pow = 1 / pow; &#125; return pow; &#125;&#125; 二叉树的层序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546import DataStructure.TreeNode;import java.util.ArrayList;import java.util.List;/** * 二叉树的层序遍历 * https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ * @author cairui * @date 2020-05-13 */public class Solution102 &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; answer = new ArrayList&lt;&gt;(); if (root != null) &#123; List&lt;TreeNode&gt; nodeList = new ArrayList&lt;&gt;(); while (true) &#123; boolean isContinue = false; List&lt;TreeNode&gt; newNodeList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); if (nodeList.size() == 0) &#123; nodeList.add(root); &#125; for (TreeNode treeNode : nodeList) &#123; integerList.add(treeNode.val); if (treeNode.left != null) &#123; newNodeList.add(treeNode.left); isContinue = true; &#125; if (treeNode.right != null) &#123; newNodeList.add(treeNode.right); isContinue = true; &#125; &#125; answer.add(integerList); nodeList = newNodeList; if (!isContinue) &#123; break; &#125; &#125; &#125; return answer; &#125;&#125; 只出现一次的数字1234567891011121314151617/** * 只出现一次的数字 * https://leetcode-cn.com/problems/single-number/ * @author cairui * @date 2020-05-14 */public class Solution &#123; public int singleNumber(int[] nums) &#123; int num = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; num = num ^ nums[i]; &#125; return num; &#125;&#125; 课程表 II123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.HashMap;import java.util.List;/** * 课程表 II * https://leetcode-cn.com/problems/course-schedule-ii/ * @author cairui * @date 2020-05-17 */public class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] answer = new int[numCourses]; int index = 0; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); list.add(temp); &#125; for (int[] prerequisite : prerequisites) &#123; List&lt;Integer&gt; temp = list.get(prerequisite[0]); temp.add(prerequisite[1]); list.set(prerequisite[0], temp); &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); while (index &lt; numCourses) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i).size() == 0 &amp;&amp; map.get(i) == null) &#123; map.put(i, i); answer[index++] = i; &#125; &#125; boolean isStudy = false; for (int i = 0; i &lt; list.size(); i++) &#123; List&lt;Integer&gt; temp = list.get(i); int begin = temp.size() - 1; for (int j = begin; j &gt;= 0; j--) &#123; int num = temp.get(j); if (map.get(num) != null) &#123; isStudy = true; temp.remove(j); list.set(i, temp); &#125; &#125; &#125; if (!isStudy) &#123; break; &#125; &#125; if (index &lt; numCourses) &#123; return new int[0]; &#125; return answer; &#125;&#125; 乘积最大子数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.ArrayList;/** * 乘积最大子数组 * https://leetcode-cn.com/problems/maximum-product-subarray/ * @author cairui * @date 2020-05-18 */public class Solution &#123; public int maxProduct(int[] nums) &#123; int answer = Integer.MIN_VALUE; int index = 0; boolean isZero = false; while (index &lt; nums.length) &#123; int negativeCount = 0; int negative = 0; ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); while (index &lt; nums.length) &#123; int num = nums[index++]; if (num == 0) &#123; isZero = true; break; &#125; else if (num &lt; 0) &#123; negativeCount++; &#125; temp.add(num); &#125; if (negativeCount % 2 == 0 || temp.size() == 1) &#123; negative = this.getProduct(temp); &#125; else&#123; ArrayList&lt;Integer&gt; temp1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; temp2 = new ArrayList&lt;&gt;(); //第一个负数的位置 int negativeIndex = -1; int count = 0; for (int i = 0; i &lt; temp.size(); i++) &#123; if (temp.get(i) &lt; 0) &#123; count++; negativeIndex = (negativeIndex == -1) ? i : negativeIndex; &#125; if (count == negativeCount) &#123; break; &#125; temp1.add(temp.get(i)); &#125; for (int i = negativeIndex + 1; i &lt; temp.size(); i++) &#123; temp2.add(temp.get(i)); &#125; negative = Math.max(this.getProduct(temp1), this.getProduct(temp2)); &#125; answer = Math.max(negative, answer); &#125; if (answer &lt; 0 &amp;&amp; isZero) &#123; return 0; &#125; return answer; &#125; private int getProduct(ArrayList&lt;Integer&gt; list) &#123; if (list.size() == 0) &#123; return Integer.MIN_VALUE; &#125; int answer = 1; for (Integer integer : list) &#123; answer = answer * integer; &#125; return answer; &#125;&#125; 验证回文字符串 Ⅱ1234567891011121314151617181920212223242526272829303132333435/** * 验证回文字符串 Ⅱ * https://leetcode-cn.com/problems/valid-palindrome-ii/ * @author cairui * @date 2020-05-19 */public class Solution680 &#123; public boolean validPalindrome(String s) &#123; char[] strs = s.toCharArray(); int front = 0; int back = strs.length - 1; while (front &lt; back) &#123; if (strs[front] != strs[back]) &#123; if (isPalindrome(strs, front + 1, back)) &#123; return true; &#125; return isPalindrome(strs, front, back - 1); &#125; front++; back--; &#125; return true; &#125; private boolean isPalindrome(char[] strs, int front, int back) &#123; while (front &lt; back) &#123; if (strs[front++] != strs[back--]) &#123; return false; &#125; &#125; return true; &#125;&#125; 寻找两个正序数组的中位数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 寻找两个正序数组的中位数 * https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ * @author cairui * @date 2020-05-24 */public class Solution4 &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; boolean isOdd = (nums1.length + nums2.length) % 2 != 0; List&lt;Double&gt; list = new ArrayList&lt;&gt;(); int index1 = 0; int index2 = 0; int count = 0; int midIndex = (nums1.length + nums2.length) / 2; midIndex = isOdd ? midIndex : midIndex - 1; while (index1 &lt; nums1.length &amp;&amp; index2 &lt; nums2.length) &#123; double num = (nums1[index1] &lt;= nums2[index2]) ? nums1[index1++] : nums2[index2++]; if (count == midIndex || count == midIndex + 1) &#123; list.add(num); &#125; count++; if ((isOdd &amp;&amp; list.size() == 1) || (!isOdd &amp;&amp; list.size() == 2)) &#123; break; &#125; &#125; if ((isOdd &amp;&amp; list.size() != 1) || (!isOdd &amp;&amp; list.size() != 2)) &#123; int[] nums = index1 &lt; nums1.length ? nums1 : nums2; int index = index1 &lt; nums1.length ? index1 : index2; while (index &lt; nums.length) &#123; if (count == midIndex || count == midIndex + 1) &#123; list.add((double) nums[index]); &#125; count++; index++; if ((isOdd &amp;&amp; list.size() == 1) || (!isOdd &amp;&amp; list.size() == 2)) &#123; break; &#125; &#125; &#125; return list.size() == 1 ? list.get(0) : (list.get(0) + list.get(1)) / 2; &#125;&#125; LRU缓存机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * LRU缓存机制 * https://leetcode-cn.com/problems/lru-cache/ * @author cairui * @date 2020-05-25 */public class LRUCache &#123; private final List&lt;Integer&gt; keyList = new ArrayList&lt;&gt;(); private final List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;(); private final int capacity; private final HashMap&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;(); private int count = 0; public LRUCache(int capacity) &#123; this.capacity = capacity; &#125; public int get(int key) &#123; for (int i = 0; i &lt; this.keyList.size(); i++) &#123; if (this.keyList.get(i) == key) &#123; this.countMap.put(key, this.count++); return this.valueList.get(i); &#125; &#125; return -1; &#125; public void put(int key, int value) &#123; boolean isExist = false; for (int i = 0; i &lt; this.keyList.size(); i++) &#123; if (this.keyList.get(i) == key) &#123; isExist = true; this.valueList.set(i, value); break; &#125; &#125; if (!isExist) &#123; if (this.keyList.size() &lt; this.capacity) &#123; this.keyList.add(key); this.valueList.add(value); &#125; else &#123; int minCount = Integer.MAX_VALUE; int index = -1; for (int i = 0; i &lt; this.keyList.size(); i++) &#123; int count = countMap.get(keyList.get(i)); if (count &lt; minCount) &#123; minCount = count; index = i; &#125; &#125; this.keyList.set(index, key); this.valueList.set(index, value); &#125; &#125; this.countMap.put(key, this.count++); &#125;&#125; 寻找重复数123456789101112131415161718192021/** * 寻找重复数 * https://leetcode-cn.com/problems/find-the-duplicate-number/ * @author cairui * @date 2020-05-26 */public class Solution287 &#123; public int findDuplicate(int[] nums) &#123; for (int i = 1; i &lt;= nums.length; i++) &#123; int count = 0; for (int num : nums) &#123; if (num == i &amp;&amp; ++count == 2) &#123; return num; &#125; &#125; &#125; return 0; &#125;&#125; 拥有最多糖果的孩子1234567891011121314151617181920212223/** * 拥有最多糖果的孩子 * https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/ * @author cairui * @date 2020-06-01 */public class Solution1431 &#123; public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) &#123; List&lt;Boolean&gt; answerList = new ArrayList&lt;&gt;(); int max = Integer.MIN_VALUE; for (int candy : candies) &#123; if (max &lt; candy) &#123; max = candy; &#125; &#125; for (int candy : candies) &#123; answerList.add(candy + extraCandies &gt;= max); &#125; return answerList; &#125;&#125; 求1+2+…+n1234567891011121314/** * 求1+2+…+n * https://leetcode-cn.com/problems/qiu-12n-lcof/ * @author cairui * @date 2020-06-02 */public class Solution64 &#123; public int sumNums(int n) &#123; boolean flag = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0; return n; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[]},{"title":"Linux-ping通ip但ping不通域名","slug":"Linux-ping通ip但ping不通域名","date":"2020-02-27T06:51:10.000Z","updated":"2020-02-27T06:53:38.384Z","comments":true,"path":"2020/02/27/Linux-ping通ip但ping不通域名/","link":"","permalink":"http://blog.cairui99.cn/2020/02/27/Linux-ping通ip但ping不通域名/","excerpt":"","text":"原因：机器的域名解析有问题 解决方法：修改DNS配置 sudo vi /etc/resolv.conf 添加 nameserver 8.8.8.8","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.cairui99.cn/categories/linux/"}],"tags":[]},{"title":"ssr服务器搭建","slug":"ssr服务器搭建","date":"2020-01-03T07:28:52.000Z","updated":"2020-02-27T06:50:01.709Z","comments":true,"path":"2020/01/03/ssr服务器搭建/","link":"","permalink":"http://blog.cairui99.cn/2020/01/03/ssr服务器搭建/","excerpt":"搭建代理服务器前首先要有一台自己的机器，我是在这里办的 https://my.vultr.com/ ，优点是可以随时注销、随时办理，按小时收费。","text":"搭建代理服务器前首先要有一台自己的机器，我是在这里办的 https://my.vultr.com/ ，优点是可以随时注销、随时办理，按小时收费。 有了自己的服务器后，登陆进去，依次输入下面几条命令： 12345wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 运行成功后，会提示你设置你代理的密码、端口、协议等信息： 如提示（Please enter password for ShadowsocksR）：设置密码，自己设定 如提示（Please enter a port for ShadowsocksR [1-65535]）：设置服务器端口，如不设定会随机生成 如提示（Please select stream cipher for ShadowsocksR）：设置加密方式，建议 chacha20 如提示（Please select protocol for ShadowsocksR）：设置协议，默认为 origin 如提示（Please select obfs for ShadowsocksR）：选择混淆方式，建议选择 http_simple 至此所有配置已经设置完成，等待几分钟，配置成功会显示出所有配置信息，建议截图保存，以免遗忘","categories":[],"tags":[]},{"title":"两条单链表相交的问题","slug":"算法题-两条单链表相交的问题","date":"2019-12-16T06:06:14.000Z","updated":"2019-12-16T06:50:19.245Z","comments":true,"path":"2019/12/16/算法题-两条单链表相交的问题/","link":"","permalink":"http://blog.cairui99.cn/2019/12/16/算法题-两条单链表相交的问题/","excerpt":"题目给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null","text":"题目给定两个单链表的头节点，单链表可能有环也可能无环，判断是否相交，如果相交返回相交的节点，不相交返回null 思路首先判断两条单链表是否成环，如果有环则获取到入环节点，然后分情况讨论： 两条非环单链表：遍历两条链表获取链表的长度，将较长的那条的头节点向后移动两条链表头部的差值，然后两条单链表从头节点同时向后移动： 如果产生交点则两条链表相交，返回该节点 抵达尾部时都没有产生交点则不相交，返回null 一条单链表成环，一条单链表非环：必无交点 两条成环单链表： 入环节点相同，必相交：将入环节点视为终点，此时两条链表可以视为非环单链表，寻找两条单链表的交点时则可以使用两条非环单链表的判断方法找到交点 入环节点不同，需要判断是否相交：选择其中一条链表的入环节点开始遍历，如果遍历过程中遇到了另一条链表的入环节点，则两条链表相交；如果遍历一整圈都没有相遇则两条链表无交点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 给定两个单链表的头节点,判断是否相交,如果相交返回相交的节点,不相交返回null * @author CaiRui * @time 2019-12-06 */public class IntersectNode &#123; public static ListNode isIntersect(ListNode head1, ListNode head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; ListNode isCyclization1 = isCyclization(head1); ListNode isCyclization2 = isCyclization(head2); if (isCyclization1 == null &amp;&amp; isCyclization2 == null) &#123; //两条非环单链表 return getIntersect(head1, head2); &#125; else if (isCyclization1 != null &amp;&amp; isCyclization2 != null) &#123; //两条成环单链表 if (isCyclization1 == isCyclization2) &#123; //入环节点相同,必相交 ListNode tempNode = isCyclization1.next; isCyclization1.next = null; ListNode resultNode = getIntersect(head1, head2); isCyclization1.next = tempNode; return resultNode; &#125; else &#123; //入环节点不同需要判断是否相交 ListNode node = isCyclization1.next; while (node != isCyclization1) &#123; if (node == isCyclization2) &#123; //在环中遇到了另一个链表的入环节点,说明两条链表相交 return isCyclization1; &#125; node = node.next; &#125; &#125; &#125; return null; &#125; /** * 单链表是否成环 * @param head 头节点 * @return 入环节点,不成环则返回null */ private static ListNode isCyclization(ListNode head) &#123; if (head == null || head.next == null) &#123; return null; &#125; //使用快慢指针判断是否成环 ListNode fast = head; ListNode slow = head; do &#123; if (fast.next == null || fast.next.next == null) &#123; return null; &#125; slow = slow.next; fast = fast.next.next; &#125; while (slow != fast); //返回入环节点 fast = head; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; /** * 返回两条非环单链表的交点 */ private static ListNode getIntersect(ListNode head1, ListNode head2) &#123; int node1Length = getNodeLength(head1); int node2Length = getNodeLength(head2); ListNode longerNode = node1Length &gt; node2Length ? head1 : head2; ListNode shortNode = node1Length &gt; node2Length ? head2 : head1; for (int i = 0; i &lt; Math.abs(node1Length - node2Length); i++) &#123; longerNode = longerNode.next; &#125; while (shortNode != null) &#123; if (shortNode == longerNode) &#123; return shortNode; &#125; shortNode = shortNode.next; longerNode = longerNode.next; &#125; return null; &#125; /** * 获取非环单链表长度 */ private static int getNodeLength(ListNode head) &#123; int length = 0; while (head != null) &#123; length++; head = head.next; &#125; return length; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"链表","slug":"链表","permalink":"http://blog.cairui99.cn/tags/链表/"}]},{"title":"使用natapp实现内网穿透功能","slug":"linux-使用natapp实现内网穿透功能","date":"2019-12-12T06:07:07.000Z","updated":"2019-12-31T06:55:31.893Z","comments":true,"path":"2019/12/12/linux-使用natapp实现内网穿透功能/","link":"","permalink":"http://blog.cairui99.cn/2019/12/12/linux-使用natapp实现内网穿透功能/","excerpt":"背景最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单","text":"背景最近在开发微信公众号时需要接收微信的回调，由于本地linux虚拟机是没有外网ip的，所以使用了natapp这个工具生成外网域名，就可以收到微信的回调了，搭建很简单 搭建环境注册账号前往官网 https://natapp.cn/ 注册账号，并登录 购买隧道 登陆成功后，进入个人中心选择购买隧道 个人使用选择：免费隧道 隧道协议选择：Web 点击免费购买（注：免费隧道的域名会随机更换，所以不适合长期使用，这里仅用来测试） 安装客户端 进入官网的客户端下载，选择linux 下载并解压，解压后获得一个natapp的文件 运行客户端至此环境已经部署完成，下面开始运行natapp 获取authtoken点击我的隧道，可以查看隧道的authtoken，用来启动客户端 启动客户端进入natapp所在目录，执行： 1$ ./natapp -authtoken=xxx 可以看到客户端启动成功，Forwarding下的网址就是你的外网域名 后台运行natapp直接启动natapp有一个缺点，就是当终端窗口关闭或者ctrl+c的时候natapp进程会被终止，这时需要natapp在后台异步执行 虽然官网给出了后台运行的方案和教程： nohup + 命令 + &amp; 但使用这种方式后我们需要的获取到的域名却不知道上哪里找了，虽然能后台运行了，但获取不到域名我运行你干什么。。。 解决方案： 在natapp客户端的同级目录下引入一个config.ini的文件，下载地址：http://download.natapp.cn/assets/downloads/config.ini 打开config.ini，将loglevel的值设置为INFO 执行命名：nohup ./natapp -authtoken=xxx &amp; 此时在目录下会生成一个nohup.out的日志文件，打开即可查看到你的外网域名 使用ps命令查看进程状态，发现natapp已经在后台运行了： 需要注意的是，免费隧道的域名不是永久有效的，natapp可能随时会将你的域名强制更换，这时还需要到日志中查找最新的域名，所以如果想要稳定的服务还是需要购买付费隧道。 当然域名换的也不会很频繁，临时测试的话免费的就够了。","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.cairui99.cn/categories/linux/"}],"tags":[]},{"title":"linux后台运行php常驻进程","slug":"php-linux后台运行php常驻进程","date":"2019-12-11T06:54:11.000Z","updated":"2019-12-12T05:56:47.226Z","comments":true,"path":"2019/12/11/php-linux后台运行php常驻进程/","link":"","permalink":"http://blog.cairui99.cn/2019/12/11/php-linux后台运行php常驻进程/","excerpt":"在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行","text":"在linux下执行普通的php命名，在关闭窗口或者ctrl+c时程序就会停止运行，这时需要把脚本放在后台常驻运行 &amp;加在一个命令的最后，可以把这个命令放在后台执行 nohup使用 &amp; 命令使程序在后台执行，当终端关闭时程序会被终止，这时需要使用nohup命令，可以在你退出账户/关闭终端之后继续运行相应的进程。 例如： 1$ nohub 命令 &gt; /home/user/log/xxx.log &amp; 在使用nohup命令时，该程序所有的输出默认会被重定向到一个名为nohup.out的文件中，除非指定了输出文件，比如上面的/home/user/log/xxx.log 查看进程&amp;杀死进程使用命令ps查看进程运行状态： 1$ ps -aux | grep xxx xxx代表命令的关键字，如果命令在运行则可以得到进程的pid 使用命令kill，杀死进程： 1$ kill pid","categories":[{"name":"linux","slug":"linux","permalink":"http://blog.cairui99.cn/categories/linux/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.cairui99.cn/tags/php/"},{"name":"linux命令","slug":"linux命令","permalink":"http://blog.cairui99.cn/tags/linux命令/"}]},{"title":"赛马问题","slug":"逻辑题-赛马问题","date":"2019-12-04T03:48:08.000Z","updated":"2019-12-04T07:03:40.372Z","comments":true,"path":"2019/12/04/逻辑题-赛马问题/","link":"","permalink":"http://blog.cairui99.cn/2019/12/04/逻辑题-赛马问题/","excerpt":"题目： 64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？","text":"题目： 64匹马，8个跑道，问最少需要进行几场比赛，可以选出跑的最快的4匹马？ 下面是我的思路，不能保证是最优解： 所有马分成8组，每组比一场，然后淘汰每组的后4名，剩32匹马：1234、1234、1234、1234、1234、1234、1234、1234 把每组第1名拉出来比一场，第一名晋级，因为只取前4名，淘汰后4名下小组的所有马，由于只剩3个名额，淘汰前4名小组的第四名，剩12匹马：234,123,123,123 将来自第1名小组的2、3、4名和其他小组的第1名拉出来比一场，此时有两种情况： 前3名全部来自于第1名的小组，前三名直接晋级，只需比 10场 前3名不全部来自于第1名的小组，第一名晋级，由于还剩下两个名额，4个小组里每组最多只留下两匹马，此时4个小组每个小组2匹马，只需再比试一轮取前两名晋级即可，共需要比赛 11场 题目中问最少，所以答案应是 10场。 当然前提是比赛中我们没有计时器同时每匹马的每场比赛跑的都是一样快的。","categories":[],"tags":[{"name":"逻辑题","slug":"逻辑题","permalink":"http://blog.cairui99.cn/tags/逻辑题/"}]},{"title":"复制含有随机指针的链表","slug":"算法题-复制含有随机指针的链表","date":"2019-12-02T07:30:23.000Z","updated":"2019-12-03T02:21:14.920Z","comments":true,"path":"2019/12/02/算法题-复制含有随机指针的链表/","link":"","permalink":"http://blog.cairui99.cn/2019/12/02/算法题-复制含有随机指针的链表/","excerpt":"题目复制含有随机指针节点的链表 Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下：","text":"题目复制含有随机指针节点的链表 Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null，Node类结构如下： 12345678910111213public class RandNode &#123; public RandNode next; public RandNode rand; public int value; public RandNode(int value) &#123; this.value = value; this.next = null; this.rand = null; &#125;&#125; 给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶： 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。 HashMap实现使用辅助结构HashMap实现： 创建一个HashMap，key、value都是RandNode类型 遍历链表，将原节点作为key存入map中，每次都新建一个RandNode节点作为value存入map中 遍历完成后，map中所有的key都是原节点，每个key对应的value代表着复制的链表节点 重新遍历原链表，将map中所有的value的next、rand指针进行连接 返回复制后链表的头节点 代码： 1234567891011121314151617181920212223242526272829/** * 使用HashMap实现 * @param head 原链表头节点 * @return 复制后的链表头节点 */public static RandNode hashMapMethod(RandNode head) &#123; if (head == null) &#123; return null; &#125; else if (head.next == null) &#123; return new RandNode(head.value); &#125; HashMap&lt;RandNode, RandNode&gt; map = new HashMap&lt;&gt;(); RandNode node = head; while (node != null) &#123; RandNode copy_node = new RandNode(node.value); map.put(node, copy_node); node = node.next; &#125; node = head; while (node != null) &#123; RandNode copy_node = map.get(node); copy_node.next = map.get(node.next); copy_node.rand = map.get(node.rand); node = node.next; &#125; return map.get(head);&#125; 使用有限变量实现借用HashMap无法实现进阶中空间复杂度O(1)的要求，下面使用有限的几个变量实现复制链表： 遍历原链表，每次遍历都创建一个新的Node类型的变量作为该节点的复制，然后将复制的节点连接到原节点的后面，复制节点的next指针指向原节点之前的next节点(例如:原链表为 1-&gt;2-&gt;3-&gt;null，在遍历后链表将变为 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null) 此时的链表结构其实可以做到和HashMap相同的效果：可以遍历原链表并且可以根据原节点可以找到对应的复制节点 下面遍历链表，将所有复制节点的rand指针指向正确的位置 最后将复制的节点从链表中分离出来，形成原链表和复制的链表，返回复制链表的头节点 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 使用有限的变量实现 空间复杂度O(1) * @param head 原链表头节点 * @return 复制后的链表头节点 */public static RandNode randPointNode(RandNode head) &#123; if (head == null) &#123; return null; &#125; else if (head.next == null) &#123; return new RandNode(head.value); &#125; //将复制的节点连到对应原节点后面 RandNode node = head; while (node != null) &#123; RandNode copy_node = new RandNode(node.value); copy_node.next = node.next; node.next = copy_node; node = copy_node.next; &#125; //配置复制节点的rand指针 node = head; while (node != null) &#123; RandNode copy_node = node.next; copy_node.rand = node.rand != null ? node.rand.next : null; node = node.next.next; &#125; //将复制的节点分离出来 RandNode result = head.next; node = head; while (true) &#123; RandNode copy_node = node.next; if (copy_node.next != null) &#123; node.next = copy_node.next; copy_node.next = copy_node.next.next; node = node.next; &#125; else &#123; node.next = null; copy_node.next = null; break; &#125; &#125; return result;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"链表","slug":"链表","permalink":"http://blog.cairui99.cn/tags/链表/"}]},{"title":"检查是否安装某种php扩展","slug":"php-检查是否安装某种php扩展","date":"2019-11-27T08:21:22.000Z","updated":"2019-11-27T08:26:37.687Z","comments":true,"path":"2019/11/27/php-检查是否安装某种php扩展/","link":"","permalink":"http://blog.cairui99.cn/2019/11/27/php-检查是否安装某种php扩展/","excerpt":"","text":"1、linux下使用命令：php -m 可列出已安装的php扩展 2、使用phpInfo()函数，可展示已安装的php扩展 3、使用如下代码验证： 1234567&lt;?php$extension= ''; //需要验证的某种扩展if (extension_loaded($extension)) &#123; echo '开启了扩展';&#125; else &#123; echo '没有开启扩展';&#125;","categories":[{"name":"操作","slug":"操作","permalink":"http://blog.cairui99.cn/categories/操作/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.cairui99.cn/tags/php/"}]},{"title":"荷兰国旗问题-单向链表版","slug":"算法题-荷兰国旗问题-单向链表版","date":"2019-11-27T05:39:20.000Z","updated":"2019-11-28T02:32:53.339Z","comments":true,"path":"2019/11/27/算法题-荷兰国旗问题-单向链表版/","link":"","permalink":"http://blog.cairui99.cn/2019/11/27/算法题-荷兰国旗问题-单向链表版/","excerpt":"题目将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。 进阶：左、中、右三个部分内部需要与原链表顺序一致","text":"题目将给定一个标准数，一个单向链表的头节点，实现将链表中小于标准数的放左边，等于的放中间，大于的放右边。 进阶：左、中、右三个部分内部需要与原链表顺序一致 思路一使用辅助数组实现： 创建一个辅助数组，遍历链表将节点放入数组中 在数组中调整元素的位置，具体操作可见荷兰国旗问题 在数组中调整好顺序后再将值赋给原链表 代码： 12345678910public class ListNode &#123; public ListNode next = null; public int value; public ListNode(int value) &#123; this.value = value; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * 使用辅助数组 * 空间复杂度O(n) */public static void arrayMethod(ListNode head, int num) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ListNode node = head; while (node != null) &#123; list.add(node.value); node = node.next; &#125; int indexFront = 0; int indexMid = 0; int indexRear = list.size() - 1; while (indexMid &lt;= indexRear) &#123; if (list.get(indexMid) &lt; num) &#123; swap(list,indexMid,indexFront); indexMid++; indexFront++; &#125; else if (list.get(indexMid) == num) &#123; indexMid++; &#125; else &#123; swap(list,indexMid,indexRear); indexRear--; &#125; &#125; node = head; for (Integer integer : list) &#123; node.value = integer; node = node.next; &#125;&#125;private static void swap(List&lt;Integer&gt; list, int x, int y)&#123; int temp = list.get(x); list.set(x, list.get(y)); list.set(y, temp);&#125; 思路二为了实现进阶的要求，同时降低空间复杂度，只能在链表内部进行操作： 遍历链表，将链表拆分为小于、等于、大于三条子链表：只需创建6个变量，分别表示小于、等于、大于部分子链表的头尾节点 将三条子链表头尾连接，变为一条完整的链表返回即可 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 进阶版 * 保证稳定性，同时空间复杂度达到O(1) */public static void dutchFlagListNode(ListNode head, int num) &#123; if (head == null || head.next == null) &#123; return; &#125; ListNode less_head = null; ListNode less_tail = null; ListNode eq_head = null; ListNode eq_tail = null; ListNode more_head = null; ListNode more_tail = null; while (head != null) &#123; if (head.value &lt; num) &#123; if (less_head == null) &#123; less_head = head; less_tail = head; &#125; else &#123; less_tail.next = head; less_tail = less_tail.next; &#125; &#125; else if (head.value == num) &#123; if (eq_head == null) &#123; eq_head = head; eq_tail = head; &#125; else &#123; eq_tail.next = head; eq_tail = eq_tail.next; &#125; &#125; else &#123; if (more_head == null) &#123; more_head = head; more_tail = head; &#125; else &#123; more_tail.next = head; more_tail = more_tail.next; &#125; &#125; head = head.next; &#125; //连接小于、等于、大于部分 head = null; ListNode tail = null; if (less_head != null) &#123; head = less_head; tail = less_tail; &#125; if (eq_head != null) &#123; if (head != null) &#123; tail.next = eq_head; &#125; else &#123; head = eq_head; &#125; tail = eq_tail; &#125; if (more_head != null) &#123; if (head != null) &#123; tail.next = more_head; &#125; else &#123; head = more_head; &#125; tail = more_tail; &#125; //尾部至空，防止链表成环 if (tail != null &amp;&amp; tail.next != null) tail.next = null;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"链表","slug":"链表","permalink":"http://blog.cairui99.cn/tags/链表/"}]},{"title":"判断链表是否为回文结构","slug":"算法题-判断链表是否为回文结构","date":"2019-11-25T03:13:31.000Z","updated":"2019-11-28T02:33:07.760Z","comments":true,"path":"2019/11/25/算法题-判断链表是否为回文结构/","link":"","permalink":"http://blog.cairui99.cn/2019/11/25/算法题-判断链表是否为回文结构/","excerpt":"题目给定一个链表的头节点head,请判断该链表是否为回文结构。 回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构","text":"题目给定一个链表的头节点head,请判断该链表是否为回文结构。 回文结构：将给定序列倒序排列后与原序列相等，则称为回文结构 思路1使用栈结构辅助判断，时间复杂度O(n)，空间复杂度O(n)： 将链表从头到尾依次入栈 再从头部开始遍历链表，同时依次将栈中元素弹出，比较每两个节点的值是否相等 如果全部相等则说明链表是回文结构，出现不相等的情况时则链表不是回文结构 代码： 12345678910111213141516171819202122/** * 使用栈结构 * 额外空间O(n) */public static boolean stackMethod(ListNode head) &#123; if (head == null) &#123; return false; &#125; ListNode node = head; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (node != null) &#123; stack.push(node.value); node = node.next; &#125; while (!stack.isEmpty()) &#123; if (head.value != stack.pop()) &#123; return false; &#125; head = head.next; &#125; return true;&#125; 思路2使用快慢指针+逆序链表的方式，可以实现时间复杂度O(n)，空间复杂度O(1)： 使用快慢指针的方式找到链表的中间节点：快指针一次走两步、慢指针一次走一步，两个指针初始位于链表的头部并同时开始移动，当快指针到达链表尾部时慢指针的位置就是链表的中间节点 将链表的后半部分逆序，同时将中间节点指向null 此时该链表的头部和尾部都指向了中间节点，中间节点指向null，使用两个指针分别在链表的头尾开始遍历，每次比较两个指针所指向的节点的value是否相等 如果出现不相等的情况则链表不是回文结构，当两个指针都走到了中间节点时还没有出现不相等的情况，则该链表是回文结构，记录下结论 将链表调整为最初的状态(如果需要的话)，然后返回结论 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 快慢指针+逆序链表 * 额外空间O(1) */public static boolean isPalindromeList(ListNode head) &#123; if (head == null) &#123; return false; &#125; else if (head.next == null) &#123; return true; &#125; ListNode fast = head; ListNode slow = head; //链表元素的个数是否为单数 boolean isSingular = true; //寻找链表的中心点 while (true) &#123; if (fast.next == null) &#123; break; &#125; if (fast.next.next == null) &#123; isSingular = false; break; &#125; slow = slow.next; fast = fast.next.next; &#125; //逆序链表的后半部分 ListNode node1 = head; ListNode node2 = null; if (isSingular) &#123; node2 = reverseListNode(slow); &#125; else &#123; node2 = slow.next; slow.next = null; node2 = reverseListNode(node2); &#125; //判断链表是否是回文结构 boolean result = true; ListNode tailNode = node2; while (true) &#123; if (node1 == null &amp;&amp; node2 == null) &#123; break; &#125; else if (node1 == null || node2 == null) &#123; result = false; break; &#125; else if (node1.value != node2.value) &#123; result = false; break; &#125; node1 = node1.next; node2 = node2.next; &#125; //调整链表至最初状态 reverseListNode(tailNode); return true;&#125;/** * 反转链表 * @param head 头节点 * @return 反转后的头节点 */private static ListNode reverseListNode(ListNode head) &#123; ListNode before = null; ListNode node = head; ListNode next = head.next; while (true) &#123; node.next = before; before = node; node = next; if (node == null) &#123; break; &#125; next = node.next; &#125; return before;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"链表","slug":"链表","permalink":"http://blog.cairui99.cn/tags/链表/"}]},{"title":"区块链与比特币","slug":"区块链与比特币","date":"2019-11-20T07:17:39.000Z","updated":"2020-01-14T11:18:40.878Z","comments":true,"path":"2019/11/20/区块链与比特币/","link":"","permalink":"http://blog.cairui99.cn/2019/11/20/区块链与比特币/","excerpt":"区块链2008年11月1日， 中本聪（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“比特币”的电子货币及其算法，其中实现比特币的底层技术：chain of blocks 在最早的比特币白皮书中文翻译版中，将 chain of blocks 翻译成了 区块链，这是区块链这一中文词的第一次出现。","text":"区块链2008年11月1日， 中本聪（真实身份未知）在网络上发布了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点式的电子现金系统），论文中描述了一种被他称为“比特币”的电子货币及其算法，其中实现比特币的底层技术：chain of blocks 在最早的比特币白皮书中文翻译版中，将 chain of blocks 翻译成了 区块链，这是区块链这一中文词的第一次出现。 想要解决的问题我们先不对区块链进行定义与讲解，先了解一下使用区块链想要解决哪种问题？ 想象一下，你和你的朋友在外面吃完饭后，你买了单，由于之前说好了AA制，你的朋友现在需要给你100块钱，于是你的朋友打开了手机里的转账工具给你转了100块钱，然后你确认了下转账记录。 好了，到此为止这笔100元的转账已经完成了，但你们两人之间并没有发生事实上的一笔现金交易，本质上呢？其实就是在银行机构的数据库中，在你朋友的账目上减去100，在你的帐目上加上100，这笔交易实则只是账簿上的一个条目。更准确的说，这是一条既不受你和你的朋友控制、也不被你们所拥有的条目，之所以肯定的认为这笔交易是成立的，仅仅是出于你对第三方机构的信任和依赖，这就是现有体系的问题。 你也许会问，我依赖第三方机构有什么问题？ 问题在于，你所拥有的不过是清一色的数字，并且修改权不在你： 要是中央数据库的数据丢失了呢？ 要是转账软件出现bug，或者你的银行经理搞错了，把1500元写成了1000元呢？ 要是，他根本就是有意为之呢？你真的可以完全信任他吗？ 多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。 现在问题清晰了，是否可以实现一个系统，在那里我们无需银行(第三方机构)就可以转账？ 我们将这个问题挖的更深一点，转账意味什么？只是在账簿上的一个记录而已，那么———— 1是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？ 是的， 区块链 就是这个问题的答案，区块链被很多人定义为 加密的分布式记账技术，它是一种在我们中间维护账簿而非依赖第三方来为我们代劳的方法。 下面就来介绍一下这个分散式账簿是如何实现的。 区块链是如何工作的？使用区块链维护账簿的要求是： 必修有足够的人不想依赖第三方， 至少要三个。 一个简单的例子，假设有10个人打算使用区块链来维护彼此之间的账簿： 这10个人一直拥有着彼此的账号信息，但不知道真实身份。 一个空的文件夹一开始的时候，每个人都拥有一个空的文件夹和一些空的纸张。 一笔交易发生的时候在这个网络中的每个人都纸笔在手，随时准备记录下每时每刻发生的任何交易。 现在假设2号想要给9号转10块钱，于是2号将这个信息广播给所有人，我想转10元钱给9号，大家都记录下来！ 这时收到通知的人都通过历史的交易记录来确认2号是否有足够的余额转账，如果确认2号有足够的钱，每个人都在自己维护的账簿上记录下这笔交易。 时间过的很快，在这个网络中随时都在发生着交易，为了保证交易的成立，我们需要每隔一段时间更换新的纸张记录新的交易信息，并将上一份交易记录保存起来。 我将交易记录保存之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。 密封过后没人能够对这份大家都认同的交易记录做出更改，直至永远。 如果可以做到这点，那么大家就都可以信任被密封过的交易记录。 (在比特币中一般把将用来密封交易记录的东西称之为“矿”或者“工作量证明”) 123第三方/中介给予我们信任，其形式是：交易发生后账簿不可更改。在区块链这样的分散式、去中心化的系统中，这把唯一的钥匙将提供信任替代。 密封为了让每个人都信任密封过的交易记录无法被更改，那么这一封存手法，就是区块链中交易成立的关键。 使用到的加密算法： SHA256加密算法 sha256简单来说是一种不可逆的加密算法，对于给定的任意长度的输入，sha256都会产生一个256bit长的哈希值，可以先理解为一个hash函数。 请看下面这个问题： 12345你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符我该从左边输入什么东西进去呢？比如000ab，或者00098，或者000fa或者其它情况中的任何一个。 貌似只有这样一个办法，穷尽宇宙中所有的数字，直到我得到了数字经过sha256之后的值为一个三个0开头的一串字符。 得到输入值是极端困难的，但是，如果其他人想要验证你的答案是否正确，却是非常容易的。 如何加密账单？能不能找到一个数字，让它加上这张账单中的内容以后的加密输出是一个以三个0开头的字符？为了简化问题，假设20893就是账单的内容： 在花费许多时间和电力后，我们会偶然发现一个数字，比如21191，符合了我们的要求： 此时，数字21191就可以作为账单20893的封条，但在此之前，我们还需要区块链网络中大部分人的认可：在网络中，每个人都会进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。 当有人发布了这个数字之后，每个人都立即验证它是否能产生要求的输出值， 如果大部分人都同意这个密封数字，无论这个数字是什么，都会成为那个可信的密封数字。 但是，如果对于某人，例如#7，那个被宣布的数字无法产生要求的输出值，此时大部分都同意了这个密封数字，无论错误的原因是什么，#7只有一个选择： 放弃他记录的账单，从其他人处获得拷贝，使他可以用该数字正常密封账单。 否则他将无法在该网络中继续交易。 防止对密封数字的修改想象现在已经加密好了5份历史账单，而非1份。如果我回溯到第二页纸，改动交易记录企图作弊，会怎么样？ 在我企图花这笔钱的时候，密封数字+账单内容的hash值会让任何人察觉到交易记录的矛盾。那假如我更新一步、在修改完交易记录之后重新计算出了新的密封数字、让其他人无法察觉到我做了修改呢？ 为了防止这个问题的发生，即有人回溯到历史区块修改了其中内容和密封数字，其实除了初始区块，正确的密封数字是这样计算出来的： 事实上，在计算密封数字时，除了需要加上该区块的转账记录，还需要加上 前一个区块的sha256输出值。 此时可以保证每一个区块都依赖于它的上一个区块，如果有人想要修改一个区块历史记录，那个他将必须改变该区块之后的所有区块的内容以保证链条的一致。但与此同时，在网络中每个人的努力下，新的区块也在不断的增加，作弊者一个人的速度永远无法赶上所有人的速度，导致此次作弊他将无法成功。 将会发生的事情是，从他可以尝试作弊的那一刻开始，他将要在这个网络中创造出另一条区块链，那它创造的区块链无法赶上可信的区块链，所以在区块链网络中：最长的链就是可信的链，每一笔交易只允许发生在最长的链上 如果，不是一个人在作弊，而是大部分的人一起作弊呢？ 这种情况下，区块链将会被攻陷，协议将会落空流于表面。 这种行为被称为 51%攻击. 奖励机制我们都知道会有人算出密封数字并公布它，为什么每个人还要耗费资源来进行计算呢？为什么不坐视不理，等着抱大腿呢？ 问题的答案就是激励人们加入到区块链这幅图景的地方：第一个计算出密封数字的人将得到免费的金钱作为对他的努力的奖励。 这就是比特币变为现实的方式。他是在区块链上被用来交易的第一种货币。当足够的人持有比特币，比特币会升值，升值会使更多人想要得到比特币，这使比特币进一步升值：如此循环往复。 123“只让人们在比特币带来的交易中获取比特币，或许是有意义的。一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009* 待更新… 参考文章 https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348","categories":[{"name":"拓展知识","slug":"拓展知识","permalink":"http://blog.cairui99.cn/categories/拓展知识/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://blog.cairui99.cn/tags/区块链/"}]},{"title":"MySql-使用explain分析sql","slug":"MySql-使用explain分析sql","date":"2019-11-14T05:54:05.000Z","updated":"2019-11-14T07:22:04.283Z","comments":true,"path":"2019/11/14/MySql-使用explain分析sql/","link":"","permalink":"http://blog.cairui99.cn/2019/11/14/MySql-使用explain分析sql/","excerpt":"在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。 Expliain语法：explain + sql语句","text":"在mysql中可以使用explain关键字来分析sql语句的执行效果，从而帮助我们选择出更好的索引和优化查询的方案，写出性能更高的语句。 Expliain语法：explain + sql语句 Expliain执行后包含以下信息： 123+----+-------------+-------+------+---------------+-----+---------+-----+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-------+------+---------------+-----+---------+------+-----+-------+ idsql的查询序列号，在分析的sql中包含子查询时会出现多条id，id表示了sql的执行顺序： id相同：执行顺序由上至下执行 id不同，按id由大到小执行 select_type表示select的类型，包含以下几种： select_type 含义 SIMPLE 简单SELECT(不使用UNION或子查询等) PRIMARY 最外层的 select 查询(使用到主键作为查询条件) UNION UNION中的第二个或后面的SELECT语句 DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询 UNION RESULT UNION的结果 SUBQUERY 子查询中的第一个SELECT,不依赖于外部查询的结果集 DEPENDENT SUBQUERY 子查询中的第一个select查询,依赖于外部查询的结果集 DERIVED 导出表的SELECT(FROM子句的子查询) table表示该条查询的表名 如果查询是使用了别名，显示的是别名 如果不涉及数据库表，显示NULL 如果显示结果别这种形式，表示这是个临时表，N为查询序列号，表示临时表的结果来自于这个查询产生;&lt;derived M,N&gt;表示结果来自于一个UNION查询，查询id为M和N typetype表示访问类型，是sql性能较为重要的一项制表，由好到坏依次是：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，all,除了all之外的其他type都用到了索引。 常用的几个type： system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all 一般情况下我们要保证你的sql至少达到range级别，最好达到ref。 type 含义 system 表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index const 使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描 eq_ref 出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref ref 不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。 fulltext 全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 ref_or_null 与ref方法类似，只是增加了null值的比较。实际用的不多 unique_subquery 用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery 用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 range 索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。 index_merge 表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range index 索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。如explain select id from user all 这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。 possible_keys显出可能使用到的索引 key查询中实际使用到的索引 key_lenkey_len显示的值为索引字段的最大可能长度，并非实际使用长度 ref显示使用哪个列或常数与key一起从表中选择行。 rows显示MySQL认为它执行查询时必须检查的行数 Extra包含了MySQL解决查询的详细信息，也是关键参考项之一，可显示的信息多达几十种，这里不进行列举了。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.cairui99.cn/categories/Mysql/"}],"tags":[{"name":"sql优化","slug":"sql优化","permalink":"http://blog.cairui99.cn/tags/sql优化/"}]},{"title":"判断k是否在矩阵中","slug":"算法题-判断k是否在矩阵中","date":"2019-11-12T08:23:01.000Z","updated":"2019-11-28T02:33:14.002Z","comments":true,"path":"2019/11/12/算法题-判断k是否在矩阵中/","link":"","permalink":"http://blog.cairui99.cn/2019/11/12/算法题-判断k是否在矩阵中/","excerpt":"题目给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵： 要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。","text":"题目给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的，例如下图矩阵： 要求：实现一个函数,判断K是否在matrix中。算法的时间复杂度为O(N+M)、额外空间复杂度为O(1)。 思路 创建一个指针，初始位置可选取排序矩阵中两个特殊的点，右上角的点和左下角的点 假设指针设置在了矩阵的右上角，在排好序的矩阵中，该点的特殊性为：大于左边的所有元素同时小于下方的所有元素 跟据该特性，判断指针所在位置的元素和整数k的关系： 等于k：返回true 大于k：指针向左移动，如果移动后超过了矩阵边界返回false 小于k：指针向下移动，如果移动后超过了矩阵边界返回false 重复执行上述步骤，直至函数return 代码1234567891011121314151617181920212223242526272829/** * 【题目】给定一个有N*M的整型矩阵matrix和一个整数K,matrix的每一行和每一列都是排好序的. * 实现一个函数,判断K是否在matrix中 * 【要求】时间复杂度为O(N+M),额外空间复杂度为O(1). * @author Cairui * @time 2019-11-08 */public class SortMatrixNum &#123; public static boolean isExist(int[][] matrix, int num) &#123; if (matrix == null) &#123; return false; &#125; int[] index = &#123;0, matrix[0].length - 1&#125;; while (true) &#123; if (matrix[index[0]][index[1]] == num) &#123; return true; &#125; else if (matrix[index[0]][index[1]] &gt; num) &#123; index[1]--; &#125; else &#123; index[0]++; &#125; if (index[0] &gt;= matrix.length || index[1] &lt; 0) &#123; return false; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"旋转正方形矩阵","slug":"算法题-旋转正方形矩阵","date":"2019-11-07T07:43:14.000Z","updated":"2019-11-28T02:33:50.100Z","comments":true,"path":"2019/11/07/算法题-旋转正方形矩阵/","link":"","permalink":"http://blog.cairui99.cn/2019/11/07/算法题-旋转正方形矩阵/","excerpt":"题目给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 要求：额外空间复杂度为O(1)。","text":"题目给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 要求：额外空间复杂度为O(1)。 举例： 思路大体思路做到由外到内一圈一圈旋转，具体步骤如下： 取左上角与右上角的坐标A、B，由A、B来确定完整的一圈 要将一个整圈进行旋转时，旋转方法为：选择4个对称的点进行顺时针的互换，例如图中的1、3、9、7和2、6、8、4，将所有对称的点进行顺时针的互换来实现旋转 旋转完成后将A、B的坐标向内缩小，重复上述旋转步骤，直至A横纵坐标大于等于B时结束流程 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Code;/** * 旋转正方形矩阵 *【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。 *【要求】 额外空间复杂度为O(1)。 * @author CaiRui * @time 2019-11-06 */public class ClockwiseRotateMatrix &#123; public static void clockwiseRotateMatrix(int[][] matrix) &#123; //不是正方形矩阵 if (matrix == null || matrix.length != matrix[0].length || matrix.length &lt; 2) &#123; return; &#125; int A = 0; int B = matrix.length - 1; while (A &lt; B) &#123; clockwise(matrix, A, B); A++; B--; &#125; &#125; /** * 旋转一个外圈 * @param matrix 矩阵 * @param A 左上角坐标(A, A) * @param B 右下角坐标(B, B) */ private static void clockwise(int[][] matrix, int A, int B) &#123; int[] leftOn = &#123;A, A&#125;; int[] rightOn = &#123;A, B&#125;; int[] leftDown = &#123;B, A&#125;; int[] rightDown = &#123;B, B&#125;; while (leftOn[1] &lt; B) &#123; swap(matrix, leftOn, rightOn, rightDown, leftDown); leftOn[1]++; rightOn[0]++; leftDown[0]--; rightDown[1]--; &#125; &#125; private static void swap(int[][] matrix, int[] A, int[] B, int[] C, int[] D) &#123; int tempA = matrix[A[0]][A[1]]; int tempB = matrix[B[0]][B[1]]; int tempC = matrix[C[0]][C[1]]; int tempD = matrix[D[0]][D[1]]; matrix[A[0]][A[1]] = tempD; matrix[B[0]][B[1]] = tempA; matrix[C[0]][C[1]] = tempB; matrix[D[0]][D[1]] = tempC; &#125;&#125; 测试： 123456789101112131415161718192021222324252627282930package Test;import Code.ClockwiseRotateMatrix;public class CodeTest &#123; private static void printMatrix(int[][] matrix) &#123; for (int[] ints : matrix) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; System.out.print(ints[j] + \" \"); &#125; System.out.println(); &#125; &#125; private static void clockwiseRotateMatrixTest() &#123; int[][] matrix = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;// int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; System.out.println(\"原矩阵：\"); printMatrix(matrix); System.out.println(\"旋转后矩阵：\"); ClockwiseRotateMatrix.clockwiseRotateMatrix(matrix); printMatrix(matrix); &#125; public static void main(String[] args) &#123; CodeTest.clockwiseRotateMatrixTest(); &#125;&#125; 运行结果： 12345678原矩阵：1 2 3 4 5 6 7 8 9 旋转后矩阵：7 4 1 8 5 2 9 6 3","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"之字形打印矩阵","slug":"算法题-之字形打印矩阵","date":"2019-11-05T07:43:50.000Z","updated":"2019-11-28T02:34:13.688Z","comments":true,"path":"2019/11/05/算法题-之字形打印矩阵/","link":"","permalink":"http://blog.cairui99.cn/2019/11/05/算法题-之字形打印矩阵/","excerpt":"题目输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵 打印结果为： 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16","text":"题目输入一个矩阵，按照“之”字形的方式打印这些矩阵，例如下图矩阵 打印结果为： 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16 要求：额外空间复杂度为O(1) 思路 创建两个指针A和B，初始坐标都是(0,0),相当于矩阵的左上角 指针A、B每次同时移动一格，移动规则为： 指针A先每次向右移动一格，当移动至矩阵右上角时，开始向下移动 指针B先每次向下移动一格，当移动至矩阵左下角时，开始向右移动 在每次指针A、B移动后进行一次打印，打印出A、B两点的连线中所经过数字，并且每次打印的顺序都要相反(即第一次打印时由A到B打印，下次打印就由B到A打印) 最后A、B一定会在矩阵的右下角相遇，打印出右下角的点后，之字型打印矩阵结束 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 之字型打印矩阵 * @author CaiRui * @time 2019-11-04 */public class ZigZagPrintMatrix &#123; private static void zigZagPrintMatrix(int[][] matrix) &#123; //不是矩阵 if (matrix == null || matrix.length &lt;= 1 || matrix[0].length &lt;= 1) &#123; return; &#125; int[] indexA = &#123;0, 0&#125;; int[] indexB = &#123;0, 0&#125;; boolean isAToB = false; while (true) &#123; printStraightLine(matrix,indexA,indexB,isAToB); if (indexA[0] == (matrix.length - 1) &amp;&amp; indexA[1] == (matrix[0].length - 1)) &#123; //终点 break; &#125; //更新A、B坐标 if (indexA[1] == (matrix[0].length - 1)) &#123; indexA[0]++; &#125; else &#123; indexA[1]++; &#125; if (indexB[0] == (matrix.length - 1)) &#123; indexB[1]++; &#125; else &#123; indexB[0]++; &#125; isAToB = !isAToB; &#125; &#125; //打印点A~B这条线的元素 private static void printStraightLine(int[][] matrix, int[] indexA, int[] indexB, boolean isAToB) &#123; //只有一个元素 if (indexA[0] == indexB[0] &amp;&amp; indexA[1] == indexB[1]) &#123; System.out.println(matrix[indexA[0]][indexA[1]]); return; &#125; //不能改变数组中的值,用变量代替 int x = isAToB ? indexA[0] : indexB[0]; int y = isAToB ? indexA[1] : indexB[1]; if (isAToB) &#123; // 从A打印到B while (true) &#123; System.out.print(matrix[x][y]+\" \"); if (x == indexB[0] &amp;&amp; y == indexB[1]) &#123; break; &#125; x++; y--; &#125; &#125; else &#123; // 从B打印到A while (true) &#123; System.out.print(matrix[x][y]+\" \"); if (indexA[0] == x &amp;&amp; indexA[1] == y) &#123; break; &#125; x--; y++; &#125; &#125; System.out.println(); &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; ZigZagPrintMatrix.zigZagPrintMatrix(matrix); &#125;&#125; 运行结果：","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"go语言学习笔记","slug":"go-go语言学习笔记","date":"2019-11-01T06:04:02.000Z","updated":"2020-04-21T02:54:21.619Z","comments":true,"path":"2019/11/01/go-go语言学习笔记/","link":"","permalink":"http://blog.cairui99.cn/2019/11/01/go-go语言学习笔记/","excerpt":"从零开始","text":"从零开始 参考书籍：《Go程序设计语言》 环境部署前往官网下载源码点击此处官网(可能需要翻墙) 根据你的系统选择对应的源码包，我的环境是Centos7，选择linux的 解压并安装1$ tar -zxvf go1.13.4.linux-amd64.tar.gz 配置环境变量123456789101112131415161.创建workspace$ mkdir -p workspace/src2.配置环境变量$ vi ~/.bashrc将以下配置添加进bashrc中export GOROOT=$HOME/goexport GOPATH=$HOME/workspaceexport PATH=$GOROOT/bin:$GOPATH/bin:$PATH使配置生效$ source ~/.bashrc3.验证是否成功$ go version 入门体验用Go编写一些你在已经使用其他编程语言编写过的一些经典程序，对有其他编程语言经验的程序员来说，这是学习Go语言更高效的方式。 HelloWorld创建一个 HelloWorld.go 文件 (注意创建在你的GOPATH目录下) 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello World\")&#125; go是编译性语言，使用run命令来将一个或多个.go来进行编译、链接，然后运行生成的可执行文件： 1234$ go run HelloWorld.go输出：Hello World 如果你的程序不是一次性实验，那么每次运行时都将.go进行编译显然是多余的，我们可以手动编译出来一个可直接执行的程序，使用go build实现： 1$ go build HelloWorld.go 此时会在目录下生成一个名为HelloWorld的二进制程序，该文件可直接不做处理直接执行： 1234$ ./HelloWorld输出：Hello World 下面说一下代码：Go代码使用包(package)来组织，一个包由多个.go文件组成，放在一个文件夹中，文件夹的名字也就是包名描述了包的作用，类似于其他语言的库或模块。 每个.go文件都需要在开头声明文件所在的包名，HelloWorld中是package main，main包是一个特殊的包，它用来定义一个可执行的程序，而不是函数库，在任何程序中main总是程序最开始执行的地方。 package声明后面需要紧跟import，它表示程序导入其他包的列表。HelloWorld例子中导入了fmt包，fmt包中的函数用来格式化输出和扫描输入，比如程序中使用的fmt.Println,是fmt中的一个基本输出函数。Go语言要求你必须精确的导入你所需要的包，在缺失import包或者import进了不需要的包，会编译失败，这样严格的要求保证了Go程序不不会导入多余的包。 在import之后，包含了组成程序常量、变量、类型、函数的声明，此时声明的顺序是严格要求了，在示例中只声明了一个main函数。 Go不需要在语句的末尾添加”;”,除非多个语句放在同一行，此时”;”用来区分不同的语句 Go语言同时还对程序的格式有着严格的要求，例如函数声明中，”{“必须和关键字fun在同一行，不允许单独换行。从语言层面就限制了格式，保证了在你的项目中不会出现各种各样的编码风格，同时可以省去大量对程序本身无关紧要的代码风格的辩论。 输出命令行参数123456789101112131415package mainimport ( \"os\" \"fmt\")func main() &#123; var s, sep string for i := 1; i &lt; len(os.Args); i++ &#123; s += sep + os.Args[i] sep = \" \" &#125; fmt.Println(s)&#125; os包提供了一些函数和变量，以与平台无关的方式和操作系统打交道，上面程序使用了os包中的Args变量，来获取程序运行时从外部获得的参数。 运行结果如下： 1234$ go run echo.go 1 3 -X ?输出：1 3 -X ? 使用var声明两个string类型的变量s、sep，没有对变量进行初始化，此时两个string类型的变量就被隐式的初始化为空字符串 循环变量i在for循环的开始处声明，使用 := 进行短变量声明，此时go会根据初始化的值来给变量赋予合适的类型；因为在Args中，Args[0]中存储的值为该程序本身的执行语句，所以这里将变量i初始化为1。 注意go中的for循环的循环条件不需要使用小括号，但循环内部的语句必须使用大括号括起来，而且左大括号不能独立成行，必须和前置语句在同一行 for是go中唯一的循环语句，有好几种形式，上面的程序是其中一种，格式为： 1234//传统的for循环for initialization; condition; post &#123; // ...&#125; 其中三个部分都是可以省略的，例如： 123456789//传统的while循环for condition &#123; // ...&#125;//无限循环 while(true)for &#123; //...&#125; 无限循环这种形式可以通过如break、return等语句进行终止 还有一种形式的for循环是在字符串或者数组上迭代，现在给出echo.go的另一版写法来辅助说明： 123456789101112131415package mainimport ( \"os\" \"fmt\")func main() &#123; s, sep := \"\", \"\" for _, arg := range os.Args[1:] &#123; s += sep + arg sep = \" \" &#125; fmt.Println(s)&#125; 首先使用了另外一种方式定义了变量s和sep，go语言中共有4种定义变量的方式如下： 12345678//定义简洁方便，通常在函数内部使用，不适用于包级别的变量s := \"\"//使用默认初始化值时的定义方式var s string//很少使用，除非定义多个变量时使用var s = \"\"//在类型不一致时，强调类型使用var s string = \"\" 在for循环中，使用了range关键字来迭代数组，range在每一次迭代中会产生一对值：索引和这个索引对应的值，但此时range产生的索引我们是不需要的，但在go语言中不允许出现无用的变量，编译会出错，所以这里我们将无用的索引赋值给 _ 这个变量，_ 在go语言中表示 空标识符 ，空标识符可以用在任何语法需要给变量赋值但程序逻辑不需要的地方。 如果有大量的数据需要处理，以上两种写法代价会比较大，使用string包中的join函数是一种简单又高效的方法： 1234567891011package mainimport ( \"fmt\" \"strings\" \"os\")func main() &#123; fmt.Println(strings.Join(os.Args[1:], \"\"))&#125; 最后，如果不关心格式或者只是调试程序时，可以直接使用Println： 12345678910package mainimport ( \"fmt\" \"os\")func main() &#123; fmt.Println(os.Args[1:])&#125; 结果和预期很像，只是两边有括号： 123$ go run echo4.go 1 2 s d ?[1 2 s d ?] 找出重复行从控制台输入下面的程序用来找出在控制台输入时出现次数大于1的行，我们将出现次数和内容打印出来，代码如下： 1234567891011121314151617181920212223package mainimport ( \"bufio\" \"os\" \"fmt\")func main() &#123; counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() &#123; if input.Text() == \"end\" &#123; break &#125; counts[input.Text()]++ &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(\"%d\\t%s\\n\",n,line) &#125; &#125;&#125; 程序运行结果如下： 123456789101112$ go run dup1.go112333end2 13 3 在程序使用变量count来记录重复行出现的次数，结构map存储一个键/值对，其中键的类型必须是可以进行相等(==)比较的类型，值可以存储任意类型，在例子中键使用string类型来存储行的内容，值为int类型用来存储出现的数量，使用go语言内置函数make()来创建一个新的map。 接下来引入了bufio包，使用它可以简便和高效地处理输入和输出。其中一个最有用的特性是成为扫描器(Scanner)的类型，它可以读取输入，以行或者单词为单位断开，这是处理以行为单位的输入内容最简单的方式。 在程序中我们新建了一个bufio.Scanner类型的input变量来读取来自控制台的输入。在每次调用input.Scan()时读取下一行，通过input.Text()来读取该行的内容，通过读取map中该行的出现次数，若没有出现过的话由于是int类型则初始值为0，在每次输入后将次数+1，这里设置了终止条件，当键盘输入了”end”时停止输入，开始打印重复行。 为了方便输出结果，依然使用基于range的for循环，遍历map输出值大于1的键与值。需要注意的是迭代输出map时顺序不是固定的，通常每次运行都不一致，所以该程序无法对输出顺序做任何保证。 下面说一下Printf，fmt.Printf()通过一个表达式列表生成格式化的输出。它的第一个参数格式化的指示字符串，由它指定最终的输出格式，其中可以包含转义字符或者(%+字符)。后面的参数表示需要格式化输出的变量。 例如程序中的 “%d\\t%s\\n”含义为： %d 为将一个整数格式化为十进制形式、 \\t 制表符、 %s 把参数输入为字符串、 \\n 换行符。 下面给出一些常用的Printf转义字符，Go程序员将其称为verb： verb 描述 %d 十进制整数 %x, %o, %b 十六进制、八进制、二进制整数 %f, %g, %e 浮点型 %t 布尔型 %c 字符 %s 字符串 %q 带引号的字符串(“abc”或者’c’) %v 内置格式的任何值 %T 任何值的类型 %% 百分号本身 流式读取文件下面的dup程序支持从文件中读取并查找出重复行，在命令行中传入文件路径，使用os.Open函数来打开文件： 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"os\" \"fmt\" \"bufio\")func main() &#123; counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 &#123; countLines(os.Stdin, counts) &#125; else &#123; for _, arg := range files &#123; f, err := os.Open(arg) if err != nil &#123; fmt.Fprintf(os.Stderr, \"dup2: %v\\n\", err) continue &#125; countLines(f, counts) f.Close() &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(\"%d\\t%s\\n\", n, line) &#125; &#125;&#125;func countLines(f *os.File, counts map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; if input.Text() == \"end\" &#123; break &#125; counts[input.Text()]++ &#125;&#125; for test： 首先创建一个测试文件，名为test.txt： 1234567112121231231231234 运行结果如下： 1234$ go run dup2.go test.txt3 1232 12 os.Open()函数用来打开一个文件，它有两个返回值：第一个返回值是打开的文件(* os.File),该文件随后使用Scanner进行读取，然后使用Close函数关闭文件，关闭后释放相应的资源(内存等)；第二个返回值是一个内置的error类型的值，在error等于内置nil值时，表示文件打开成功，如果error不等于nil，说明文件打开失败，error的值描述着错误原因。 可以看出 在go中函数的声明次序是任意的，包括main函数。 在示例中counts是一个由make创建的引用类型的map结构，所以在countLines函数中修改的值，返回main中依然有效。 一次性读取文件上面的dup2示例采用流式模式读取文件，然后按需拆分为行，该方法更适用于处理海量数据的情况。 下面提供一种方式是一次性的读取文件到内存、一次性地分割所有行，然后进行按需处理： 123456789101112131415161718192021222324252627package mainimport ( \"os\" \"io/ioutil\" \"fmt\" \"strings\")func main() &#123; counts := make(map[string]int) for _, filename := range os.Args[1:] &#123; data, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Fprintf(os.Stderr, \"dup3: %v\\n\", err) continue &#125; for _, line := range strings.Split(string(data), \"\\n\") &#123; counts[line]++ &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(\"%d\\t%s\\n\", n, line) &#125; &#125;&#125; 运行方式与结果同dup2.go ioutil.ReadFile()方法返回的第一个参数是一个可以转化为字符串的slice，这样在后面的for循环中可以把它转换为string，然后将它按行(\\n)分割，实现查找重复行；返回的第二参数与os.Open函数的error相同，值为nil时表示成功，失败时值为失败信息。 获取URL的内容程序fetch通过命令行来读取url，通过net包下面的方法来获取指定url的内容，然后不加解析地输出： 12345678910111213141516171819202122232425package mainimport ( \"os\" \"net/http\" \"fmt\" \"io/ioutil\")func main() &#123; for _, url := range os.Args[1:] &#123; resp, err := http.Get(url) if err != nil &#123; fmt.Fprintf(os.Stderr, \"fetch: %v\\n\", err) os.Exit(1) &#125; b, err := ioutil.ReadAll(resp.Body) resp.Body.Close() if err != nil &#123; fmt.Fprintf(os.Stderr, \"fetch: reading %s: %v\\n\", url, err) os.Exit(1) &#125; fmt.Printf(\"%s\", b) &#125;&#125; 上面程序使用net/http包的http.Get函数来产生一个HTTP请求，在没有出错的情况下返回结果会保存到resp中，其中resp.Body为一个可读数据流，通过ioutil.ReadAll来读取整个响应结果并存入b，随后关闭Body数据流来避免起源泄露。 并发获取多个URL的内容Go语言的特点之一就是支持并发编程，我们通过下面程序的程序简单了解下go的主要并发机制、goroutine和通道(channel)。下面程序用来从命令行读取很多个URL，并发的获取这些URL的内容，并返回获取每个URL的时间与程序执行的总时间 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"time\" \"os\" \"fmt\" \"net/http\" \"io\" \"io/ioutil\")func fetch(url string, ch chan&lt;- string) &#123; start := time.Now() resp, err := http.Get(url) if err != nil &#123; ch &lt;- fmt.Sprint(err) //发送到通道ch return &#125; nbytes, err := io.Copy(ioutil.Discard, resp.Body) resp.Body.Close() if err != nil &#123; ch &lt;- fmt.Sprintf(\"while reading %s: %v\", url, err) return &#125; secs := time.Since(start).Seconds() ch &lt;- fmt.Sprintf(\"%.2fs %7d %s\", secs, nbytes, url)&#125;func main() &#123; start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] &#123; go fetch(url, ch) //启动一个goroutine &#125; for range os.Args[1:] &#123; fmt.Println(&lt;-ch) //从通道ch接收 &#125; fmt.Printf(\"%.2fs elapsed\\n\", time.Since(start).Seconds())&#125; 运行结果如下： 1234567$ go run fetchall.go http://www.rong360.com http://www.jd.com http://www.weibo.com http://www.baidu.com0.03s 156218 http://www.baidu.com0.14s 106674 http://www.jd.com0.15s 611 http://www.weibo.com0.17s 110858 http://www.rong360.com0.17s elapsed goroutin是一个并发执行的函数，本质是协程。main函数就是在一个goroutine中执行的，在main中可以使用 go 关键字来创建额外的goroutine。goroutine之前可以使用channel来进行通信或者说是数据共享。 go语言中使用 chan 关键字来声明channel，在上面的程序中使用了make创建了一个字符串通道ch，接下来在for循环中每次循环都创建一个新的goroutine，可以实现异步的调用fetch()方法来获取URL内容，在fetch中将读取到的信息传入channel中，在main函数的第二个for循环中依次接收。 搭建一个Web服务器输出url路径使用Go的库将很容易实现一个Web服务器，用来响应像fetch那样的客户端请求，下面实现一个迷你服务器，它将展示出访问服务器的URL路径部分。 1234567891011121314151617package mainimport ( \"net/http\" \"fmt\" \"log\")func main() &#123; http.HandleFunc(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))&#125;//处理回显请求部分func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"URL.PATH = %q\\n\", r.URL.Path)&#125; 运行服务器： 1$ go run server1.go 效果如下： 这个程序只有寥寥几行代码，因为库函数做了大部分工作。main函数中， http.HandleFunc(“/“, handler) 代表所有以/开头的URL都将转交给handler这个方法来处理，然后启动服务器开始监听本地4000端口的请求。 一个请求由一个http.Request类型的结构体表示，其中包含请求的URL(http.Request.URL.Path)，handler函数的操作就是将URL提取出来使用Fprintf输出。 输出网址的访问数量为服务器添加功能很容易，下面的程序实现了当URL为/count时返回到现在为止请求的个数： 1234567891011121314151617181920212223242526272829303132package mainimport ( \"sync\" \"net/http\" \"log\" \"fmt\")var mu sync.Mutexvar count intfunc main() &#123; http.HandleFunc(\"/\", handler) http.HandleFunc(\"/count\", counter) log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))&#125;//处理程序回显请求的URL的路径部分func handler(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() count++ mu.Unlock() fmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path)&#125;//counter回显目前为止调用的次数func counter(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() fmt.Fprintf(w, \"Count %d\\n\", count) mu.Unlock()&#125; 在程序后台，服务器在不同的goroutine中运行处理函数，这样它可以同时处理多个请求，需要注意的是，在并发请求的情况下可能导致count的计数的不一致，为了避免该问题，所以使用了mu.lock()和mu.Unlock()两个方法对方法加锁，保证goroutine在同一时间最多只有一个对count变量进行操作，实现了共享变量的并发访问。 输出消息头和表单数据下面是一个更完整的例子，处理函数handler可以报告它接收到的消息头和表单数据，这样可以方便服务器审查和调试请求： 1234567891011121314151617181920212223242526272829package mainimport ( \"net/http\" \"log\" \"fmt\")func main() &#123; http.HandleFunc(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:4000\", nil))&#125;//处理回显请求部分func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"%s %s %s\\n\", r.Method, r.URL, r.Proto) for k, v := range r.Header &#123; fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) &#125; fmt.Fprintf(w, \"Host = %q\\n\", r.Host) fmt.Fprintf(w, \"RemoteAddr = %q\\n\", r.RemoteAddr) if err := r.ParseForm(); err != nil &#123; log.Print(err) &#125; for k, v := range r.Form &#123; fmt.Fprintf(w, \"Form[%q] = %q\\n\", k, v) &#125;&#125; 运行结果： 程序结构名称命名规范Go中对于函数、变量、常量、类型、语句标签和包名的命名全部遵循一个简单的规则：名称的开头是一个字母或者下划线，并区分大小写，后面可以跟任意字符的字母、数字或下划线。 Go存在一些不能用来命名的关键字，他们只能用在语法允许的地方： 另外还有一些内置的预声明的常量、类型和函数，这些名称不属于关键字，我们可以将它们用来命名，但不建议这么做，会有冲突的风险： 访问权限Go中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问(类似于其他语言的public)；如果首字母小写，则只能在本包中使用(类似于其他语言的private) 在定义结构体时，如果结构体是大写的，则该结构体可以被任意包访问，但无法访问结构体中以小写字母开头定义的参数，如果结构体需要通过json转码，需要注意参数不能使用小写，json无法解析小写字母开头的参数。 声明Go程序由一个或多个以.go为后缀的文件组成，每一个.go文件以package声明开头，表名文件属于哪个包。package声明后面是import声明，然后是包级别的变量、类型、常量、函数的声明，这4种声明不区分顺序，也是Go程序中主要的4种声明类型。 例如：下面的程序声明了一个常量、一个函数和一对变量： 123456789101112//输出水的沸点package mainimport \"fmt\"const boilingF = 212.0func main() &#123; var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(\"boiling point = %g°F or %g°C\\n\", f, c)&#125; 常量boilingF是一个包级别的声明，对包中所有源文件可见；变量f和c是属于main函数的局部变量，变量仅在main函数内部可见。 函数的声明包含一个函数名字，一个参数列表，一个可选的返回值列表（如果无需返回值可省略），以及函数体组成。 下面的程序封装了温度转换的方法fToC，在其他函数中可以进行多次调用： 1234567891011121314//两次华氏-摄氏温度的转换package mainimport \"fmt\"func main() &#123; const freezingF, boilingF = 32.0, 212.0 fmt.Printf(\"%g°F = %g°C\\n\",freezingF, fToC(freezingF)) fmt.Printf(\"%g°F = %g°C\\n\",boilingF, fToC(boilingF))&#125;func fToC(f float64) float64 &#123; return (f - 32) * 5 / 9&#125; 待更新…","categories":[{"name":"Go","slug":"Go","permalink":"http://blog.cairui99.cn/categories/Go/"}],"tags":[{"name":"go语言基础","slug":"go语言基础","permalink":"http://blog.cairui99.cn/tags/go语言基础/"}]},{"title":"设计原则-最少知识原则","slug":"设计原则-最少知识法则","date":"2019-11-01T03:31:11.000Z","updated":"2019-11-01T06:00:02.589Z","comments":true,"path":"2019/11/01/设计原则-最少知识法则/","link":"","permalink":"http://blog.cairui99.cn/2019/11/01/设计原则-最少知识法则/","excerpt":"定义最少知识法则也称为迪米特原则，定义为：一个对象应该对其他对象有最少的了解。","text":"定义最少知识法则也称为迪米特原则，定义为：一个对象应该对其他对象有最少的了解。 实践迪米特法则对实现类的低耦合提出了明确的要求，规则如下： 1.只和直接的朋友通信直接朋友指和该对象存在直接耦合关系的类，例如组合、聚合、依赖等。 类与类之间的联系是建立在类间的，而不是方法间，不要出现getA().getB()这种情况出现。以此来降低系统间的耦合，提高系统的健壮性。 2.朋友间也需要有距离一个类对外公布的public属性或方法越多，变更引起的风险就越大。因此在设计时尽量减少public方法和属性，方法和属性访问权限收缩的越小对后续维护就越容易。 3.是自己的就是自己的如果一个方法可以放在本类中，既不增加类间关系耦合，也对本类没有负面影响，那么不要把该方法放到其他类中，并与之建立联系，请把该方法放置在本类中","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"设计原则-接口隔离原则","slug":"设计原则-接口隔离原则","date":"2019-10-30T07:25:09.000Z","updated":"2019-10-31T12:16:35.442Z","comments":true,"path":"2019/10/30/设计原则-接口隔离原则/","link":"","permalink":"http://blog.cairui99.cn/2019/10/30/设计原则-接口隔离原则/","excerpt":"定义Clients should not be forced to depend upon interfaces that they don’t use. “客户端不应该依赖它不需要的接口”，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。","text":"定义Clients should not be forced to depend upon interfaces that they don’t use. “客户端不应该依赖它不需要的接口”，另一种含义就是客户端应该只依赖它需要的接口，把不需要的接口剔除掉，保证接口的纯洁性，这就是接口隔离原则。 实践实现接口时尽量做到以下规范： 接口要做到高内聚：尽量少的公布public方法，降低变更的风险 定制服务：对于每个独立的模块，只提供给每个访问者它们需要的方法，不暴露出它们不需要的方法 有限度的拆分接口：接口的设计粒度越小，系统越灵活，但也同时带来了系统结构的复杂化，加大开发和维护成本，所以在设计时要适度拆分接口 已经被污染的接口，尽量去修改，如果修改风险较大则用适配器模式进行转化处理 接口的设计没有通用的完美的的方案，请深入了解业务逻辑，自己设计出最适合的接口！","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"顺时针打印矩阵","slug":"算法题-顺时针打印矩阵","date":"2019-10-30T06:11:01.000Z","updated":"2019-11-28T02:33:32.310Z","comments":true,"path":"2019/10/30/算法题-顺时针打印矩阵/","link":"","permalink":"http://blog.cairui99.cn/2019/10/30/算法题-顺时针打印矩阵/","excerpt":"题目输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵 打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10","text":"题目输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如下图矩阵 打印结果为：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 思路大体思想是将矩阵由外到内一圈一圈的打印，直至所有数字都打印完毕，具体思路如下： 在不考虑打印矩阵内圈的情况下，此时只需要两个点的坐标就可以遍历完整的矩阵，我们取左上角的坐标和右下角的坐标,最外圈的矩阵坐标就是(0,0)和(arr.length-1,arr[0].arr.length-1) 完整打印了外圈矩阵后，只需要将左上角的坐标向右下方移动一格、右下角坐标向左上方移动一格，此时就得到了可以打印内圈矩阵的两个坐标 重复执行上述步骤，直至得到的坐标无法构成矩阵为止 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package Code;/** * 顺时针打印矩阵 * @author CaiRui * @time 2019-10-24 */public class ClockwisePrintMatrix &#123; private static void printMatrix(int[][] matrix) &#123; //不是矩阵 if (matrix == null || matrix.length &lt;= 1 || matrix[0].length &lt;= 1) &#123; return; &#125; int[] A = &#123;0, 0&#125;; int[] B = &#123;matrix.length - 1, matrix[0].length -1&#125;; while (B[0] &gt;= A[0] &amp;&amp; B[1] &gt;= A[1]) &#123; print(matrix,A[0]++,A[1]++,B[0]--,B[1]--); &#125; &#125; /** * 左上角坐标(a,b) * 右下角坐标(c,d) */ private static void print(int[][] arr, int a, int b, int c, int d) &#123; // (a, b) -&gt; (a, d) int index = b; while (index &lt; d) &#123; System.out.print(arr[a][index++] + \" \"); &#125; // (a, d) -&gt; (c, d) index = a; while (index &lt; c) &#123; System.out.print(arr[index++][d] + \" \"); &#125; // (c, d) -&gt; (c, b) index = d; while (index &gt; b) &#123; System.out.print(arr[c][index--] + \" \"); &#125; // (c, b) -&gt; (a, b) index = c; while (index &gt; a) &#123; System.out.print(arr[index--][b]+\" \"); &#125; &#125; public static void main(String[] args) &#123; int[][] matrix = &#123; &#123; 1, 2, 3, 4 &#125;, &#123; 5, 6, 7, 8 &#125;, &#123; 9, 10, 11, 12 &#125;, &#123; 13, 14, 15, 16 &#125; &#125;; ClockwisePrintMatrix.printMatrix(matrix); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"栈实现队列&队列实现栈","slug":"算法题-栈实现队列-队列实现栈","date":"2019-10-28T07:02:20.000Z","updated":"2019-11-28T02:34:01.958Z","comments":true,"path":"2019/10/28/算法题-栈实现队列-队列实现栈/","link":"","permalink":"http://blog.cairui99.cn/2019/10/28/算法题-栈实现队列-队列实现栈/","excerpt":"栈实现队列要求使用栈实现队列的如下方法： offer(入队) poll(出队) peek(查看栈顶元素)","text":"栈实现队列要求使用栈实现队列的如下方法： offer(入队) poll(出队) peek(查看栈顶元素) 思路 内部创建两个栈，push栈和pop栈 offer()：push栈正常入栈 poll(): 弹出pop栈的栈顶元素并返回 (当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中) peek(): 返回pop栈的栈顶元素 (当pop栈为空时，首先将push栈里面的所有元素依次弹出并压入pop栈中) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Stack;/** * 栈实现队列 * @author CaiRui * @time 2019-10-24 */public class StackBecomeQueue &#123; private Stack&lt;Integer&gt; push = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; pop = new Stack&lt;&gt;(); public void offer(int num) &#123; push.push(num); &#125; public int poll() &#123; if (!pop.isEmpty()) &#123; return pop.pop(); &#125; if (push.isEmpty()) &#123; throw new ArrayIndexOutOfBoundsException(\"Queue is empty!\"); &#125; this.pushData(); return pop.pop(); &#125; public int peek() &#123; if (!pop.isEmpty()) &#123; return pop.peek(); &#125; if (push.isEmpty()) &#123; throw new ArrayIndexOutOfBoundsException(\"Queue is empty!\"); &#125; this.pushData(); return pop.peek(); &#125; private void pushData() &#123; while (!push.isEmpty()) &#123; pop.push(push.pop()); &#125; &#125;&#125; 队列实现栈结构要求使用队列实现栈结构的如下方法： push(入栈) pop(出栈) peek(查看栈顶元素) 思路 内部创建两个队列，data队列和help队列 push(): data队列正常入队 pop(): 将data队列中前n-1个数依次出队然后进入help队列，然后进行一个指针变换，data队列和help队列互换，互换后help队列仅剩的一个数出队并返回 peek(): 将data队列中全部数依次出队然后进入help队列，注意记录最后一个元素作为返回值，先进行指针互换，然后将记录的值返回 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.LinkedList;import java.util.Queue;/** * 使用队列实现栈结构 * @author CaiRui * @time 2019-10-23 */public class QueueBecomeStack &#123; private Queue&lt;Integer&gt; data = new LinkedList&lt;&gt;(); private Queue&lt;Integer&gt; help = new LinkedList&lt;&gt;(); private int size = 0; /** * 入栈 */ private void push(int num) &#123; size++; data.offer(num); &#125; /** * 栈顶元素出栈 */ private int pop() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException(\"栈为空\"); &#125; for (int i = 0; i &lt; size - 1; i++) &#123; help.offer(data.remove()); &#125; size--; swap(); return help.remove(); &#125; /** * 查看栈顶元素 */ private int peek() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException(\"栈为空\"); &#125; for (int i = 0; i &lt; size -1; i++) &#123; help.offer(data.remove()); &#125; int ret = data.remove(); help.offer(ret); swap(); return ret; &#125; private void swap() &#123; Queue&lt;Integer&gt; temp = data; data = help; help = temp; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"栈","slug":"栈","permalink":"http://blog.cairui99.cn/tags/栈/"},{"name":"队列","slug":"队列","permalink":"http://blog.cairui99.cn/tags/队列/"}]},{"title":"Min栈的实现","slug":"算法题-Min栈的实现","date":"2019-10-28T06:46:05.000Z","updated":"2019-11-28T02:34:19.110Z","comments":true,"path":"2019/10/28/算法题-Min栈的实现/","link":"","permalink":"http://blog.cairui99.cn/2019/10/28/算法题-Min栈的实现/","excerpt":"题目实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求： 1．pop、push、peek、getMin操作的时间复杂度都是O(1)。 2．设计的栈类型可以使用现成的栈结构。","text":"题目实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。要求： 1．pop、push、peek、getMin操作的时间复杂度都是O(1)。 2．设计的栈类型可以使用现成的栈结构。 思路 内部创建两个栈，data栈和min栈 元素num入栈时data栈正常入栈，min栈将自己的栈顶元素和num比较，较小的元素入min栈,做到的感觉是(min栈的栈顶存的永远是data栈中的最小值) 出栈时data栈和min栈一起正常出栈 getMin()方法只需要返回min栈的栈顶元素 代码12345678910111213141516171819202122232425262728293031323334import java.util.Stack;/** * 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。 * 【要求】 1．pop、push、getMin操作的时间复杂度都是O(1)。 * 2．设计的栈类型可以使用现成的栈结构。 * @author CaiRui * @time 2019-10-22 */public class MinStack &#123; private Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; min = new Stack&lt;&gt;(); public int push(int num) &#123; data.push(num); min.push((min.peek() &gt; num) ? num : min.peek()); return num; &#125; public int pop() &#123; min.pop(); return data.pop(); &#125; public int peek() &#123; return data.peek(); &#125; public int getMin() &#123; return min.peek(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"栈","slug":"栈","permalink":"http://blog.cairui99.cn/tags/栈/"}]},{"title":"更快的获取中位数","slug":"算法题-更快的获取中位数","date":"2019-10-28T05:56:44.000Z","updated":"2019-11-28T03:50:24.105Z","comments":true,"path":"2019/10/28/算法题-更快的获取中位数/","link":"","permalink":"http://blog.cairui99.cn/2019/10/28/算法题-更快的获取中位数/","excerpt":"题目一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数","text":"题目一个流不断的吐出无序的数，你可以收集并操作这些数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数 思路这道题，如果只是简单的收集流中吐出的数的话，当别人调获取中位数接口时，这时需要把收集的数进行一次排序，从而获取中位数。 此时收集数的操作是 O(1)，获取中位数的操作是 O(n*logn) 如果接口被频繁调用，排序的代价就太高了，下面利用堆结构的特点来进行优化： 创建一个大根堆和一个小根堆，用来收集流中的数，收集规则如下： 假设一共有n个数，把较大的(2/n)个数放入小根堆中，较小的(2/n)个数放入大根堆中 两个堆中元素数量保持平衡，差值不大于1 如何获取中位数： 如果全部元素个数为奇数，中位数就是两个堆中size较大的那个堆中的堆顶元素 如果全部元素个数为偶数，中位数就是两个堆的堆顶元素的平均值 此时收集数的操作需要进行一次heapInsert 代价是 O(logn)，而获取中位数的操作变为了 O(1)，效率得到了很大的提升 O(logn)的时间复杂度其实是很低的，3千万的数量级logn还不到25，基本上等于O(1)了 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import DataStructure.Heap;/** * 题目：一个流不断的吐出无序的数，要求提供一个接口，可以在任何时刻获取到目前为止流中吐出的所有数的中位数 * @author Cai Rui * @time 2019-10-18 */public class MedianQuick &#123; private int[] bigHeap = new int[100]; private int[] smallHeap = new int[100]; private int bigSize = 0; private int smallSize = 0; public void numberInsert(int number) &#123; if (bigSize == 0) &#123; bigHeap[bigSize++] = number; return; &#125; //是否需要扩容 if (bigSize &gt;= bigHeap.length || smallSize &gt;= smallHeap.length) &#123; this.automaticCapacity(); &#125; if (number &gt; bigHeap[0]) &#123; //较大的数进小根堆 smallHeap[smallSize++] = number; Heap.heapInsert(smallHeap,smallSize-1,1); &#125; else &#123; //较小的数进大根堆 bigHeap[bigSize++] = number; Heap.heapInsert(bigHeap,bigSize-1,0); &#125; //平衡堆中元素数量，差值不等大于1 if (bigSize - smallSize &gt; 1) &#123; smallHeap[smallSize++] = Heap.heapPop(bigHeap,bigSize--,0); Heap.heapInsert(smallHeap,smallSize-1,1); &#125; else if (smallSize - bigSize &gt; 1) &#123; bigHeap[bigSize++] = Heap.heapPop(smallHeap,smallSize--,1); Heap.heapInsert(bigHeap,bigSize-1,0); &#125; &#125; //获取中位数 public double getMedian() &#123; if (bigSize == 0) &#123; return -1; &#125; if (bigSize == smallSize) &#123; return (double)(bigHeap[0] + smallHeap[0])/2; &#125; else if (bigSize &gt; smallSize) &#123; return bigHeap[0]; &#125; else &#123; return smallHeap[0]; &#125; &#125; //自动扩容 private void automaticCapacity() &#123; int[] bigHeap = new int[this.bigHeap.length+100]; int[] smallHeap = new int[this.smallHeap.length+100]; System.arraycopy(this.bigHeap, 0, bigHeap, 0, bigSize); System.arraycopy(this.smallHeap, 0, smallHeap, 0, smallSize); this.bigHeap = bigHeap; this.smallHeap = smallHeap; &#125;&#125; 注：Heap类的相关代码","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"堆","slug":"堆","permalink":"http://blog.cairui99.cn/tags/堆/"}]},{"title":"数组实现队列","slug":"算法题-数组实现队列","date":"2019-10-28T03:39:43.000Z","updated":"2019-11-28T02:33:19.698Z","comments":true,"path":"2019/10/28/算法题-数组实现队列/","link":"","permalink":"http://blog.cairui99.cn/2019/10/28/算法题-数组实现队列/","excerpt":"题目使用数组实现队列结构，实现方法： add(向队尾添加元素) poll(返回队首元素，并移除) peek(返回队首元素)","text":"题目使用数组实现队列结构，实现方法： add(向队尾添加元素) poll(返回队首元素，并移除) peek(返回队首元素) 思路 创建两个指针start、end和一个变量size，初始值都为0 start表示队首元素的位置 end表示下一个元素入队时要添加的位置 size表示队列大小 start和end如果到了数组尾部，则下次移动到数组头部，循环利用数组 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 使用数组实现队列 * @author CaiRui * @time 2019-10-23 */public class ArrayBecomeQueue &#123; private int[] arr; private int start = 0; private int end = 0; private int size = 0; public ArrayBecomeQueue() &#123; arr = new int[50]; &#125; public ArrayBecomeQueue(int initSize) &#123; arr = new int[initSize]; &#125; //添加一个元素到队尾 public boolean add(int num) &#123; if (size == arr.length) &#123; throw new ArrayIndexOutOfBoundsException(\"队列已满\"); &#125; size++; arr[end] = num; end = (end == arr.length - 1) ? 0 : ++end; return true; &#125; //获取队首元素，并移除 public int poll() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException(\"队列为空\"); &#125; size--; int result = arr[start]; start = start == arr.length - 1 ? 0 : ++start; return result; &#125; //获取队首元素 public int peek() &#123; if (size == 0) &#123; throw new ArrayIndexOutOfBoundsException(\"队列为空\"); &#125; return arr[start]; &#125; public static void main(String[] args) &#123; //预计输出：1 1 2 3 3 ArrayBecomeQueue queue = new ArrayBecomeQueue(5); queue.add(1); queue.add(2); queue.add(3); System.out.println(queue.peek()); queue.add(4); System.out.println(queue.poll()); System.out.println(queue.poll()); queue.add(5); queue.add(6); System.out.println(queue.peek()); System.out.println(queue.poll()); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"队列","slug":"队列","permalink":"http://blog.cairui99.cn/tags/队列/"}]},{"title":"相邻两数最大差值","slug":"算法题-相邻两数最大差值","date":"2019-10-22T06:08:22.000Z","updated":"2019-11-28T02:33:38.810Z","comments":true,"path":"2019/10/22/算法题-相邻两数最大差值/","link":"","permalink":"http://blog.cairui99.cn/2019/10/22/算法题-相邻两数最大差值/","excerpt":"题目描述给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n)","text":"题目描述给定一个无序数组，求如果数组排好序后，相邻两数的最大差值，要求时间复杂度O(n) 举个例子： 给定数组：{4,5,1,2} 排好序后的数组是：{1,2,4,5} 相邻两数的差值分别为：1,2,1 需要返回最大差值，所以最终结果就是2 暴力解法先把数组排序，再遍历数组求出所有差值，返回最大的那一个 123456789101112131415//暴力解法 O(n*logn)private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result;&#125; 由于基于比较的排序时间复杂度最快也需要O(n*logn)，而题中要求时间复杂度达到O(n),所以此暴力解法是无法通过的，这里暴力解法仅用来给下面的标准解法验证正确性使用 标准解法这里利用了桶的概念，但没有进行桶排序 思路： 假设数组中有N个数，创建N+1个桶 遍历数组，找出最小值min和最大值max，最小值进第一个桶，最大值进最后一个桶 然后将(max-min)分为(N+1)份，也就是在这N+1个桶中，每个桶都有它对应的数组范围，然后遍历数组，将每个数放进它对应的桶中 (例：数组中4个数，最小值0，最大值5，则创建5个桶，首先将0放入1号桶，5放入5号桶，之后划分范围：1号桶的范围是0 ~ 1,2号桶1 ~ 2,3号桶2 ~ 3,4号桶3 ~ 4,5号桶4 ~ 5) 这里解释下为什么创建N+1个桶：目的是让元素全部入桶后至少还存在一个空桶，以此来保证 产生最大差值的两个相邻数绝对不会来自于相同桶 有了这个特性，我们就只需要比较不同桶之间相邻数的差值，而不需要比较相同桶中的相邻数了 所以在每个桶中只需要存储桶中所有元素的最大值与最小值，比较差值时比较的是 相邻非空桶(中间隔着空桶也算相邻)之间相邻元素的差值，差值就是(后方桶的最小值-前方桶的最大值)因为这两个数一定是相邻的 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 题目：给定一个无序数组，求如果排序之后，相邻两数的最大差值 * @author CaiRui * @time 2019-10-21 */public class BorderCount &#123; //O(n) private static int getBorderCount(int[] arr) &#123; //过滤非法数据 if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; //借用桶的概念，假设数组中有n个数则创建n+1个桶，目的是元素全部入桶后至少存在一个非空桶，以此来保证最大差值绝对不来自于相同桶 int[] min = new int[arr.length+1]; int[] max = new int[arr.length+1]; //记录桶是否为空 boolean[] existNumber = new boolean[arr.length+1]; //最小值和最大值相等：返回0 HashMap&lt;String,Integer&gt; criticalMap = getMaxAndMin(arr); int minNum = criticalMap.get(\"Min\"); int maxNum = criticalMap.get(\"Max\"); if (minNum == maxNum) &#123; return 0; &#125; //最小值放在第一个桶，最大值放在最后一个桶 min[0] = minNum; max[0] = minNum; existNumber[0] = true; min[min.length-1] = maxNum; max[max.length-1] = maxNum; existNumber[existNumber.length-1] = true; //每个桶中存放的数值范围 double scope = (double) (min[min.length-1] - min[0])/min.length; //元素入桶 for (int num : arr) &#123; if (num == min[0] || num == max[max.length - 1]) &#123; continue; &#125; //该元素应该存放的下标 int index = (int) Math.ceil((num - min[0]) / scope)-1; if (!existNumber[index]) &#123; min[index] = num; max[index] = num; existNumber[index] = true; &#125; else &#123; if (num &gt; max[index]) &#123; max[index] = num; &#125; else if (num &lt; min[index]) &#123; min[index] = num; &#125; &#125; &#125; //记录非空桶的坐标 List&lt;Integer&gt; existIndex = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; existNumber.length;i++) &#123; if (existNumber[i]) &#123; existIndex.add(i); &#125; &#125; //计算最大差值 int maxBorderCount = max[0] - min[0]; for (int i = 0;i &lt; existIndex.size() - 1;i++) &#123; int border = min[existIndex.get(i+1)] - max[existIndex.get(i)]; if (border &gt; maxBorderCount) &#123; maxBorderCount = border; &#125; &#125; return maxBorderCount; &#125; //获取最大值和最小值 private static HashMap&lt;String,Integer&gt; getMaxAndMin(int[] arr) &#123; HashMap&lt;String,Integer&gt; result = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int num : arr) &#123; max = Math.max(max,num); min = Math.min(min,num); &#125; result.put(\"Max\",max); result.put(\"Min\",min); return result; &#125; //暴力解法 O(n*logn) private static int testMethod(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return -1; &#125; Arrays.sort(arr); int result = arr[1] - arr[0]; for (int i = 0; i &lt; arr.length-1;i++) &#123; int border = arr[i+1] - arr[i]; if (border &gt; result) &#123; result = border; &#125; &#125; return result; &#125; public static void main(String[] args) &#123; int testCount = 10000; boolean is_success = true; for (int i = 0;i &lt; testCount;i++) &#123; int[] arr = ArrayUtil.getArray(10,0,20); int[] arr1 = ArrayUtil.copyArray(arr); int[] arr2 = ArrayUtil.copyArray(arr); int border1 = BorderCount.getBorderCount(arr1); int border2 = BorderCount.testMethod(arr2); if (border1 != border2) &#123; is_success = false; break; &#125; &#125; if (is_success) &#123; System.out.println(\"Success\"); &#125; else &#123; System.out.println(\"Fail\"); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"堆排序","slug":"排序算法-堆排序","date":"2019-10-18T02:38:03.000Z","updated":"2019-10-28T03:31:12.890Z","comments":true,"path":"2019/10/18/排序算法-堆排序/","link":"","permalink":"http://blog.cairui99.cn/2019/10/18/排序算法-堆排序/","excerpt":"堆排序堆排序是利用堆结构的特点来设计的一种排序算法。","text":"堆排序堆排序是利用堆结构的特点来设计的一种排序算法。 思路 首先将整个数组构建成大根堆 依次将堆顶元素弹出，转移到堆中最后一个元素后面的位置 在弹出过程中，假设数组长度为l，堆的大小为n，则数组中(0~n)为堆结构，((n+1) ~ l)为一段有序数组 当堆中所有元素弹出完毕，此时数组已全部有序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 堆排序 * @author Cai Rui * @time 2019-10-17 */public class HeapSort &#123; public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; Heap.buildBigHeap(arr,arr.length,0); for (int i = 0;i &lt; arr.length;i++) &#123; Heap.heapPop(arr,arr.length-i,0); &#125; &#125;&#125;/** * 堆结构 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param length 堆的大小 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int length,int heapType)&#123; if (arr == null || length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType)&#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; ArrayUtil.swap(arr,0,length-1); heapFalling(arr,length-2,heapType); return result; &#125; /** * 向堆中添加一个元素 * @param arr 数组中(0 ~ index-1)为堆结构 * @param index 元素下标 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void heapInsert(int[] arr,int index,int heapType)&#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; ArrayUtil.swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType)&#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; ArrayUtil.swap(arr,index,leftChild); index = leftChild; &#125; else &#123; ArrayUtil.swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n*logn); 平均时间复杂度: O(n*logn) 空间复杂度: O(1) 稳定性分析不稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"数据结构-堆","slug":"数据结构-堆","date":"2019-10-16T09:34:42.000Z","updated":"2020-04-26T09:57:54.115Z","comments":true,"path":"2019/10/16/数据结构-堆/","link":"","permalink":"http://blog.cairui99.cn/2019/10/16/数据结构-堆/","excerpt":"堆堆(Heap)是计算机科学中一类特殊的数据结构的统称，堆通常是一个可以被看做一棵完全二叉树的数组对象。","text":"堆堆(Heap)是计算机科学中一类特殊的数据结构的统称，堆通常是一个可以被看做一棵完全二叉树的数组对象。 完全二叉树首先堆的结构是一颗 完全二叉树 完全二叉树：如果二叉树的深度为k，则除第k层外其余所有层节点的度都为2，且叶子节点从左到右依次存在。也即是，将满二叉树的最后一层从左到右依次删除若干节点就得到完全二叉树。结构如下图： 在程序中，我们可以使用数组结构来抽象出一颗完全二叉树： 数组中的0位置代表根节点 假设父节点在数组中的坐标为i，那么该节点左右孩子在数组中的的坐标为： 左孩子：2*i+1 右孩子：2*i+2 假设某子节点在数组中的坐标为i，那么该节点的父节点在数组中的坐标为： 父节点：(i-1)/2 根节点的父节点是自己：(0-1)/2 = 0 使用上面的抽象规则，我们就可以把 任意数组抽象为一颗完全二叉树。 构建推结构堆分为两种： 大根堆：在一颗完全二叉树中，任何一颗子树的 最大值 都是头部 小根堆：在一颗完全二叉树中，任何一颗子树的 最小值 都是头部 以大根堆为例，下面给出一个无序数组，如何将数组构建成大根堆？ 步骤： 首先默认在堆中只有一个根节点，也就是数组中只有第一个数在堆中 后面通过遍历数组，将每个元素依次进堆 进堆步骤：将该元素与父节点比较，如果比父节点大则与父节点进行交换，直至该元素比父节点小或者该元素已经移动至根节点为止 数组中所有元素进堆完毕，则大根堆构建完成 时间复杂度：O(n) 弹出堆顶元素在堆中弹出堆顶元素是常用操作，可以用来获取堆中的最大/小值，弹出操作的关键在于缺少了堆顶元素后如何将堆中剩下的元素快速重建，便于下次弹出时依旧是最大/小值。 步骤： 将堆顶元素与堆中最后一个元素交换，堆长度减一，此时弹出的元素已经不在堆中 对此时的堆顶元素进行下沉操作，直至无须下沉或者无法下沉(下沉到叶子节点时无法下沉) 下沉：当前元素如果不是叶子节点，则将它和它的左孩子和右孩子(如果没有右孩子就不比较，但一定有左孩子) 大小进行比较，当前元素如果不是最大的，则将最大的元素和当前元素交换位置，完成一次下沉 堆顶元素下沉完毕后，此时又重新构建好了堆结构 时间复杂度：O(logn) 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * 堆 * @author Cai Rui * @time 2019-10-17 */public class Heap &#123; /** * 将数组建立为堆结构 * @param arr 待处理数组 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 */ public static void buildBigHeap(int[] arr,int heapType) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 1;i &lt; arr.length;i++) &#123; heapInsert(arr,i,heapType); &#125; &#125; /** * 弹出堆顶元素 * @param arr int[] * @param length 堆在数组中的长度 * @param heapType 0-&gt;大根堆 , 1-&gt;小根堆 * @return 弹出的堆顶元素 */ public static int heapPop(int[] arr,int length,int heapType) &#123; if(arr == null || arr.length == 0) &#123; return -1; &#125; int result = arr[0]; swap(arr,0,length); heapFalling(arr,length-1,heapType); return result; &#125; private static void heapInsert(int[] arr,int index,int heapType) &#123; while (true) &#123; int father = (index-1)/2; if ((arr[index] &lt;= arr[father] &amp;&amp; heapType == 0) || (arr[index] &gt;= arr[father]) &amp;&amp; heapType == 1) break; swap(arr,index,father); index = father; &#125; &#125; private static void heapFalling(int[] arr,int length,int heapType) &#123; int index = 0; while (true) &#123; int leftChild = 2*index+1; int rightChild = 2*index+2; //已经在叶子节点了，直接返回 if (leftChild &gt; length) break; //没有右孩子 if (rightChild &gt; length) &#123; if ((arr[index] &lt; arr[leftChild] &amp;&amp; heapType == 0) || (arr[index] &gt; arr[leftChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; continue; &#125; else &#123; break; &#125; &#125; //有左右孩子，先判断是否需要下沉 if (((arr[index] &lt; arr[leftChild] || arr[index] &lt; arr[rightChild]) &amp;&amp; heapType == 0) || ((arr[index] &gt; arr[leftChild] || arr[index] &gt; arr[rightChild]) &amp;&amp; heapType == 1)) &#123; //再判断与哪个孩子交换 if ((arr[leftChild] &gt;= arr[rightChild] &amp;&amp; heapType == 0) || (arr[leftChild] &lt;= arr[rightChild] &amp;&amp; heapType == 1)) &#123; swap(arr,index,leftChild); index = leftChild; &#125; else &#123; swap(arr,index,rightChild); index = rightChild; &#125; &#125; else &#123; break; &#125; &#125; &#125; private static void swap(int[] arr,int a,int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; public static void main(String[] args) &#123; int[] arr = &#123;5,1,4,5,8,2,5,6,54,9,7,5,2,0&#125;; Heap.buildBigHeap(arr,1); ArrayUtil.printArray(arr); int min = Heap.heapPop(arr,arr.length-1,1); System.out.println(min); ArrayUtil.printArray(arr); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.cairui99.cn/tags/数据结构/"}]},{"title":"快速排序","slug":"排序算法-快速排序","date":"2019-10-12T07:04:19.000Z","updated":"2019-10-28T08:28:55.366Z","comments":true,"path":"2019/10/12/排序算法-快速排序/","link":"","permalink":"http://blog.cairui99.cn/2019/10/12/排序算法-快速排序/","excerpt":"快速排序快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。","text":"快速排序快排的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 思路 选取数组中的中的一个数作为基准数，然后将数组调整为两部分：左部分的数全部小于等于基准数、右部分的数全部大于基准数(子序列中内部不需要有序) 递归的对数组两个部分继续执行上述步骤，直至数组有序 改进 将数组划分为三个部分，小于、等于、大于区域 (具体实现) 这时等于区域的数就已经位于理想的位置，因此只需要递归小于区域和大于区域 (在有很多重复数字的情况下效率提升会很明显) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 快速排序 * @author cairui * @time 2019-10-11 */public class QuickSort &#123; public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr, 0, arr.length-1); &#125; //递归函数 private static void quickSort(int[] arr,int left,int right) &#123; if (left &gt;= right) &#123; return; &#125; int[] index = grouping(arr,left,right); //递归小于区域和大于区域 quickSort(arr,left,index[0]); quickSort(arr,index[1],right); &#125; //划分出小于、等于、大于区域 private static int[] grouping(int[] arr, int left, int right) &#123; int indexFront = left; int indexMid = left; int indexRear = right; int num = arr[right]; while (true) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr, indexMid, indexFront); if (indexMid + 1 &gt; indexRear) break; indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; if (indexMid + 1 &gt; indexRear) break; indexMid++; &#125; else &#123; if (indexMid &gt; indexRear - 1) break; swap(arr, indexMid, indexRear); indexRear--; &#125; &#125; //返回临界值坐标 int[] index = new int[2]; index[0] = (arr[indexFront] == num) ? (indexFront - 1) : indexFront; index[1] = (arr[indexRear] == num) ? (indexRear + 1) : indexRear; return index; &#125; private static void swap(int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ; 最差时间复杂度: O(n2); (快排在最差情况下会退化为冒泡) 平均时间复杂度: O(n*logn) 空间复杂度: O(logn) 稳定性分析不稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"Hexo-向git推送更新失败","slug":"Hexo-向git推送更新失败","date":"2019-10-11T09:31:12.000Z","updated":"2019-10-12T06:29:04.616Z","comments":true,"path":"2019/10/11/Hexo-向git推送更新失败/","link":"","permalink":"http://blog.cairui99.cn/2019/10/11/Hexo-向git推送更新失败/","excerpt":"今天在更新博客时发生了 hexo d 时推送失败的情况。 报错信息: 12Connection reset by 52.74.223.119 port 22fatal: Could not read from remote repository.","text":"今天在更新博客时发生了 hexo d 时推送失败的情况。 报错信息: 12Connection reset by 52.74.223.119 port 22fatal: Could not read from remote repository. 这表示git客户端无法连接至github，原因大概是防火墙禁止了ip为52.74.223.119端口22的ssh连接 解决方法： (1) 我的解决的方法是切换网络，将wifi切成手机热点就提交成功了。 (2) 如果条件不允许或者切换网络依旧不成功，需要手动将防火墙中的 22端口设置为允许连接 具体操作请参考","categories":[{"name":"问题整理","slug":"问题整理","permalink":"http://blog.cairui99.cn/categories/问题整理/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.cairui99.cn/tags/Hexo/"}]},{"title":"荷兰国旗问题","slug":"算法题-荷兰国旗问题","date":"2019-10-11T06:44:37.000Z","updated":"2019-11-28T02:33:01.934Z","comments":true,"path":"2019/10/11/算法题-荷兰国旗问题/","link":"","permalink":"http://blog.cairui99.cn/2019/10/11/算法题-荷兰国旗问题/","excerpt":"题目给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。","text":"题目给定一个数组arr和一个数num,要求调整数组，把小于num的数放在数组左边，等于num的数放在数组中间，大于num的数放在数组右边。 常见思路常见思路为使用三个辅助数组，分别存储小于、等于和大于num的数，最后再依次赋值给原数组。 代码： 1234567891011121314151617181920212223242526//常见思路 时间复杂度(n) 空间复杂度O(n)private static void badMethod(@NotNull int[] arr, int num)&#123; int index = 0; List&lt;Integer&gt; alist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; blist = new ArrayList&lt;&gt;(); List&lt;Integer&gt; clist = new ArrayList&lt;&gt;(); for (int n : arr) &#123; if (n&lt;num) &#123; alist.add(n); &#125; else if (n==num) &#123; blist.add(n); &#125; else &#123; clist.add(n); &#125; &#125; index = setArray(arr,index,alist); index = setArray(arr,index,blist); setArray(arr,index,clist);&#125;private static int setArray(int[] arr, int index, @NotNull List&lt;Integer&gt; list)&#123; for (Integer integer : list) &#123; arr[index++] = integer; &#125; return index;&#125; 改进上面的算法空间、时间复杂度都为O(n)，下面把空间复杂度优化为O(1)的等级： 123456789101112131415161718192021222324//空间复杂度改进为O(1)的方法private static void dutchFlag(@NotNull int[] arr, int num)&#123; int indexFront = 0; int indexMid = 0; int indexRear = arr.length-1; while (indexMid &lt;= indexRear) &#123; if (arr[indexMid] &lt; num) &#123; swap(arr,indexMid,indexFront); indexMid++; indexFront++; &#125; else if (arr[indexMid] == num) &#123; indexMid++; &#125; else &#123; swap(arr,indexMid,indexRear); indexRear--; &#125; &#125;&#125;private static void swap(@NotNull int[] arr, int x, int y)&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp;&#125; 使用三个指针，交换全部在数组内部进行，三个指针的含义为： indexFront : 指针前面的所有数都满足小于num indexMid : 指针前面所有的数都满足小于等于num indexRear : 指针后面所有的数都满足大于num 终止条件为indexMid&gt;indexRear，当两个指针相遇时，代表数组中所有的数已经处于正确的位置","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"IDEA-批量修改变量名","slug":"IDEA-批量修改变量名","date":"2019-10-11T05:44:15.000Z","updated":"2019-11-27T08:22:16.411Z","comments":true,"path":"2019/10/11/IDEA-批量修改变量名/","link":"","permalink":"http://blog.cairui99.cn/2019/10/11/IDEA-批量修改变量名/","excerpt":"","text":"双击选中修改对象后： Shift+F6 变量名填写完成后按回车执行修改","categories":[{"name":"操作","slug":"操作","permalink":"http://blog.cairui99.cn/categories/操作/"}],"tags":[{"name":"IDEA快捷键","slug":"IDEA快捷键","permalink":"http://blog.cairui99.cn/tags/IDEA快捷键/"}]},{"title":"小和问题","slug":"算法题-小和问题","date":"2019-09-27T07:35:43.000Z","updated":"2019-11-28T02:33:43.051Z","comments":true,"path":"2019/09/27/算法题-小和问题/","link":"","permalink":"http://blog.cairui99.cn/2019/09/27/算法题-小和问题/","excerpt":"题目在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。 现在给出一个数组请求出数组的小和。","text":"题目在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。 现在给出一个数组请求出数组的小和。 例子数组：[1,3,4,2,5] 1左边比1小的数，没有； 3左边比3小的数，1； 4左边比4小的数，1、3； 2左边比2小的数，1； 5左边比5小的数，1、3、4、2； 所以小和为1+1+3+1+1+3+4+2=16 常见思路常见思路：遍历数组，计算每一个元素前面比它小的数相加并返回。 12345678910//常见思路,O(n2)的方法int badMethod(int[] arr)&#123; int smallSum = 0; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i-1;j&gt;=0;j--)&#123; if(arr[i]&gt;arr[j]) smallSum += arr[j]; &#125; &#125; return smallSum;&#125; 但这样的方法虽然好想、好写，但O(n2)的时间复杂度有些太高了，需要改进 改进在归并排序的基础上进行改进，在merge左右两个有序数组时候，如果左边的数小于右边的数，说明当前左边的这个数是右边数组中所有元素的小和，此时进行累加小和，累加的小和为(当前小和+左边第一个数*右边数组剩余元素的个数)。 1234567891011121314151617181920212223242526272829303132333435363738394041//利用分治思想,O(n*logn)的方法private static int getSmallSum(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return 0; &#125; return getSmallSum(arr,0,arr.length-1);&#125;//递归private static int getSmallSum(int[] arr, int left, int right)&#123; if(left&gt;=right)&#123; return 0; &#125; int mid = left - (left-right)/2; return getSmallSum(arr,left,mid) + getSmallSum(arr,mid+1,right) + merge(arr,left,mid,right);&#125;private static int merge(int[] arr,int left,int mid,int right)&#123; int smallSum = 0; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; //左边数比右边数小,累加小和(小和为当前左边的数*右边待排序的个数) smallSum += (arr[index_left] &lt; arr[index_right]) ? (right-index_right+1) * arr[index_left] : 0; merge_arr[index_merge++] = (arr[index_left] &gt;= arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); return smallSum;&#125; 此时算法的时间复杂度就提升到了O(n*logn)的级别","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://blog.cairui99.cn/tags/算法题/"},{"name":"数组","slug":"数组","permalink":"http://blog.cairui99.cn/tags/数组/"}]},{"title":"归并排序","slug":"排序算法-归并排序","date":"2019-09-26T08:00:54.000Z","updated":"2019-10-08T08:47:00.549Z","comments":true,"path":"2019/09/26/排序算法-归并排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/26/排序算法-归并排序/","excerpt":"归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。","text":"归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。 思路 将数组分解为各含n/2个元素的子数组，递归的拆分数组，当子数组长度为1时，默认子数组是就有序的 将两个有序的数组通过外排合并为一个有序的数组 当全部子数组合并完成时，原数组变为有序 图解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 归并排序 * author:Cai Rui * date:2019-09-27 */class MergeSort &#123; static void mergeSort(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return; &#125; mergeSort(arr,0,arr.length-1); &#125; //递归 private static void mergeSort(int[] arr,int left,int right)&#123; if(left&gt;=right)&#123; return; &#125; int mid = left - (left-right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); merge(arr,left,mid,right); &#125; private static void merge(int[] arr,int left,int mid,int right)&#123; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; merge_arr[index_merge++] = (arr[index_left] &gt; arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ;最差时间复杂度: O(n*logn) ;平均时间复杂度: O(n*logn) 空间复杂度: O(n) 稳定性分析稳定(在外排过程中，当遇到相等元素先存左边的数，就可以保证排序结果是稳定的)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"依赖倒置原则","slug":"设计原则-依赖倒置原则","date":"2019-09-24T11:11:34.000Z","updated":"2019-10-08T08:46:58.297Z","comments":true,"path":"2019/09/24/设计原则-依赖倒置原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/24/设计原则-依赖倒置原则/","excerpt":"依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD.","text":"依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD. 定义High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 翻译过来就是： 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 每一个逻辑的具体实现就是低层模块(一般指方法)，各种逻辑的组装就是高层模块。 抽象是指接口或者抽象类，属于不能被示例化的；细节就是可以被实例化的实现类，一般指实现接口或继承抽象类的类。 依赖倒置原则在开发过程中的体现就是： 模块间的依赖通过抽象发生，实现类之间不直接发生依赖，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 应用看一个应用到依赖倒置原则的例子： 下图是在不使用依赖倒置原则的情况下，奔驰车和驾车司机的类图设计：奔驰车中提供run方法，表示车辆运行： 12345public class Benz &#123; public void run()&#123; System.out.println(\"奔驰汽车开始运行...\"); &#125;&#125; 司机通过调用奔驰车的run方法来驾驶奔驰车： 12345public class Driver &#123; public void drive(Benz benz)&#123; benz.run(); &#125;&#125; 司机驾驶奔驰汽车的场景如下： 1234567public class Client &#123; public static void main(String[] args) &#123; Driver driver = new Driver(); Benz benz = new Benz(); driver.drive(benz); &#125;&#125; 以上代码实现了司机开动奔驰车的功能，目前为止程序的功能没有任何问题。 此时如果我们现在不仅有奔驰车，又添加了一辆宝马车，代码如下： 12345public class BMW &#123; public void run()&#123; System.out.println(\"宝马汽车开始运行...\"); &#125;&#125; 有了宝马车之后，我们发现司机竟然没有办法把宝马车开动起来，这是因为目前的司机和奔驰车是紧耦合的关系，要想让司机开动奔驰车就必须修改司机类的代码，被依赖者的变更竟然需要依赖者来承担修改的代价，可见上面的程序稳定性和可维护性都是非常差的 在比较大一些项目开发中，团队中每个人都会负责不同的模块，这里假设这个项目的团队中甲负责汽车类的维护，乙负责司机类的维护，如果按照上面的思路开发，那么在甲开发完成之前乙是不能编写drive方法，因为缺少汽车类，所以此时团队的开发工作是无法做到并行开发的，这严重影响了项目的开发效率 为了解决以上问题，对该项目引入依赖倒置原则后的类图如图所示： 列出采用依赖倒置原则的三种写法： (1)构造函数传入依赖对象 12345678910111213public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public Driver(ICar _car)&#123; this.car = _car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 通过构造函数来设置驾驶汽车的类型 (2)set方法传递依赖对象 1234567891011121314public interface IDriver &#123; public void setCar(ICar car); public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 在执行drive方法之前通过setCar方法来指定汽车的类型 (3)接口声明依赖对象 12345678910111213141516171819202122232425public interface IDriver &#123; public void drive(ICar car);&#125;public class Driver implements IDriver&#123; public void drive(ICar car)&#123; car.run(); &#125;&#125;public interface ICar &#123; public void run();&#125;public class Benz implements ICar&#123; public void run()&#123; System.out.println(\"奔驰汽车开始运行...\"); &#125;&#125;public class BMW implements ICar&#123; public void run()&#123; System.out.println(\"宝马汽车开始运行...\"); &#125;&#125; 业务场景实现： 1234567public class Client &#123; public static void main(String[] args) &#123; IDriver zhangSan = new Driver(); ICar benz = new Benz(); zhangSan.drive(benz); &#125;&#125; 小结为什么是依赖“倒置”：以正常人的思维方式，类之间的依赖关系是实现类之间的依赖，例如司机要开奔驰车，就直接依赖奔驰车，这种就属于“正置”；在编写程序中我们要做到的是对现实世界的事物进行抽象，来实现扩展性和维护性更高的代码，抽象就是抽象类和接口，让我们的的系统产生对抽象的依赖，代替正常人们传统的思维方式(对事物的依赖)，这就是“倒置”的含义 采用依赖倒置原则带来的好处： 减少类间的耦合性 提高系统的稳定性 降低并行开发的风险 提高代码的可读性和可维护性 在项目开发中应遵循： 实体类尽量有接口或抽象类：有抽象才能进行依赖倒置 变量的表面类型尽量是接口或抽象类 不要从具体类中派生出子类 尽量不重写父类的方法：对依赖的稳定性会有影响 采用依赖倒置原则的优势在小型项目中很难体现，一般适用于大中型项目，让项目在后续的扩展和维护中更加方便快捷稳定。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"插入排序","slug":"排序算法-插入排序","date":"2019-09-24T06:59:35.000Z","updated":"2019-10-08T08:46:59.810Z","comments":true,"path":"2019/09/24/排序算法-插入排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/24/排序算法-插入排序/","excerpt":"插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少","text":"插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少 思路 第一个数默认已经排好序 从第二数开始，依次和前面的数比较，遇到比自己大的就交换，遇到比自己小的或者已经到了数组头部时停止(相当于把自己插入到了正确的位置，比自己大的数往后挪了一位) 遍历数组，重复以上步骤 图解 代码12345678910111213141516171819202122public class InsertSort &#123; //插入排序 public static void insertSort(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&gt;arr[j-1])&#123; break; &#125; swap(arr,j,j-1); &#125; &#125; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"选择排序","slug":"排序算法-选择排序","date":"2019-09-23T08:59:29.000Z","updated":"2019-10-08T08:46:59.071Z","comments":true,"path":"2019/09/23/排序算法-选择排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/23/排序算法-选择排序/","excerpt":"选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2)","text":"选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2) 思路 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾 以此类推，直到全部待排序的数据元素的个数为零 图解 代码12345678910111213141516171819202122public class SelectSort &#123; //选择排序 public static int[] selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; int min_index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; min_index = arr[j]&lt;arr[min_index] ? j : min_index; &#125; swap(arr,i,min_index); &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n2) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析举例： 排序前：3(1号) , 3(2号) , 1 排序后：1 , 3(2号) , 3(1号) 不稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"对数器","slug":"对数器","date":"2019-09-20T07:04:04.000Z","updated":"2019-11-29T03:51:40.918Z","comments":true,"path":"2019/09/20/对数器/","link":"","permalink":"http://blog.cairui99.cn/2019/09/20/对数器/","excerpt":"对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。","text":"对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。 下面一个例子，是利用系统已有的排序函数(绝对正确的方法)来验证我自己写的排序函数mySort(正确性未知的,我们要验证的方法)的正确性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.Arrays;public class SortTest &#123; /** * 获取一个随机数组 * @param length 数组最大长度,最小为0 * @param min 最小值 * @param max 最大值 */ private static int[] getArray(int length,int min,int max)&#123; int[] arr = new int[(int)(0+Math.random()*(length+1))]; for(int i=0;i&lt;length;i++)&#123; arr[i] = (int)(min+Math.random()*(max-min+1)); &#125; return arr; &#125; //复制数组 private static int[] copyArray(int[] arr)&#123; int[] result = new int[arr.length]; for(int i=0;i&lt;arr.length;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; //比较两个数组是否相等 private static boolean isEqualsArray(int[] arr1,int[] arr2)&#123; if(arr1.length!=arr2.length)&#123; return false; &#125; for(int i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; return false; &#125; &#125; return true; &#125; //输出数组 private static void printArray(int[] arr)&#123; for(int num : arr)&#123; System.out.print(num+\" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; boolean is_right = true; int[] fail_array = new int[10]; //测试次数 int test_num = 100000; for(int i=0;i&lt;test_num;i++)&#123; //生成一个长度为 0~10，值为 1~20之间的随机数组,并生成两个复制来进行排序 int[] arr = SortTest.getArray(10, 1, 20); int[] arrA = SortTest.copyArray(arr1); int[] arrB = SortTest.copyArray(arr1); //执行排序 Arrays.sort(arrA); MySort.mySort(arrB); //比较结果是否相等 if(!SortTest.isEqualsArray(arrA, arrB))&#123; is_right = false; fail_array = arr; break; &#125; &#125; if(is_right)&#123; System.out.println(\"Success!\"); &#125;else&#123; System.out.println(\"Fail!\"); System.out.println(); System.out.print(\"Fail Array:\"); SortTest.printArray(fail_array); &#125; &#125;&#125; 校验mySort步骤： 生成一个长度随机，值也随机的数组 获取两个刚刚随机生成的数组的复制，分别用正确的sort方法和待验证的mysort方法进行排序 比较排好序的两个数组是否相等 若不相等则说明算法是错的，把排序失败的数组打印出来，方便排查问题出在哪 相等则说明该条测试用例可以通过，继续重复以上步骤，我这里重复了10万次，当然次数越多越好，这样几乎可以涵盖所有的可能，可以说明该算法是正确的 对数器的好处在于测试用例不再需要自己设计了，通过随机生成的庞大样本量，就可以保证算法的正确性，自己想测试用例的话总会出现情况考虑不全的时候，到时程序出bug的话就得不偿失了。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[]},{"title":"里氏替换原则","slug":"设计原则-里氏替换原则","date":"2019-09-19T03:07:34.000Z","updated":"2019-10-08T08:46:55.593Z","comments":true,"path":"2019/09/19/设计原则-里氏替换原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/19/设计原则-里氏替换原则/","excerpt":"在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。","text":"在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。 定义那什么是里氏替换原则呢？它有两种定义： 第一种：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为什么发生变化，那么类型S是类型T的子类型) 第二种：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明的使用其子类的对象) 第一种是比较官方、正宗的定义，不是很好理解，感觉像是高数里面的某种概念。我们看第二种，第二种是定义是比较清晰的，解释一下就是：所有可以使用父类的地方，把父类替换为子类后，程序运行时不会体现出任何的异常，使用者甚至不需要关心使用的是父类和子类。 但反过来就未必可以，使用子类的地方换成父类就不能保证程序不会出错，因为子类可以有父类没有的属性和方法。 继承的使用规范知道了什么是里氏替换原则，那么具体应该怎么做呢？ (1)子类必须完全实现父类的方法： 如果子类不能完整的实现父类的方法，或者父类的方法不适合该子类，这种情况下继承带来的效果就属于弊大于利，因为子类无法完整地实现父类的业务，此时建议解除继承关系，采用依赖、聚集、组合等关系代替来继承。 (2)覆盖或实现父类的方法时输入参数可以被放大，不可以被缩小： 例如： 123456789101112131415public class Father &#123; public void doSomething(HashMap map)&#123; System.out.println(\"父类被执行\"); &#125;&#125;public class Son extends Father &#123; public void doSomething(Map map)&#123; System.out.println(\"子类被执行\"); &#125;&#125; 子类实现了一个和父类同名的方法，虽然方法名相同，但方法的输入参数不同，这样的方式就保证了子类对父类的方法进行了 重载 而非 重写 ，看具体的场景： 1234567891011public class Client &#123; public static void main(String[] args) &#123; Father f = new Father(); Son s = new Son(); HashMap hashmap = new HashMap(); f.doSomething(hashmap); s.doSomething(hashmap); &#125;&#125; 执行结果： 12父类被执行父类被执行 可以看到我们把调用父类的地方换成了子类，结果依然调用了父类的方法，对程序和业务逻辑没有造成影响，这样就符合了里氏替换原则。 如果子类的参数范围缩小的话，在引用里氏替换原则后执行结果就会变为 子类被执行，这样就会引起物业逻辑混乱，因为父类已经抽象好了方法，而子类“曲解”了父类的意图。 所以子类的覆写父类的方法时，只能让输入参数的范围扩大或相同，不能缩小。 (3)重写父类的方法时输出结果可以被缩小，不能扩大 小结采用里氏替换原则的目的就是增强程序的健壮性，在版本升级时也可以保持非常好的兼容性。保证即使增加子类，原有的子类也可以正常运行。在实际项目中每个子类在同的业务中，使用父类作为参数来实现不同的业务逻辑。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"浅谈继承的特点","slug":"浅谈继承的特点","date":"2019-09-18T06:16:36.000Z","updated":"2019-09-18T07:38:59.489Z","comments":true,"path":"2019/09/18/浅谈继承的特点/","link":"","permalink":"http://blog.cairui99.cn/2019/09/18/浅谈继承的特点/","excerpt":"继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。","text":"继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。 特点： 子类继承后自动拥有父类所有的非private属性和方法,父类的构造方法无法被继承 子类可以拥有自己的属性和方法 子类可以重写从父类继承过来的方法，但方法的访问权限只能扩大或不变，不能缩小(public&gt;protect&gt;(默认)&gt;private) 当创建一个子类对象时，会先调用父类的构造方法，再调用子类的构造方法 被关键字final修饰的类无法被继承 支持向下转型，例如：123//通过父类创建子类Person person = new Teacher();Teacher teacher = (Teacher)p; 优点： 提高代码的复用性，减少工作量 提高代码的可读性，让层次更清晰 提高代码的易维护性：所有子类共用父类的方法，方法变更时只需修改父类一处 提高代码的拓展性：子类可实现特有的方法 缺点： 继承是侵入的，只要继承，子类就必须拥有父类的所有非私有的属性和方法 继承是高耦合的形式：当父类修改方法时，需要考虑对所有子类的影响，如果有子类重写了该方法，可能会造成非常严重的后果","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.cairui99.cn/tags/基础知识/"}]},{"title":"冒泡排序","slug":"排序算法-冒泡排序","date":"2019-09-17T03:45:02.000Z","updated":"2019-10-08T08:47:01.173Z","comments":true,"path":"2019/09/17/排序算法-冒泡排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/17/排序算法-冒泡排序/","excerpt":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止","text":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止 思路 比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数 重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数 针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; //冒泡排序 public static int[] bubbleSort(int[] arr)&#123; for(int i=0;i&lt;=arr.length;i++)&#123; boolean is_change = false; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr, j, j+1); is_change = true; &#125; &#125; //如果一次完整的遍历中,没有触发过交换，则数组已经有序 if(!is_change)&#123; break; &#125; &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"Redis常用数据结构&应用场景","slug":"Redis常用数据结构-应用场景","date":"2019-09-12T08:25:12.000Z","updated":"2019-09-19T03:17:32.614Z","comments":true,"path":"2019/09/12/Redis常用数据结构-应用场景/","link":"","permalink":"http://blog.cairui99.cn/2019/09/12/Redis常用数据结构-应用场景/","excerpt":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。","text":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。 应用场景String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。 Hash常用命令 hget($key,$field) 返回hash表中指定字段的值 hset($key,$field,$value) 设置hash中指定字段的值 hgetall($key) 返回指定key下，哈希表中所有字段和值 实现Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。 应用场景当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。 List常用命令 lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部 rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部 lpop($key) 移除指定列表的第一个元素 rpop($key) 移除指定列表的最后一个元素 lrange($key,$start,$stop) 获取指定列表指定范围内的元素 blpop($key,$timeOut) 移除指定列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 实现Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。 应用场景最新消息排行; 消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。 SetSet集合的特点是在插入元素时Redis会提供去重的功能 常用命令 sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，已经存在与集合中的元素将被忽略 spop($key) 移除集合中的一个随机元素 srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略 smembers($key) 获取指定集合中的所有元素 sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集 sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集 实现set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重 应用场景用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。 SortSet有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点 常用方法 zadd($key,$score,$value) 将一个或多个元素及其分数值加入到有序集合中，重复的元素只更新分数，并按分数重新对集合排序 zrange($key,$start,$end) 获取有序集合中指定区间内的成员信息 zrem($key,$member) 移除一个或多个成员，不存在的成员会忽略，不存在的key或key不是有序集合会返回错误 zcard($key) 获取指定有序集合中元素的数量 实现sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。 应用场景可以用于需要不重复、有序的场景中。例如各种排行榜 延迟队列","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.cairui99.cn/tags/Redis/"}]},{"title":"php中字符串与0比较问题","slug":"php中字符串与0比较问题","date":"2019-09-06T03:29:27.000Z","updated":"2019-09-06T05:49:52.518Z","comments":true,"path":"2019/09/06/php中字符串与0比较问题/","link":"","permalink":"http://blog.cairui99.cn/2019/09/06/php中字符串与0比较问题/","excerpt":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。","text":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = \"CaiRui\";if($str==0)&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = \"CaiRui\";if($str===0)&#123; echo \"===0成立\";&#125;else&#123; echo \"===0不成立\";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = \"CaiRui\";if($str==\"0\")&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。","categories":[{"name":"问题整理","slug":"问题整理","permalink":"http://blog.cairui99.cn/categories/问题整理/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.cairui99.cn/tags/php/"}]},{"title":"单一职责原则","slug":"设计原则-单一职责原则","date":"2019-09-04T12:18:10.000Z","updated":"2019-10-08T08:46:57.324Z","comments":true,"path":"2019/09/04/设计原则-单一职责原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/04/设计原则-单一职责原则/","excerpt":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法）","text":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"设计模式开篇","slug":"设计模式开篇","date":"2019-09-02T10:23:46.000Z","updated":"2019-12-03T02:42:08.010Z","comments":true,"path":"2019/09/02/设计模式开篇/","link":"","permalink":"http://blog.cairui99.cn/2019/09/02/设计模式开篇/","excerpt":"学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景，慢慢更新 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？","text":"学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景，慢慢更新 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望通过对设计模式的理解，自己可以站在一个更高的层次来审视、赏析程序代码。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.cairui99.cn/tags/设计模式/"}]}]}