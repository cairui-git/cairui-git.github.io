{"meta":{"title":"CaiRui的博客","subtitle":"坚持是一种品格","description":null,"author":"CaiRui","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-09-04T11:29:31.000Z","updated":"2019-09-04T11:30:56.221Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"待更新"},{"title":"categories","date":"2019-09-04T11:34:44.000Z","updated":"2019-09-04T11:34:59.273Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-04T11:26:46.000Z","updated":"2019-09-04T11:27:12.706Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"php中字符串与0比较问题","slug":"php中字符串与0比较问题","date":"2019-09-06T03:29:27.000Z","updated":"2019-09-06T05:46:43.909Z","comments":true,"path":"2019/09/06/php中字符串与0比较问题/","link":"","permalink":"http://yoursite.com/2019/09/06/php中字符串与0比较问题/","excerpt":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。","text":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = \"CaiRui\";if($str==0)&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = \"CaiRui\";if($str===0)&#123; echo \"===0成立\";&#125;else&#123; echo \"===0不成立\";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = \"CaiRui\";if($str==\"0\")&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。","categories":[{"name":"问题整理","slug":"问题整理","permalink":"http://yoursite.com/categories/问题整理/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"单一职责原则","slug":"单一职责原则","date":"2019-09-04T12:18:10.000Z","updated":"2019-09-06T03:27:17.774Z","comments":true,"path":"2019/09/04/单一职责原则/","link":"","permalink":"http://yoursite.com/2019/09/04/单一职责原则/","excerpt":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法）","text":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://yoursite.com/categories/知识点整理/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"设计思想","slug":"设计思想","permalink":"http://yoursite.com/tags/设计思想/"}]},{"title":"设计模式开篇","slug":"设计模式开篇","date":"2019-09-02T10:23:46.000Z","updated":"2019-09-05T03:40:12.561Z","comments":true,"path":"2019/09/02/设计模式开篇/","link":"","permalink":"http://yoursite.com/2019/09/02/设计模式开篇/","excerpt":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？","text":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是，设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring、Yii这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望在不久的将来，通过对设计模式的理解和工作经验的积累，自己可以站在一个更高的层次来审视、赏析程序代码。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"First Write","slug":"First Write","date":"2019-08-28T06:02:35.984Z","updated":"2019-09-03T03:12:34.111Z","comments":true,"path":"2019/08/28/First Write/","link":"","permalink":"http://yoursite.com/2019/08/28/First Write/","excerpt":"","text":"2019年，终于毕业了，结束了学生生涯 这次搭建了自己的网站，我会花时间来慢慢丰富这个博客 记录自己的成长.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}