{"meta":{"title":"CaiRui的博客","subtitle":"坚持是一种品格","description":null,"author":"CaiRui","url":"http://blog.cairui99.cn","root":"/"},"pages":[{"title":"tags","date":"2019-09-04T11:26:46.000Z","updated":"2019-09-06T07:19:03.047Z","comments":false,"path":"tags/index.html","permalink":"http://blog.cairui99.cn/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-04T11:34:44.000Z","updated":"2019-09-06T07:19:01.112Z","comments":false,"path":"categories/index.html","permalink":"http://blog.cairui99.cn/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-09-04T11:29:31.000Z","updated":"2019-09-06T07:18:57.504Z","comments":false,"path":"about/index.html","permalink":"http://blog.cairui99.cn/about/index.html","excerpt":"","text":"待更新"}],"posts":[{"title":"排序算法-归并排序","slug":"排序算法-归并排序","date":"2019-09-26T08:00:54.000Z","updated":"2019-09-27T03:37:48.148Z","comments":true,"path":"2019/09/26/排序算法-归并排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/26/排序算法-归并排序/","excerpt":"归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。","text":"归并排序归并排序是一种使用递归操作来实现的排序算法，采用了分治的思想 (将原问题划分为n个规模较小并与原问题结构相同的子问题,然后将子问题的结果合并，从而得到原问题的解)，归并排序是分治法的典型应用。 思路 将数组分解为各含n/2个元素的子数组，递归的拆分数组，当子数组长度为1时，默认子数组是就有序的 将两个有序的数组通过外排合并为一个有序的数组 当全部子数组合并完成时，原数组变为有序 图解 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 归并排序 * User:Cai Rui * Time:2019-09-27 */class MergeSort &#123; static void mergeSort(int[] arr)&#123; if(arr==null || arr.length&lt;2)&#123; return; &#125; mergeSort(arr,0,arr.length-1); &#125; //递归 private static void mergeSort(int[] arr,int left,int right)&#123; if(left&gt;=right)&#123; return; &#125; int mid = left - (left-right)/2; mergeSort(arr,left,mid); mergeSort(arr,mid+1,right); merge(arr,left,mid,right); &#125; private static void merge(int[] arr,int left,int mid,int right)&#123; int[] merge_arr = new int[arr.length]; int index_merge = left; int index_left = left; int index_right = mid+1; //外排 while (index_left &lt;= mid &amp;&amp; index_right &lt;= right) &#123; merge_arr[index_merge++] = (arr[index_left] &gt; arr[index_right]) ? arr[index_right++] : arr[index_left++]; &#125; int start = index_left&lt;=mid ? index_left : index_right; int end = index_left&lt;=mid ? mid : arr.length-1; for(int i=start;i&lt;=end;i++) &#123; merge_arr[index_merge++] = arr[i]; &#125; //将排好序的结果赋给原数组 System.arraycopy(merge_arr, left, arr, left, right + 1 - left); &#125;&#125; 复杂度分析最佳时间复杂度：O(n*logn) ;最差时间复杂度: O(n*logn) ;平均时间复杂度: O(n*logn) 空间复杂度: O(n) 稳定性分析稳定(在外排过程中，当遇到相等元素先存左边的数，就可以保证排序结果是稳定的)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"设计原则-依赖倒置原则","slug":"设计原则-依赖倒置原则","date":"2019-09-24T11:11:34.000Z","updated":"2019-09-26T07:40:35.262Z","comments":true,"path":"2019/09/24/设计原则-依赖倒置原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/24/设计原则-依赖倒置原则/","excerpt":"依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD.","text":"依赖倒置原则简单来说就是我们常说的 面向接口编程——OOD. 定义High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 翻译过来就是： 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 每一个逻辑的具体实现就是低层模块(一般指方法)，各种逻辑的组装就是高层模块。 抽象是指接口或者抽象类，属于不能被示例化的；细节就是可以被实例化的实现类，一般指实现接口或继承抽象类的类。 依赖倒置原则在开发过程中的体现就是： 模块间的依赖通过抽象发生，实现类之间不直接发生依赖，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 应用看一个应用到依赖倒置原则的例子： 下图是在不使用依赖倒置原则的情况下，奔驰车和驾车司机的类图设计：奔驰车中提供run方法，表示车辆运行： 12345public class Benz &#123; public void run()&#123; System.out.println(\"奔驰汽车开始运行...\"); &#125;&#125; 司机通过调用奔驰车的run方法来驾驶奔驰车： 12345public class Driver &#123; public void drive(Benz benz)&#123; benz.run(); &#125;&#125; 司机驾驶奔驰汽车的场景如下： 1234567public class Client &#123; public static void main(String[] args) &#123; Driver driver = new Driver(); Benz benz = new Benz(); driver.drive(benz); &#125;&#125; 以上代码实现了司机开动奔驰车的功能，目前为止程序的功能没有任何问题。 此时如果我们现在不仅有奔驰车，又添加了一辆宝马车，代码如下： 12345public class BMW &#123; public void run()&#123; System.out.println(\"宝马汽车开始运行...\"); &#125;&#125; 有了宝马车之后，我们发现司机竟然没有办法把宝马车开动起来，这是因为目前的司机和奔驰车是紧耦合的关系，要想让司机开动奔驰车就必须修改司机类的代码，被依赖者的变更竟然需要依赖者来承担修改的代价，可见上面的程序稳定性和可维护性都是非常差的 在比较大一些项目开发中，团队中每个人都会负责不同的模块，这里假设这个项目的团队中甲负责汽车类的维护，乙负责司机类的维护，如果按照上面的思路开发，那么在甲开发完成之前乙是不能编写drive方法，因为缺少汽车类，所以此时团队的开发工作是无法做到并行开发的，这严重影响了项目的开发效率 为了解决以上问题，对该项目引入依赖倒置原则后的类图如图所示： 列出采用依赖倒置原则的三种写法： (1)构造函数传入依赖对象 12345678910111213public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public Driver(ICar _car)&#123; this.car = _car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 通过构造函数来设置驾驶汽车的类型 (2)set方法传递依赖对象 1234567891011121314public interface IDriver &#123; public void setCar(ICar car); public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125; 在执行drive方法之前通过setCar方法来指定汽车的类型 (3)接口声明依赖对象 12345678910111213141516171819202122232425public interface IDriver &#123; public void drive(ICar car);&#125;public class Driver implements IDriver&#123; public void drive(ICar car)&#123; car.run(); &#125;&#125;public interface ICar &#123; public void run();&#125;public class Benz implements ICar&#123; public void run()&#123; System.out.println(\"奔驰汽车开始运行...\"); &#125;&#125;public class BMW implements ICar&#123; public void run()&#123; System.out.println(\"宝马汽车开始运行...\"); &#125;&#125; 业务场景实现： 1234567public class Client &#123; public static void main(String[] args) &#123; IDriver zhangSan = new Driver(); ICar benz = new Benz(); zhangSan.drive(benz); &#125;&#125; 小结为什么是依赖“倒置”：以正常人的思维方式，类之间的依赖关系是实现类之间的依赖，例如司机要开奔驰车，就直接依赖奔驰车，这种就属于“正置”；在编写程序中我们要做到的是对现实世界的事物进行抽象，来实现扩展性和维护性更高的代码，抽象就是抽象类和接口，让我们的的系统产生对抽象的依赖，代替正常人们传统的思维方式(对事物的依赖)，这就是“倒置”的含义 采用依赖倒置原则带来的好处： 减少类间的耦合性 提高系统的稳定性 降低并行开发的风险 提高代码的可读性和可维护性 在项目开发中应遵循： 实体类尽量有接口或抽象类：有抽象才能进行依赖倒置 变量的表面类型尽量是接口或抽象类 不要从具体类中派生出子类 尽量不重写父类的方法：对依赖的稳定性会有影响 采用依赖倒置原则的优势在小型项目中很难体现，一般适用于大中型项目，让项目在后续的扩展和维护中更加方便快捷稳定。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"},{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"}]},{"title":"排序算法-插入排序","slug":"排序算法-插入排序","date":"2019-09-24T06:59:35.000Z","updated":"2019-09-24T07:29:34.919Z","comments":true,"path":"2019/09/24/排序算法-插入排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/24/排序算法-插入排序/","excerpt":"插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少","text":"插入排序在工程中比较常用的O(n2)的排序算法，特点是越趋近与有序的数组，排序所花费的时间越少 思路 第一个数默认已经排好序 从第二数开始，依次和前面的数比较，遇到比自己大的就交换，遇到比自己小的或者已经到了数组头部时停止(相当于把自己插入到了正确的位置，比自己大的数往后挪了一位) 遍历数组，重复以上步骤 图解 代码12345678910111213141516171819202122public class InsertSort &#123; //插入排序 public static void insertSort(int[] arr)&#123; for(int i=0;i&lt;arr.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(arr[j]&gt;arr[j-1])&#123; break; &#125; swap(arr,j,j-1); &#125; &#125; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"排序算法-选择排序","slug":"排序算法-选择排序","date":"2019-09-23T08:59:29.000Z","updated":"2019-09-23T09:38:21.753Z","comments":true,"path":"2019/09/23/排序算法-选择排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/23/排序算法-选择排序/","excerpt":"选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2)","text":"选择排序最稳定的排序算法，任何情况下时间复杂度都是O(n2) 思路 第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置 然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾 以此类推，直到全部待排序的数据元素的个数为零 图解 代码12345678910111213141516171819202122public class SelectSort &#123; //选择排序 public static int[] selectSort(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++)&#123; int min_index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; min_index = arr[j]&lt;arr[min_index] ? j : min_index; &#125; swap(arr,i,min_index); &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n2) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析举例： 排序前：3(1号) , 3(2号) , 1 排序后：1 , 3(2号) , 3(1号) 不稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"对数器","slug":"对数器","date":"2019-09-20T07:04:04.000Z","updated":"2019-09-23T06:25:55.413Z","comments":true,"path":"2019/09/20/对数器/","link":"","permalink":"http://blog.cairui99.cn/2019/09/20/对数器/","excerpt":"对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。","text":"对数器的作用是验证算法的正确性，前提是对该题目你已知一种完全正确的答案，才可以使用对数器。 对数器一般用来 优化算法,利用正确的但效率低下的算法来验证优化之后的算法的正确性。 下面一个例子，是利用系统已有的排序函数(绝对正确的方法)来验证我自己写的排序函数mySort(正确性未知的,我们要验证的方法)的正确性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.Arrays;public class SortTest &#123; /** * 获取一个随机数组 * @param length 数组最大长度,最小为0 * @param min 最小值 * @param max 最大值 */ private static int[] getArray(int length,int min,int max)&#123; int[] arr = new int[(int)(0+Math.random()*(length+1))]; for(int i=0;i&lt;length;i++)&#123; arr[i] = (int)(min+Math.random()*(max-min+1)); &#125; return arr; &#125; //复制数组 private static int[] copyArray(int[] arr)&#123; int[] result = new int[arr.length]; for(int i=0;i&lt;arr.length;i++)&#123; result[i] = arr[i]; &#125; return result; &#125; //比较两个数组是否相等 private static boolean isEqualsArray(int[] arr1,int[] arr2)&#123; if(arr1.length!=arr2.length)&#123; return false; &#125; for(int i=0;i&lt;arr1.length;i++)&#123; if(arr1[i]!=arr2[i])&#123; return false; &#125; &#125; return true; &#125; //输出数组 private static void printArray(int[] arr)&#123; for(int num : arr)&#123; System.out.print(num+\" \"); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; boolean is_right = true; int[] fail_array = new int[10]; //测试次数 int test_num = 100000; for(int i=0;i&lt;test_num;i++)&#123; //生成一个长度为 0~10，值为 1~20之间的随机数组,并生成两个复制来进行排序 int[] arr = SortTest.getArray(10, 1, 20); int[] arrA = SortTest.copyArray(arr1); int[] arrB = SortTest.copyArray(arr1); //执行排序 Arrays.sort(arrA); MySort.mySort(arrB); //比较结果是否相等 if(!SortTest.isEqualsArray(arrA, arrB))&#123; is_right = false; fail_array = arr; break; &#125; &#125; if(is_right)&#123; System.out.println(\"Success!\"); &#125;else&#123; System.out.println(\"Fail!\"); System.out.println(); System.out.print(\"Fail Array:\"); SortTest.printArray(fail_array); &#125; &#125;&#125; 校验mySort步骤： 生成一个长度随机，值也随机的数组 获取两个刚刚随机生成的数组的复制，分别用正确的sort方法和待验证的mysort方法进行排序 比较排好序的两个数组是否相等 若不相等则说明算法是错的，把排序失败的数组打印出来，方便排查问题出在哪 相等则说明该条测试用例可以通过，继续重复以上步骤，我这里重复了10万次，当然次数越多越好，这样几乎可以涵盖所有的可能，可以说明该算法是正确的 对数器的好处在于测试用例不再需要自己设计了，通过随机生成的庞大样本量，就可以保证算法的正确性，自己想测试用例的话总会出现情况考虑不全的时候，到时程序出bug的话就得不偿失了。","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[]},{"title":"设计原则-里氏替换原则","slug":"设计原则-里氏替换原则","date":"2019-09-19T03:07:34.000Z","updated":"2019-09-26T07:40:41.704Z","comments":true,"path":"2019/09/19/设计原则-里氏替换原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/19/设计原则-里氏替换原则/","excerpt":"在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。","text":"在学习里氏替换原则之前，可以先简单复习下 继承 一个事物的存在，总是优点和缺点并存的，继承也一样，所以我们要做的就是把它用在最合适的地方，让继承的优点充分的发挥，同时规避缺点带来的影响。 那么如何实现呢？解决方案就是引入里氏替换原则。 定义那什么是里氏替换原则呢？它有两种定义： 第一种：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.(如果对每一个类型为S的对象o1，都有类型为T的对象o2，,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为什么发生变化，那么类型S是类型T的子类型) 第二种：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.(所有引用基类的地方必须能透明的使用其子类的对象) 第一种是比较官方、正宗的定义，不是很好理解，感觉像是高数里面的某种概念。我们看第二种，第二种是定义是比较清晰的，解释一下就是：所有可以使用父类的地方，把父类替换为子类后，程序运行时不会体现出任何的异常，使用者甚至不需要关心使用的是父类和子类。 但反过来就未必可以，使用子类的地方换成父类就不能保证程序不会出错，因为子类可以有父类没有的属性和方法。 继承的使用规范知道了什么是里氏替换原则，那么具体应该怎么做呢？ (1)子类必须完全实现父类的方法： 如果子类不能完整的实现父类的方法，或者父类的方法不适合该子类，这种情况下继承带来的效果就属于弊大于利，因为子类无法完整地实现父类的业务，此时建议解除继承关系，采用依赖、聚集、组合等关系代替来继承。 (2)覆盖或实现父类的方法时输入参数可以被放大，不可以被缩小： 例如： 123456789101112131415public class Father &#123; public void doSomething(HashMap map)&#123; System.out.println(\"父类被执行\"); &#125;&#125;public class Son extends Father &#123; public void doSomething(Map map)&#123; System.out.println(\"子类被执行\"); &#125;&#125; 子类实现了一个和父类同名的方法，虽然方法名相同，但方法的输入参数不同，这样的方式就保证了子类对父类的方法进行了 重载 而非 重写 ，看具体的场景： 1234567891011public class Client &#123; public static void main(String[] args) &#123; Father f = new Father(); Son s = new Son(); HashMap hashmap = new HashMap(); f.doSomething(hashmap); s.doSomething(hashmap); &#125;&#125; 执行结果： 12父类被执行父类被执行 可以看到我们把调用父类的地方换成了子类，结果依然调用了父类的方法，对程序和业务逻辑没有造成影响，这样就符合了里氏替换原则。 如果子类的参数范围缩小的话，在引用里氏替换原则后执行结果就会变为 子类被执行，这样就会引起物业逻辑混乱，因为父类已经抽象好了方法，而子类“曲解”了父类的意图。 所以子类的覆写父类的方法时，只能让输入参数的范围扩大或相同，不能缩小。 (3)重写父类的方法时输出结果可以被缩小，不能扩大 小结采用里氏替换原则的目的就是增强程序的健壮性，在版本升级时也可以保持非常好的兼容性。保证即使增加子类，原有的子类也可以正常运行。在实际项目中每个子类在同的业务中，使用父类作为参数来实现不同的业务逻辑。 以上内容参考&lt;&lt;设计模式之禅&gt;&gt;","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"},{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"}]},{"title":"浅谈继承的特点","slug":"浅谈继承的特点","date":"2019-09-18T06:16:36.000Z","updated":"2019-09-18T07:38:59.489Z","comments":true,"path":"2019/09/18/浅谈继承的特点/","link":"","permalink":"http://blog.cairui99.cn/2019/09/18/浅谈继承的特点/","excerpt":"继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。","text":"继承是面向对象语言的一大特点，是开发中实现代码复用的主要手段，被继承的类叫做父类，继承父类的叫做子类，子类继承父类之后就自动拥有了父类的方法和属性。 特点： 子类继承后自动拥有父类所有的非private属性和方法,父类的构造方法无法被继承 子类可以拥有自己的属性和方法 子类可以重写从父类继承过来的方法，但方法的访问权限只能扩大或不变，不能缩小(public&gt;protect&gt;(默认)&gt;private) 当创建一个子类对象时，会先调用父类的构造方法，再调用子类的构造方法 被关键字final修饰的类无法被继承 支持向下转型，例如：123//通过父类创建子类Person person = new Teacher();Teacher teacher = (Teacher)p; 优点： 提高代码的复用性，减少工作量 提高代码的可读性，让层次更清晰 提高代码的易维护性：所有子类共用父类的方法，方法变更时只需修改父类一处 提高代码的拓展性：子类可实现特有的方法 缺点： 继承是侵入的，只要继承，子类就必须拥有父类的所有非私有的属性和方法 继承是高耦合的形式：当父类修改方法时，需要考虑对所有子类的影响，如果有子类重写了该方法，可能会造成非常严重的后果","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.cairui99.cn/tags/基础知识/"}]},{"title":"排序算法-冒泡排序","slug":"排序算法-冒泡排序","date":"2019-09-17T03:45:02.000Z","updated":"2019-09-23T09:35:57.142Z","comments":true,"path":"2019/09/17/排序算法-冒泡排序/","link":"","permalink":"http://blog.cairui99.cn/2019/09/17/排序算法-冒泡排序/","excerpt":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止","text":"冒泡排序一种简单的排序，比较相邻的两个元素，如果顺序错误就交换顺序，重复的遍历数组直到排好序为止 思路 比较数组中第一个数和第二个数，把较大的放在第二个位置上，之后比较第二数和第三个数 重复以上步骤直到比较完最后一个数，现在最后一个数就是最大的数 针对数组中第1个数到第n(数组长度-遍历次数)个数重复以上步骤，直至数组有序 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; //冒泡排序 public static int[] bubbleSort(int[] arr)&#123; for(int i=0;i&lt;=arr.length;i++)&#123; boolean is_change = false; for(int j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; swap(arr, j, j+1); is_change = true; &#125; &#125; //如果一次完整的遍历中,没有触发过交换，则数组已经有序 if(!is_change)&#123; break; &#125; &#125; return arr; &#125; //交换位置 private static void swap(int[] arr,int n,int m)&#123; int temp = arr[n]; arr[n] = arr[m]; arr[m] = temp; &#125;&#125; 复杂度分析最佳时间复杂度：O(n) ;最差时间复杂度: O(n2) ;平均时间复杂度: O(n2) 空间复杂度: O(1) 稳定性分析稳定 (保证比较相同数值时不做交换即可)","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.cairui99.cn/categories/算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://blog.cairui99.cn/tags/排序算法/"}]},{"title":"Redis常用数据结构&应用场景","slug":"Redis常用数据结构-应用场景","date":"2019-09-12T08:25:12.000Z","updated":"2019-09-19T03:17:32.614Z","comments":true,"path":"2019/09/12/Redis常用数据结构-应用场景/","link":"","permalink":"http://blog.cairui99.cn/2019/09/12/Redis常用数据结构-应用场景/","excerpt":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。","text":"String常用命令 get($key) 获取key的值 set($key,$value) 设置key的值 incr($key) 将key的值+1 decr($key) 将key的值-1 mget($key1,$key2,…) 获取多个key的值 实现String是最常用的数据类型，普通的key-value都可归为此类，value除了String也可存储json、数字;Redis使用自己定义的结构SDS来实现String,详见&lt;&lt;Redis设计与实现&gt;&gt;。 应用场景String用来存储简单的键值信息，用途广泛，例如用户信息、登陆信息、配置信息、使用记录、增减库存等等。在使用时要注意存储的值不要过大，最好不要超过1M。 Hash常用命令 hget($key,$field) 返回hash表中指定字段的值 hset($key,$field,$value) 设置hash中指定字段的值 hgetall($key) 返回指定key下，哈希表中所有字段和值 实现Redis的Hash的Value内部实际是HashMap，当成员较少时会当成数组存储，当成员数量增大时会转成HashMap存储。 应用场景当存储用户信息时，信息例如 （user：001 张三 19 2019-11-15）。当使用常用的String类型存储时需要对取出的value做相应的处理才可以使用。这时可以最好用hset来存储用户信息。 List常用命令 lpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的头部 rpush($key,$value1,($value2),($value3)…) 将一个或多个值插入指定列表的尾部 lpop($key) 移除指定列表的第一个元素 rpop($key) 移除指定列表的最后一个元素 lrange($key,$start,$stop) 获取指定列表指定范围内的元素 blpop($key,$timeOut) 移除指定列表第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 实现Redis的List实现是一个双向链表，可以支持反向查找和遍历，更方便的操作，也便随着更大的内存开销。Redis内部的很多实现，包括缓冲队列都是用过List实现的。 应用场景最新消息排行; 消息队列：将任务存在list中，然后工作线程利用pop操作将任务取出执行。但要注意Redis的队列是轻量级的，适合处理轻量级的任务，Redis中并没有队列重试、队列重放等机制，消费完的消息相当于在Redis中删除了。 SetSet集合的特点是在插入元素时Redis会提供去重的功能 常用命令 sadd($key,$value1,($value2),($value3)…) 将一个或多个元素放入集合中，已经存在与集合中的元素将被忽略 spop($key) 移除集合中的一个随机元素 srem($key,$value1,($value2),($value3)…) 移除集合中一个或多个元素，不存在的元素会忽略 smembers($key) 获取指定集合中的所有元素 sdiff($key1,$key2,($key3),…) 返回给定集合之间的差集，不存在的集合key将视为空集 sunion($key1,$key2,($key3),…) 返回给定集合之间的并集，不存在的集合key将视为空集 实现set内部实现是一个value永远为null的HashMap，通过hash的方式进行快速去重 应用场景用于记录或判断一些不能重复的数据。例如每个用户每天只能投票一次的投票系统，可以用set记录用户的投票情况。 SortSet有序集合，集合中的每个元素除了key和value还有一个score属性，在sortset集合中会将元素按照score排序，SortSet也具备Set集合value值唯一的特点 常用方法 zadd($key,$score,$value) 将一个或多个元素及其分数值加入到有序集合中，重复的元素只更新分数，并按分数重新对集合排序 zrange($key,$start,$end) 获取有序集合中指定区间内的成员信息 zrem($key,$member) 移除一个或多个成员，不存在的成员会忽略，不存在的key或key不是有序集合会返回错误 zcard($key) 获取指定有序集合中元素的数量 实现sortset的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，跳跃表里存放的是所有的成员信息，排序依据是HashMap里存的score，在使用跳跃表来实现查找。 应用场景可以用于需要不重复、有序的场景中。例如各种排行榜 延迟队列","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.cairui99.cn/tags/Redis/"}]},{"title":"php中字符串与0比较问题","slug":"php中字符串与0比较问题","date":"2019-09-06T03:29:27.000Z","updated":"2019-09-06T05:49:52.518Z","comments":true,"path":"2019/09/06/php中字符串与0比较问题/","link":"","permalink":"http://blog.cairui99.cn/2019/09/06/php中字符串与0比较问题/","excerpt":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。","text":"由于刚转php不久，今天在开发中踩了个比较低级的坑，记录一下。 问题是 在代码中我用一个 字符串和0作比较，结果竟然是 相等。 后来自己写了一个例子验证： 123456789&lt;?php$str = \"CaiRui\";if($str==0)&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0成立 发现问题后上网查了一下，原因是由于php是弱类型语言，在比较之前php的内部会把进行比较的两个变量转换为相同的类型，这里应该是把str强转成了int型，导致结果变成了true。 最后列出一些可以得到正确结果的写法： 123456789&lt;?php$str = \"CaiRui\";if($str===0)&#123; echo \"===0成立\";&#125;else&#123; echo \"===0不成立\";&#125;输出：===0不成立 ===：三个等于号的意思是先比较类型，如果类型不同直接返回false，若类型相同在比较两个变量的值。在这个例子中if($str===0)就相当于if（is_numeric($str) &amp;&amp; $str==0） 123456789&lt;?php$str = \"CaiRui\";if($str==\"0\")&#123; echo \"==0成立\";&#125;else&#123; echo \"==0不成立\";&#125;输出：==0不成立 也可以将0改为字符串，这样进行比较的两个变量类型相同，==将会返回预期的结果。这种写法不会影响str值为0时的预期结果。","categories":[{"name":"问题整理","slug":"问题整理","permalink":"http://blog.cairui99.cn/categories/问题整理/"}],"tags":[{"name":"php","slug":"php","permalink":"http://blog.cairui99.cn/tags/php/"}]},{"title":"设计原则-单一职责原则","slug":"设计原则-单一职责原则","date":"2019-09-04T12:18:10.000Z","updated":"2019-09-18T02:57:30.614Z","comments":true,"path":"2019/09/04/设计原则-单一职责原则/","link":"","permalink":"http://blog.cairui99.cn/2019/09/04/设计原则-单一职责原则/","excerpt":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法）","text":"There should never be more than one reason for a class to change. 单一职责原则是指在设计类时需要保证有且仅有一个原因引起类的变更，也就是说这个类有且仅有一个职责。（单一职责原则同样适用于接口和方法） 看几个例子： （1）下图是一个简单的维护用户信息的类图，看看有什么问题（参照《设计模式之禅》）： 图1-1 用户信息类图 问题比较明显，用户的属性和用户的行为没有分开，应该把用户的属性抽去成一个业务对象，用户的抽取成业务逻辑，修改结果如下图： 图1-2 划分职责后的用户类图 按职责划分，IUserBO的职责就是收集和反馈用户的属性信息，IUserBiz的职责就是负责实现用户的各种行为，进行对用户属性的维护和变更。这种设计更加接近于单一职责原则（有且仅有一个原因引起类的变更）。 (2)第二个例子,现在我们需求是拍照和播放音乐，代码如下（参照《大话设计模式》）： 123456789101112131415161718192021222324252627//具有照相的功能的接口interface IPhotograph&#123; void Photograph();&#125;//具有播放音乐功能的接口interface IPlayMusic&#123; void PlayMusic();&#125;//实现照相、播放音乐的手机类public class MobilePhone : IPhotograph, IPlayMusic&#123; //拍照 public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125; //播放音乐 public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125; 根据需求，我们设计了一部可以照相、播放音乐的手机类，满足了现有的需求；但有一天我们的需求发生了变化，简单的拍照功能无法满足现有的需求，我们需要能够拍摄高清照片的功能，这时我们需要去直接修改手机，并且不知道修改拍照功能是否会对播放音乐功能产生影响。这是因为手机类有了两个职责，而无论哪一个职责发生变化，我们都要去改变手机。 所以，为了满足单一职责原则，我们可以把手机中的两种职责抽去出来，变成一台照相机和一台音乐播放器，这样在功能需求变化的时候，我们只需要关心引起变化的原因，不必考虑需求的变化对其他功能的影响。 1234567891011121314151617//实现播放音乐功能的音乐播放器类class MusicPlayer : IPlayMusic&#123; public void PlayMusic() &#123; Console.WriteLine(\"播放音乐\"); &#125;&#125;//实现照相功能的摄像机类class Carmera : IPhotograph&#123; public void Photograph() &#123; Console.WriteLine(\"拍照片\"); &#125;&#125; 好，既然需求是拍照片和播放音乐，我们现在有了一部相机和播放器，如果想要拍照，就调用相机的拍照方法，想要放音乐，就调用播放器的播放方法。之后如果拍照功能发生改变，我们就去改变相机，播放功能改变我们就去改变播放去。我们只需要关心引起变化的功能，而不再需要考虑需求改变后对其他功能的影响。 我们一定要遵循单一职责原则吗？从上面的例子来看，改动相对简单。但往往许多时候，需求不会在系统设计时就发生改变，而是在上线迭代了一定程度之后，在系统已经有了充分的代码量之后，到时候如果一味的执行单一职责原则来修改成本必定很高，所以我们在改动时需要根据具体情况来选择更合适的改动方案。例如上面的例子，我们不直接拆分手机类，而是让手机类拥有一个相机类和播放器类，然后具体功能调用对应类的方法，这样改动较小，又达到了我们的最终目的。 小结在实际的项目开发中类的“职责”还是需要看情况而定，通常我们会将单一职责原则应用于开发接口或者方法时使用，一味的实现类的单一职责原则，会引起类间的耦合过重、类的数量、开发成本的增加、人为的加大了代码的复杂性，所以在使用时要适度，要看情况而定。","categories":[{"name":"知识点整理","slug":"知识点整理","permalink":"http://blog.cairui99.cn/categories/知识点整理/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"},{"name":"设计原则","slug":"设计原则","permalink":"http://blog.cairui99.cn/tags/设计原则/"}]},{"title":"设计模式开篇","slug":"设计模式开篇","date":"2019-09-02T10:23:46.000Z","updated":"2019-09-12T09:49:57.553Z","comments":true,"path":"2019/09/02/设计模式开篇/","link":"","permalink":"http://blog.cairui99.cn/2019/09/02/设计模式开篇/","excerpt":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？","text":"今天开设一个新的模块-设计模式 学习途径：&lt;&lt;设计模式之禅&gt;&gt;、以及相关内容的博客 其中包括：6大设计原则，以及根据设计原则衍生出的23种设计模式及其使用场景 前言不知道你有没有这样的经历，在一次需求变更中，明明只是在系统中添加或修改一点小小的功能，但当看到代码准备着手开发时，却发现系统现有的架构无法满足我们的需求，有时真的可以说是伤筋动骨，甚至直接重构。 为什么我们只有在需求变更时才想到更好的实现方案呢，如何才能做到让我们的系统持续的拥抱变化呢？ 那就是，设计模式！ What设计模式它是一套理论，是前人们踩过无数坑后，总结出的一套可以反复使用的设计程序的经验。在合适的场景使用它可以提高代码的可重用性，增强系统的可维护性，以及轻松解决复杂的需求。 Why选择设计模式，是因为它具备的广泛适应性，学习设计模式可以让我们设计出更优秀的代码，就算我们在工作中去做了其他业务，甚至更换的编程语言，设计模式的知识依然可以用到。 How对于设计模式，在这次的学习中不求自己可以完全的理解、熟练的掌握它，因为它本身就不是一种工具，和Spring、Yii这种工具类的框架不同，它属于一种指导思想，理解并掌握设计模式需求大量的工作经验做积累。 只求学习过后在开发中，对程序的设计可以有更多的选择，可以偶然想到，这里可以这么做，某种设计模式提供了更好的方法；在遇到之前觉得非常复杂的需求时，可以找到一种优雅的解决方案。 希望在不久的将来，通过对设计模式的理解和工作经验的积累，自己可以站在一个更高的层次来审视、赏析程序代码。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.cairui99.cn/tags/设计模式/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://blog.cairui99.cn/tags/读书笔记/"}]},{"title":"First Write","slug":"First Write","date":"2019-08-28T06:02:35.984Z","updated":"2019-09-03T03:12:34.111Z","comments":true,"path":"2019/08/28/First Write/","link":"","permalink":"http://blog.cairui99.cn/2019/08/28/First Write/","excerpt":"","text":"2019年，终于毕业了，结束了学生生涯 这次搭建了自己的网站，我会花时间来慢慢丰富这个博客 记录自己的成长.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://blog.cairui99.cn/tags/随笔/"}]}]}